<!-- build time:Mon Mar 28 2022 12:55:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html style="display:none" lang="zh"><head><meta charset="utf-8"><script>window.materialVersion="1.5.6",window.oldVersion=["codestartv1","1.3.4","1.4.0","1.4.0b1","1.5.0","1.5.2","1.5.5"]</script><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn1.lncld.net"><link rel="dns-prefetch" href="https://cdn1.lncld.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Java 多线程学习 | 帆的自留地</title><link rel="icon shortcut" type="image/ico" href="/img/logo-32x32.jpg"><link rel="icon" href="/img/logo-192x192.jpg"><meta name="format-detection" content="telephone=no"><meta name="description" itemprop="description" content="晓帆的学习笔记"><meta name="keywords" content="博客,代码,学习,程序,大学,java"><meta name="theme-color" content="#1e69bf"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]--><script>!function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}},lsloader.removeLS=function(e){try{localStorage.removeItem(e)}catch(t){}},lsloader.setLS=function(e,t){try{localStorage.setItem(e,t)}catch(n){}},lsloader.getLS=function(e){var t="";try{t=localStorage.getItem(e)}catch(n){t=""}return t},versionString="/*"+(window.materialVersion||"unknownVersion")+"*/",lsloader.clean=function(){try{for(var e=[],t=0;t<localStorage.length;t++)e.push(localStorage.key(t));e.forEach(function(e){var t=lsloader.getLS(e);if(window.oldVersion){var n=window.oldVersion.reduce(function(e,n){return e||-1!==t.indexOf("/*"+n+"*/")},!1);n&&lsloader.removeLS(e)}})}catch(n){}},lsloader.clean(),lsloader.load=function(e,t,n,s){"boolean"==typeof n&&(s=n,n=void 0),s=s||!1,n=n||function(){};var a;if(a=this.getLS(e),a&&-1===a.indexOf(versionString))return this.removeLS(e),void this.requestResource(e,t,n,s);if(a){var o=a.split(versionString)[0];if(o!=t)return console.log("reload:"+t),this.removeLS(e),void this.requestResource(e,t,n,s);a=a.split(versionString)[1],s?(this.jsRunSequence.push({name:e,code:a}),this.runjs(t,e,a)):(document.getElementById(e).appendChild(document.createTextNode(a)),n())}else this.requestResource(e,t,n,s)},lsloader.requestResource=function(e,t,n,s){var a=this;s?this.iojs(t,e,function(e,t,n){a.setLS(t,e+versionString+n),a.runjs(e,t,n)}):this.iocss(t,e,function(n){document.getElementById(e).appendChild(document.createTextNode(n)),a.setLS(e,t+versionString+n)},n)},lsloader.iojs=function(e,t,n){var s=this;s.jsRunSequence.push({name:t,code:""});try{var a=new XMLHttpRequest;a.open("get",e,!0),a.onreadystatechange=function(){if(4==a.readyState){if((a.status>=200&&a.status<300||304==a.status)&&""!=a.response)return void n(e,t,a.response);s.jsfallback(e,t)}},a.send(null)}catch(o){s.jsfallback(e,t)}},lsloader.iocss=function(e,t,n,s){var a=this;try{var o=new XMLHttpRequest;o.open("get",e,!0),o.onreadystatechange=function(){if(4==o.readyState){if((o.status>=200&&o.status<300||304==o.status)&&""!=o.response)return n(o.response),void s();a.cssfallback(e,t,s)}},o.send(null)}catch(r){a.cssfallback(e,t,s)}},lsloader.iofonts=function(e,t,n,s){var a=this;try{var o=new XMLHttpRequest;o.open("get",e,!0),o.onreadystatechange=function(){if(4==o.readyState){if((o.status>=200&&o.status<300||304==o.status)&&""!=o.response)return n(o.response),void s();a.cssfallback(e,t,s)}},o.send(null)}catch(r){a.cssfallback(e,t,s)}},lsloader.runjs=function(e,t,n){if(t&&n)for(var s in this.jsRunSequence)this.jsRunSequence[s].name==t&&(this.jsRunSequence[s].code=n);if(this.jsRunSequence[0]&&this.jsRunSequence[0].code&&"failed"!=this.jsRunSequence[0].status){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code)),a.type="text/javascript",document.getElementsByTagName("head")[0].appendChild(a),this.jsRunSequence.shift(),this.jsRunSequence.length>0&&this.runjs()}else if(this.jsRunSequence[0]&&"failed"==this.jsRunSequence[0].status){var o=this,a=document.createElement("script");a.src=this.jsRunSequence[0].path,a.type="text/javascript",this.jsRunSequence[0].status="loading",a.onload=function(){o.jsRunSequence.shift(),o.jsRunSequence.length>0&&o.runjs()},document.body.appendChild(a)}},lsloader.tagLoad=function(e,t){this.jsRunSequence.push({name:t,code:"",path:e,status:"failed"}),this.runjs()},lsloader.jsfallback=function(e,t){if(!this.jsnamemap[t]){this.jsnamemap[t]=t;for(var n in this.jsRunSequence)this.jsRunSequence[n].name==t&&(this.jsRunSequence[n].code="",this.jsRunSequence[n].status="failed",this.jsRunSequence[n].path=e);this.runjs()}},lsloader.cssfallback=function(e,t,n){if(!this.cssnamemap[t]){this.cssnamemap[t]=1;var s=document.createElement("link");s.type="text/css",s.href=e,s.rel="stylesheet",s.onload=s.onerror=n;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(s,a)}},lsloader.runInlineScript=function(e,t){var n=document.getElementById(t).innerText;this.jsRunSequence.push({name:e,code:n}),this.runjs()}}()</script><script>function Queue(){function e(e){this.debug&&console.log("Offered a Queued Function."),"function"==typeof e?this.dataStore.push(e):console.log("You must offer a function.")}function t(){return this.debug&&console.log("Polled a Queued Function."),this.dataStore.shift()}function o(){var e=this.poll();void 0!==e&&(this.debug&&console.log("Run a Queued Function."),e())}function u(){this.debug=!0}this.dataStore=[],this.offer=e,this.poll=t,this.execNext=o,this.debug=!1,this.startDebug=u}var queue=new Queue</script><style id="material_css"></style><script>"undefined"==typeof window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("material_css","/css/material.min.css?lfwTSCk5dU0gSgC//hS81g==",function(){"undefined"==typeof window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="style_css"></style><script>"undefined"==typeof window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("style_css","/css/style.min.css?vOFJu+pZl+0Eeqi7pGRHyw==",function(){"undefined"==typeof window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="prettify_css"></style><script>"undefined"==typeof window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){"undefined"==typeof window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="prettify_theme"></style><script>"undefined"==typeof window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("prettify_theme","/css/prettify/atelier-cave-dark.min.css?P8HZcYCbr9fq5dAvzZGnUQ==",function(){"undefined"==typeof window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style>body,html{font-family:Roboto,"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;overflow-x:hidden!important}code{font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace}a{color:#0158bc}#scheme-Paradox .hot_tags-count,#scheme-Paradox .sidebar-colored .sidebar-badge,#scheme-Paradox .sidebar-colored .sidebar-header,#scheme-Paradox .sidebar_archives-count,#search-form-label:after,#search-label,.mdl-card__media{background-color:#1e69bf!important}#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus,#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover{color:#1e69bf!important}#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a,#post_entry-right-info,.sidebar-colored .sidebar-nav li:hover>a,.sidebar-colored .sidebar-nav li:hover>a i,.sidebar-colored .sidebar-nav li>a:focus i,.sidebar-colored .sidebar-nav li>a:hover,.sidebar-colored .sidebar-nav li>a:hover i,.sidebar-colored .sidebar-nav>.open>a,.sidebar-colored .sidebar-nav>.open>a:focus,.sidebar-colored .sidebar-nav>.open>a:hover{color:#1e69bf!important}.toTop{background:#6baaf2!important}.material-layout .material-index>.material-nav,.material-layout .material-post>.material-nav,.material-nav a{color:#6baaf2}#scheme-Paradox .MD-burger-layer{background-color:#6baaf2}#scheme-Paradox #post-toc-trigger-btn{color:#6baaf2}.post-toc a:hover{color:#0158bc;text-decoration:underline}</style><style>body{background-image:url(/img/bg.jpg)}</style><style>.fade{transition:all .8s linear;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}.fade.out{opacity:0}</style><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet"><style id="material_icons"></style><script>"undefined"==typeof window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){"undefined"==typeof window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==",!0)</script><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="帆的自留地"><meta name="msapplication-starturl" content="https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"><meta name="msapplication-navbutton-color" content="#1e69bf"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="帆的自留地"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/img/logo-180x180.jpg"><link rel="alternate" type="application/atom+xml" href="feed.xml"><meta property="og:url" content="https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"><meta property="og:type" content="blog"><meta property="og:title" content="Java 多线程学习 | 帆的自留地"><meta property="og:image" content="/img/logo-192x192.jpg"><meta property="og:description" content="晓帆的学习笔记"><meta property="og:article:tag" content="java"><meta property="article:published_time" content="Mon May 25 2020 14:23:44 GMT+0800"><meta property="article:modified_time" content="Sun May 23 2021 13:25:36 GMT+0800"><meta name="twitter:card" content="summary_large_image"><link rel="canonical" href="https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html"><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html",
    "headline": "Java 多线程学习",
    "datePublished": "Mon May 25 2020 14:23:44 GMT+0800",
    "dateModified": "Sun May 23 2021 13:25:36 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "EmptinessBoy",
        "image": {
            "@type": "ImageObject",
            "url": "/img/fav_300.png"
        },
        "description": "啥都不会，<br>专业制造BUG的<br>学渣一枚<br><br>"
    },
    "publisher": {
        "@type": "Organization",
        "name": "帆的自留地",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/logo-192x192.jpg"
        }
    },
    "keywords": ",java博客,代码,学习,程序,大学",
    "description": "晓帆的学习笔记",
}</script><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-85449259-2","auto"),ga("send","pageview")</script><meta name="generator" content="Hexo 4.2.0"></head><body id="scheme-Paradox" class="lazy"><div class="material-layout mdl-js-layout has-drawer is-upgraded"><main class="material-layout__content" id="main"><div id="top"></div><button class="MD-burger-icon sidebar-toggle"><span id="MD-burger-id" class="MD-burger-layer"></span></button> <button id="post-toc-trigger-btn" class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">format_list_numbered</i></button><ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh;overflow-y:scroll"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建线程"><span class="post-toc-number">1.</span> <span class="post-toc-text">创建线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#直接继承-Thread"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">直接继承 Thread</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现-Runnable-接口"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">实现 Runnable 接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#法A：创建多个线程对象"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">法A：创建多个线程对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#法B：仅创建一个线程的对象（推荐）"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">法B：仅创建一个线程的对象（推荐）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程同步"><span class="post-toc-number">2.</span> <span class="post-toc-text">线程同步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同步代码块"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">同步代码块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#语法规范"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">语法规范</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现案例"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">实现案例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同步方法"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">同步方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现案例-1"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">实现案例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁问题"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">死锁问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#生命周期"><span class="post-toc-number">3.</span> <span class="post-toc-text">生命周期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#几个阶段"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">几个阶段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#新建状态-New"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">新建状态(New)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#就绪状态-Runnable"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">就绪状态(Runnable)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#运行状态-Running"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">运行状态(Running)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#阻塞状态-Blocked"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">阻塞状态(Blocked)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#死亡状态-Terminated"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">死亡状态(Terminated)</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程的调度"><span class="post-toc-number">4.</span> <span class="post-toc-text">线程的调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程的优先级"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">线程的优先级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程休眠"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">线程休眠</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程让步"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">线程让步</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程插队"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">线程插队</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程协作关系"><span class="post-toc-number">5.</span> <span class="post-toc-text">线程协作关系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#wait-和-notify"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">wait() 和 notify()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注意事项"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程停止"><span class="post-toc-number">6.</span> <span class="post-toc-text">线程停止</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么弃用-stop-和-suspend"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">为什么弃用 stop 和 suspend</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正确的终止一个线程"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">正确的终止一个线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#补充"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">补充</span></a></li></ol></li></ol></li></ol></ul><div class="material-post_container"><div class="material-post mdl-grid"><div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col"><div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(https://media.everdo.cn/tank/pic-bed/2020/02/26/java.jpg)"><p class="article-headline-p">Java 多线程学习</p></div><div class="mdl-color-text--grey-700 mdl-card__supporting-text meta"><div id="author-avatar"><img src="/img/fav_300.png" width="44px" height="44px" alt="Author Avatar"></div><div><strong>EmptinessBoy</strong> <span>5月 25, 2020</span></div><div class="section-spacer"></div><button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">devices other</i> <span class="visuallyhidden">devices other</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button"><li class="mdl-menu__item">在其它设备中阅读本文章</li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAADjElEQVR42u3ay27bQBAEQP//TydXA4aU7pldWgGKJ8GSRW750J7H1x/Xt+sLAQ4cOHDgwIEDBw4cH8zxFV+vPv/95z9f//yt/CfvP/nqdX4WHDhw4MBxj+MfURQfI/nkq+9//yTvsWZnwYEDBw4ctzmSEE0o24fO75jfNz8LDhw4cOD4XY62QMrD+/3378s5HDhw4MDxmRxtgZQUgW3pOPuz4cCBAweO5zlmh9xEdR7A7bsP9Upx4MCBA8ehhYZPfv0L+x04cODAgWNxJTHZsiYrC/t25MsT4cCBAweOoxxn1+A2h5l9Q7tIMeyV4sCBAweONUdCM1s+aIvDU0sPOHDgwIHjGY62DMtDcVb4Jd+TD8aid3HgwIEDxwWOvMW2GQu1Lcj8qJt2IQ4cOHDguMGxabElj16XVXGjcDMkw4EDBw4cz3DMAnK2vpBE7Iwgvy8OHDhw4DjLka8vzJp9ebgmYb8ZOOHAgQMHjuc52qDavNsWhPnrtjWJAwcOHDjOcsxCbtZYbOFmd6wHaThw4MCB4wJHXsjlDbu8wJvdJS84ceDAgQPHkxynGnltKCaHyT+zKedw4MCBA8cNjnaB4H34nfq2nHvzR8WBAwcOHPc42kIraTLmo6kcNx9ZHZjC4cCBAweOBUdeqrVjpNlwqx1HtXw4cODAgeMGR/tFeZjV45/yqG08RyUcDhw4cOA4xJHfJonAPFDzGJ5FfvSEOHDgwIHjcY683MpDbkbfhncU8Dhw4MCB4yjHbAXh1KgpLyZn0R41HHHgwIEDxwWOPDLzZmLb/svLszzao5ISBw4cOHAc5ciHT0nLr11ouEHT/qOAAwcOHDie4cgj9t5Rh2MkHDhw4MDxARztAvT+ADl9viSRD7Rw4MCBA8c9jrzcahcO2rFQHvazdmG90IADBw4cOEYcm7WDNp7bdYdNSZk3CnHgwIEDxw2OzcpCErp5YM8Kts3wCQcOHDhw3ODIr3ZZrW0LtsOq2VAKBw4cOHDc42iDKoquOHrbVuOsNVmUcDhw4MCB4xBHPnZqC7NNQdhyDyMZBw4cOHBc42jbfLOVuBllW/4VZ8GBAwcOHL/K0QZbcoDkedpIxoEDBw4c/y/HbOy0KcCS3y0GUThw4MCB4xrHrNCaPeimUExYk5/gwIEDB457HLPm2qxsS46UtxTbfwJw4MCBA8dtDhcOHDhw4MCBAwcOHDg+7PoLf8Ev4O5UtsAAAAAASUVORK5CYII="></ul><button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">bookmark</i> <span class="visuallyhidden">bookmark</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button"><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/java/" rel="tag">java</a></li></ul><button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">share</i> <span class="visuallyhidden">share</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button"><a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Java 多线程学习&url=https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html&pic=https://coding.emptinessboy.com/img/logo-32x32.jpg&searchPic=false&style=simple" target="_blank"><li class="mdl-menu__item">分享到微博</li></a><a class="post_share-link" href="https://twitter.com/intent/tweet?text=Java 多线程学习&url=https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html&via=EmptinessBoy" target="_blank"><li class="mdl-menu__item">分享到 Twitter</li></a><a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html" target="_blank"><li class="mdl-menu__item">分享到 Facebook</li></a><a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=帆的自留地&title=Java 多线程学习&summary=晓帆的学习笔记&pics=https://coding.emptinessboy.com/img/logo-32x32.jpg&url=https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html" target="_blank"><li class="mdl-menu__item">分享到 QQ</li></a><a class="post_share-link" href="https://telegram.me/share/url?url=https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html&text=Java 多线程学习" target="_blank"><li class="mdl-menu__item">分享到 Telegram</li></a></ul></div><div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out"><blockquote><p>每个运行的程序都是一个进程，在一个进程中还可以有多个执行单元同时运行。这些执行单元可以看作程序执行的—条条线索，被称为线程。操作系统中的每—个进程中都至少存在—个线程。例如当一个 Java 程序启动时，就会产生—个进程，该进程中会默认创建一个线程，在这个线程上会运行 main() 方法中的代码。</p></blockquote><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>在 Java 中提供了两种多线程实现方式， —种是继承 java.lang 包下的 Thread 类，覆写 Thread 类的 run() 方法，在 run() 方法中实现运行在线程上的代码；另一种是实现 java.lang.Runnable 接口，同样是在 run() 方法中实现运行在线程上的代码。</p><h3 id="直接继承-Thread"><a href="#直接继承-Thread" class="headerlink" title="直接继承 Thread"></a>直接继承 Thread</h3><p>JDK 中提供了—个线程类Thread , 通过继承 Thread 类，并重写 Thread 类中的 run() 方法便可实现多线程。在 Thread 类中，提供了一个 start() 方法，用千启动新线程。线程启动后，虚拟机会自动调用 run() 方法，如果子类重写了，该方法便会执行子类中的方法。</p><pre><code class="java">public class TwoThread {
    public static void main(String[] args) {
        new PrintThread1(&quot;线程A&quot;).start();
        new PrintThread1(&quot;线程B&quot;).start();
    }
}
class PrintThread1 extends Thread{
    public PrintThread1(String name) {
        super(name);
    }

    @Override
    public void run() {;
        for (int i=0;i&lt;1000;i++){
            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hOYX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/TwoThread.png" alt="TwoThread.png"></a></p><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>继承Thread 类实现了多线程，但是这种方式有—定的局限性。因为Java中只支持单继承，一个类一旦继承了某个父类就无法再继承Thread 类，例如学生类Student 继<br>承了Person 类，就无法通过继承Thread 类创建线程。</p><p>为了克服这种弊端， Thread 类提供了另外一个构造方法 Thread(Runnable target) ，其中，Runnable 是一个接口， 它只有—个 run() 方法。当通过 Thread(Runnable target)）构造方法创建线程对象时，只需为该方法传递—个实现了 Runnable 接口的实例对象，这样创建的线程将调用实现了 Runnable 接口的类中的 run() 方法作为运行代码，而不需要调用 Thread 类中的 run() 方法</p><h4 id="法A：创建多个线程对象"><a href="#法A：创建多个线程对象" class="headerlink" title="法A：创建多个线程对象"></a>法A：创建多个线程对象</h4><pre><code class="java">import static java.lang.Thread.sleep;

public class ThreadRunnable {
    public static void main(String[] args) {
        PrintThread2 xc1 = new PrintThread2(&quot;线程a&quot;);
        PrintThread2 xc2 = new PrintThread2(&quot;线程b&quot;);
        PrintThread2 xc3 = new PrintThread2(&quot;线程c&quot;);
        new Thread(xc1).start();
        new Thread(xc2).start();
        new Thread(xc3).start();
    }
}
class PrintThread2 implements Runnable{
    String name;
    public PrintThread2(String name) {
        this.name=name;
    }

    @Override
    public void run() {
        for (int i=0;i&lt;1000;i++){
            System.out.println(this.name+&quot; 第&quot;+i+&quot;次&quot;);
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hUzi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThread.png" alt="RunnableThread.png"></a></p><h4 id="法B：仅创建一个线程的对象（推荐）"><a href="#法B：仅创建一个线程的对象（推荐）" class="headerlink" title="法B：仅创建一个线程的对象（推荐）"></a>法B：仅创建一个线程的对象（推荐）</h4><p>这种方法，相比刚才的，可以在多个线程中同时使用线程对象 PrintThread3 中的某个变量。</p><pre><code class="java">import static java.lang.Thread.currentThread;
import static java.lang.Thread.sleep;

public class ThreadRunnablePlus {
    public static void main(String[] args) {
        PrintThread3 xc= new PrintThread3();
        //构造方法Thread(Runnable target, String name)在创建线程对象的同时指定线程的名称，
        new Thread(xc,&quot;线程1&quot;).start();
        new Thread(xc,&quot;线程2&quot;).start();
        new Thread(xc,&quot;线程3&quot;).start();
    }
}

class PrintThread3 implements Runnable{
    int n=0;

    @Override
    public void run() {
        for (int i=0;i&lt;1000;i++){
            //打印当前线程名和次数
            n++;
            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hKmY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-nolock.png" alt="RunnableThreadPlus-nolock.png"></a></p><p>细心的童鞋，可能在这里就发现问题了，貌似总数统计出现的顺序有问题？yep，这个问题且听下面 线程同步 的小节分解。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程去访问同一个资源时，也会引发一些安全问题。例如下面的代码段，我们把循环终止的条件改为 总次数n 小于等于10：</p><pre><code class="java">public class ThreadRunnablePlus {
    public static void main(String[] args) {
        PrintThread3 xc= new PrintThread3();
        new Thread(xc,&quot;线程1&quot;).start();
        new Thread(xc,&quot;线程2&quot;).start();
        new Thread(xc,&quot;线程3&quot;).start();
    }
}

class PrintThread3 implements Runnable{
    int n=0;
    @Override
    public void run() {
        int i=0;
        for (;n&lt;=10;n++){
            //打印当前线程名和次数
            i++;
            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
        }
    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hLwa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-nonelock0.png" alt="RunnableThreadPlus-nonelock0.png"></a></p><p>按理说，在 n 为 10 的时候，应该结束所有线程。但事实上，在这之后，还有语句输出</p><p>像现在碰到的计数错误的情况就是因为多个线程同时访问对象中的变量 n 导致的。为了解决这样的问题，需要 <strong><em>实现多线程的同步</em></strong> ，即限制某个资源在同一时刻只能被一个线程访问。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>线程安全问题其实就是由多个线程同时处理共享资源所导致的。要想解决线程安全问题，必须得保证用于处理共享资源的代码在任何时刻只能有—个线程访问。</p><p>比如刚才例子中的这一段：</p><pre><code class="java">for (;n&lt;=10;n++){
    //打印当前线程名和次数
    i++;
    System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
}</code></pre><h4 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h4><p>Java 中提供了同步机制。当多个线程使用同—个共享资源时，可以将处理共享资源的代码放在一个使用 synchronized 关键字来修饰的代码块中，这个代码块被称作同步代码块，</p><pre><code class="java">Object lock= new Object(); //定义任意一个对象，用作同步代码块的锁
synchronized (lock) {
    //操作共享资源代码块
}</code></pre><h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><p>我们将刚才出现异常的代码做出如下改进，将循环套上同步锁 synchronized：</p><pre><code class="java">class PrintThread3 implements Runnable{
    int n=0;

    @Override
    public void run() {
        int i=0;
        synchronized (this){
            for (;n&lt;=10;n++){
                //打印当前线程名和次数
                i++;
                System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
            }
        }

    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hans" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-locked.png" alt="RunnableThreadPlus-locked.png"></a></p><p>可以看到，后面的计数都完全正常了，可是线程2和3却没有运行。</p><p>这是因为因为整个循环体的代码块都被线程1阻塞了，等线程2和3得到同步锁的时候，n的值已经为11了，无法再次进入循环了。</p><p>因此，这里的<strong>同步锁应当放在循环体内</strong>，同时将 for 循环改为 while 循环可以很好的解决问题：</p><pre><code class="java">class PrintThread3 implements Runnable{
    int n=1;

    @Override
    public void run() {
        int i=0;
        while (true){
            i++;
            synchronized (this){
                if(n&lt;=10){
                    //打印当前线程名和次数
                    System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
                    n++;
                }else
                    break;
            }
            //为了演示，防止运行过快，加了这段延时代码
            try {
                sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}s</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hgq3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-locksuccess.png" alt="RunnableThreadPlus-locksuccess.png"></a></p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>除了同步代码块，在方法前面同样可以使用 synchronized 关键字来修饰，被修饰的方法为同步方法， 它能实现与同步代码块相同的功能，具体语法格式如下。</p><pre><code class="java">synchronized 返回值类型 方法名([参数1 ,^ ]) {
    //方法体
}</code></pre><p>被 synchronized 修饰的方法在某—时刻只允许一个线程访问，访问该方法的其他线程都会<br>发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。</p><h4 id="实现案例-1"><a href="#实现案例-1" class="headerlink" title="实现案例"></a>实现案例</h4><p>这里我们将同一个案例改为使用方法同步来实现：</p><pre><code class="java">class PrintThread3 implements Runnable{
    int n=1;
    boolean fin = true;

    @Override
    public void run() {
        int i=0;
        while (fin){
            i++;
            doNum(i);
            //减慢运行速度便于观察
            try {
                sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    //方法锁
    synchronized void doNum(int i){
        if(n&lt;=10){
            //打印当前线程名和次数
            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);
            n++;
        }else
            fin=false;
    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hlTG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-methodlock.png" alt="RunnableThreadPlus-methodlock.png"></a></p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程都需要对方所占用的锁，但是都无法释放自己所拥有的锁，于是这两个线程都处于挂起状态，从而造成了死锁。</p><pre><code class="java">public class SyncDie implements Runnable{
    static Object a = new Object();
    static Object b = new Object();
    boolean flag;

    @Override
    public void run() {
        if(flag){
            while (true){
                synchronized (a) {
                    System.out.println(&quot;a1&quot;);
                    synchronized (b) {
                        System.out.println(&quot;b1&quot;);
                    }
                }
            }
        }
        else{
            while (true){
                synchronized (b) {
                    System.out.println(&quot;b2&quot;);
                    synchronized (a) {
                        System.out.println(&quot;a2&quot;);
                    }
                }
            }
        }
    }

    public SyncDie(boolean flag) {
        this.flag = flag;
    }

    public static void main(String[] args) {
        SyncDie s1 = new SyncDie(true);
        SyncDie s2 = new SyncDie(false);
        new Thread(a).start();
        new Thread(b).start();
    }
}
</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/n449" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/synchronize-die.png" alt="synchronize-die.png"></a></p><p>可以看到，两个线程一直在运行并没有退出，因为线程 s1 先锁定了 a，线程 s2 锁定了 b；然后 s1 要获取 b 才能继续运行并释放 a，但是 s2 只有等 s1 释放 a 了，才能继续运行然后释放 b……</p><p>听起来很绕，没错，这就像套娃。（拒绝套娃，从不写死锁开始。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在 Java 中，任何对象都有生命周期，线程也不例外，它也有自己的生命周期。当 Thread<br>对象创建完成时，线程的生命周期便开始了。当 run() 方法中代码正常执行完毕或者线程抛出一个未捕获的异常 (Exception) 或者错误 (Error) 时，线程的生命周期便会结束。</p><h3 id="几个阶段"><a href="#几个阶段" class="headerlink" title="几个阶段"></a>几个阶段</h3><p>线程整个生命周期可以分为 5 个阶段，分别是新建状态 (New)、就绪状态 (Runnable)、运行状态 (Running)、阻塞状态 (Blocked) 和死亡状态 (Terminated) ，线程的不同状态表明了线程当前正在进行的活动。在程序中，通过—些操作，可以使线程在不同状态之间转换，</p><p><a href="https://up.media.everdo.cn/image/nHbj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadLifeTime.png" alt="ThreadLifeTime.png"></a></p><h4 id="新建状态-New"><a href="#新建状态-New" class="headerlink" title="新建状态(New)"></a>新建状态(New)</h4><p>创建—个线程对象后，该线程对象就处千新建状态，此时它不能运行，和其他Java 对象一<br>样，仅仅由Java 虚拟机为其分配了内存，没有表现出任何线程的动态特征。</p><h4 id="就绪状态-Runnable"><a href="#就绪状态-Runnable" class="headerlink" title="就绪状态(Runnable)"></a>就绪状态(Runnable)</h4><p>当线程对象调用了 start() 方法后，该线程就进入就绪状态。处于就绪状态的线程位于线程队列中，此时它只是具备了运行的条件，能否获得 CPU 的使用权并开始运行，还需要等待系统的调度。</p><h4 id="运行状态-Running"><a href="#运行状态-Running" class="headerlink" title="运行状态(Running)"></a>运行状态(Running)</h4><p>如果处于就绪状态的线程获得了 CPU 的使用权，并开始执行 run() 方法中的线程执行体，则该线程处于运行状态。</p><h4 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a>阻塞状态(Blocked)</h4><p>—个正在执行的线程在某些特殊情况下，如被人为挂起或执行耗时的输入／输出操作时，会<br>让出CPU 的使用权并暂时中止自己的执行，进入阻塞状态。线程进入阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p><blockquote><p>获取某个对象的同步锁；调用了一个阻塞式的 IO 方法；调用了某个对象的 wait() 方法【需要使用 notify() 方法唤醒该线程】；程调用了 Thread 的 sleep(long miles) 方法；调用了另—个线程的 join() 方法【需要等待被插入的线程执行完毕】</p><p><strong>这些都会导致当前线程被阻塞</strong></p></blockquote><h4 id="死亡状态-Terminated"><a href="#死亡状态-Terminated" class="headerlink" title="死亡状态(Terminated)"></a>死亡状态(Terminated)</h4><p>当线程调用 stop() 方法【stop已弃用】或 run() 方法正常执行完毕后，或者线程抛出一个未捕获的异常 (Exception)、错误(Error)，<strong>线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。</strong>（就是废了）</p><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>在计算机中，线程调度有两种模型，分别是分时调度模型和抢占式调度模型。</p><blockquote><p><strong>分时调度模型：</strong> 让所有的线程轮流获得CPU 的使用权，并且平均分配每个线程占用的CPU 的时间片。</p><p><strong>抢占式调度模型 (JAVA)：</strong> 让可运行池中优先级高的线程优先占用 CPU, 而对于优先级相同的线程，随机选择—个线程使其占用 CPU, 当它失去了 CPU 的使用权后，再随机选择其他线程获取 CPU使用权。</p></blockquote><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><table><thead><tr><th>Thread 类的静态常量</th><th>功能描述</th></tr></thead><tbody><tr><td>static int MAX_ PRIORITY</td><td>表示线程的最高优先级，值为10</td></tr><tr><td>static int MIN_PRIORITY</td><td>表示线程的最低优先级， 值为1</td></tr><tr><td>static int NORM_PRIORITY</td><td>表示线程的晋通优先级， 值为5</td></tr></tbody></table><p>可以通过Thread 类的 setPriority(int newPriority) 方法对其进行设置，该方法中的参数 newPriority 接收的是 1~10 之间的整数或者 Thread 类的 3 个静态常量。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {
    public static void main(String[] args) {
        Thread a = new PrintThread1(&quot;线程A&quot;);
        Thread b = new PrintThread1(&quot;线程B&quot;);
        a.setPriority(Thread.MIN_PRIORITY);
        b.setPriority(Thread.MAX_PRIORITY);
        a.start();
        b.start();
    }
}
class PrintThread1 extends Thread{
    public PrintThread1(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i=0;i&lt;10;i++){
            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);
        }

    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nJzO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadsetPriority.png" alt="ThreadsetPriority.png"></a></p><p>可以看到，在设置了优先级后，线程B比线程A更早运行。当然这并不代表A只能等B运行完了才能运行。只是开始时间B会早于A，很有可能A会在B阻塞时启动。</p><blockquote><p>注意：不同的操作系统对优先级的支持是不—样的， 不会与 Java 中线程优先级——对应。因此，在设计多线程应用程序时，其功能的实现一定不能依赖于线程的优先级，而只能把线程优先级作为一种提高程序效率的手段。</p></blockquote><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>如果希望人为地控制线程，使正在执行的线程暂停，将 CPU 让给别的线程，这时可以使用静态方法 sleep(long millis)，该方法可以让当前正在执行的线程暂停一段时间，进入休眠等待状态。</p><p>Sleep(long millis) 方法声明会抛出 Interrupted Exception 异常，因此在调用该方法时应该捕获异常，或者声明抛出该异常。</p><p><strong>调用格式如下：</strong></p><pre><code class="java">try {
    sleep(1000);
} 
catch (InterruptedException e) {
    e.printStackTrace();
}</code></pre><blockquote><p>需要注意的是， sleep() 是静态方法，只能控制当前正在运行的线程休眠，而不能控制其他线程休眠。当休眠时间结束后，线程就会返回到就绪状态，而不是立即开始运行。</p></blockquote><h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p>所谓的线程让步是指正在执行的线程，在某些情况下将 CPU 资源让给其他线程执行。</p><p>线程让步可以通过 yield() 方法来实现，该方法和 sleep() 方法有点相似，都可以让当前正在运行的线程暂停，区别在于 yield() 方法不会阻塞该线程，它只是将线程转换成就绪状态，让系统的调度器重新调度一次。当某个线程调用 yield() 方法之后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {
    public static void main(String[] args) {
        Thread a = new PrintThread1(&quot;线程A&quot;);
        Thread b = new PrintThread1(&quot;线程B&quot;);
        b.start();  //线程b先启动
        a.start();
    }
}
class PrintThread1 extends Thread{
    public PrintThread1(String name) {
        super(name);
    }

    @Override
    public void run() {
        //super.run();
        for (int i=0;i&lt;10;i++){
            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);
            if(this.getName().equals(&quot;线程B&quot;)){
                System.out.println(&quot;线程B让步&quot;);
                this.yield();
            }
        }

    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nPL6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/Thread-yield.png" alt="Thread-yield.png"></a></p><p>可以看到每次让步后，线程A就会排在前面执行。多次让步最后线程A率先运行完成。</p><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>在 Thread 类中也提供了一个 join() 方法来实现这个“功能” 。当在某个线程中调用其他线程的 join() 方法时，调用的线程将被阻塞，直到被 join() 方法加入的线程执行完成后它才会继续运行。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {
    public static void main(String[] args) {
        Thread a = new PrintThread1(&quot;线程A&quot;);
        a.start();
        for (int i=0;i&lt;10;i++){
            System.out.println(&quot;Main方法 第&quot;+i+&quot;次&quot;);
            if(i==3) {
                try {
                    System.out.println(&quot;a插队进来了&quot;);
                    a.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }


    }
}
class PrintThread1 extends Thread{
    public PrintThread1(String name) {
        super(name);
    }

    @Override
    public void run() {
        //super.run();
        for (int i=0;i&lt;5;i++){
            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);
        }

    }
}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nhFn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadJoin.png" alt="ThreadJoin.png"></a></p><p>可以看到，线程A插队进来后，Main方法必须等线程A执行完毕才能继续执行。</p><h2 id="线程协作关系"><a href="#线程协作关系" class="headerlink" title="线程协作关系"></a>线程协作关系</h2><p>当多个线程为完成同一任务而分工协作时，它们彼此之间有联系，知道其他线程的存在，而且受其他线程执行的影响，这些线程间存在协作关系。</p><p>协作线程之间相互等待以协调进度的过程被称为线程同步。两个以上线程基于某个条件来协调它们的活动。一个线程的执行依赖于另一个协作线程的消息或信号，当线程没有得到来自于另一个线程的消息或信号时需等待，直到消息或信号到达才被唤醒。</p><h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h3><pre><code class="java">//线程同步:

wait()  //挂起一个线程
notify()    //唤醒线程
notifyAll() //唤醒全部线程</code></pre><p><strong>wait()方法：</strong> 该方法用来使得当前线程进入等待状态，直到接到通知或者被中断打断为止。在调用wait()方法之前，线程必须要获得该对象的对象级锁；<strong><em>换句话说就是该方法只能在同步方法或者同步块中调用，如果没有持有合适的锁的话，线程将会抛出异常 IllegalArgumentException。</em></strong> 调用wait()方法之后，当前线程则释放锁。</p><p><strong>notify()方法：</strong> 该方法用来唤醒处于等待状态获取对象锁的其他线程。如果有多个线程则线程规划器任意选出一个线程进行唤醒，使其去竞争获取对象锁，但线程并不会马上就释放该对象锁，wait() 所在的线程也不能马上获取该对象锁，要程序退出同步块或者同步方法之后，当前线程才会释放锁，wait() 所在的线程才可以获取该对象锁。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>wait() 方法是释放锁的；notify() 方法不释放锁，必须等到所在线程把代码执行完。</p></li><li><p>由于 notify() 唤醒了一个随机线程，因此它可用于实现线程执行类似任务的互斥锁定，但在大多数情况下，实现 notifyAll() 会更可行。</p></li><li><p>建议使用 <strong>while循环</strong> 搭配一个公用的 boolean flag 食用更香！</p></li></ul><h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><h3 id="为什么弃用-stop-和-suspend"><a href="#为什么弃用-stop-和-suspend" class="headerlink" title="为什么弃用 stop 和 suspend"></a>为什么弃用 stop 和 suspend</h3><p>初始的 java 版本中定义了一个 stop 方法来终止一个线程还定义了一个 suspend 方法来阻塞一个线程，直到另一个线程调用 resume 方法。这两个方法在 Java SE 1.2 之后就被弃用了，因为这两种方法都不安全。</p><blockquote><p>stop 方法天生就不安全，因为它在终止一个线程时会强制中断线程的执行，不管 run 方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象。这一现象会被其它因为请求锁而阻塞的线程看到，使他们继续向下执行。这就会造成数据的不一致。</p><p>suspend 被弃用的原因是因为它会造成死锁。suspend 方法和 stop 方法不一样，它不会破换对象和强制释放锁，相反它会一直保持对锁的占有，一直到其他的线程调用 resume 方法，它才能继续向下执行。</p></blockquote><h3 id="正确的终止一个线程"><a href="#正确的终止一个线程" class="headerlink" title="正确的终止一个线程"></a>正确的终止一个线程</h3><p>可以采用设置一个条件变量的方式，run 方法中的 while 循环会不断的检测 flag 的值，在想要结束线程的地方将 flag 的值设置为 false 就可以啦！</p><blockquote><p>注意这里要将 flag 设置成 volitale 的，因为 volitale 可以保证数据的有效性，如果不设置话，可能会造成子线程多执行一次的错误</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>网络资料：</strong></p><p>volatile 的作用就是把放在线程栈上的变量立刻同步到主内存中，这里涉及到 Java 内存模型的知识。</p><blockquote><p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p></blockquote><p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><p>多个线程间变量的同步都是先同步到主内存中，然后主内存再同步到其他线程的变量副本上，但无法保证同步是立刻执行的，加 volatile 之后会立刻同步。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><blockquote style="margin:2em 0 0;padding:.5em 1em;border-left:3px solid #ebc43b;background-color:#191919;list-style:none"><p><strong>This blog is under a <a href="/creativecommons.html" target="_blank">CC BY-NC-ND 4.0 Unported License</a></strong><br><strong>本文链接：</strong><a href="https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/">https://coding.emptinessboy.com/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</a></p></blockquote></div><div id="comment" style="padding:10px" class="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return GUEST_INFO.indexOf(i)>-1}),notify=!1,verify=!0;new Valine({el:".vcomment",notify:notify,verify:verify,appId:"91mhcw0WK44B90nptmxGcJol-gzGzoHsz",appKey:"Boi7za0ClwGyWRCYd8osdf5o",placeholder:"在这里写点什么吧！",pageSize:"10",avatar:"monsterid",lang:"zh-cn",guest_info:guest_info})</script></div><nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col"><a href="/2020/05/Java-IO%E5%A4%84%E7%90%86/" id="post_nav-newer" class="prev-content"><button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation"><i class="material-icons">arrow_back</i></button> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新篇</a><div class="section-spacer"></div><a href="/2020/05/%E5%8E%9F%E6%9D%A5%E5%81%B7%E8%B7%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E9%87%8F%E7%9A%84%E7%BD%AA%E9%AD%81%E7%A5%B8%E9%A6%96%E6%98%AFTA%EF%BC%81/" id="post_nav-older" class="next-content">旧篇 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation"><i class="material-icons">arrow_forward</i></button></a></nav></div></div><div class="sidebar-overlay"></div><aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation"><div id="sidebar-main"><div class="sidebar-header header-cover" style="background-image:url(/img/sidebar_header.jpg)"><div class="top-bar"></div><button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display:initial" data-upgraded=",MaterialButton,MaterialRipple"><i class="material-icons">clear_all</i> <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></button><div class="sidebar-image"><img src="/img/fav_300.png" alt="EmptinessBoy's avatar"></div><a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">i@my.huxiaofan.com <b class="caret"></b></a></div><ul class="nav sidebar-nav"><li class="dropdown"><ul id="settings-dropdown" class="dropdown-menu"><li><a href="mailto:i@my.huxiaofan.com" target="_blank" title="Email 我"><i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i> Email 我</a></li></ul></li><li id="sidebar-first-li"><a href="/"><i class="material-icons sidebar-material-icons">home</i> 主页</a></li><li class="divider"></li><li class="dropdown"><a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown"><i class="material-icons sidebar-material-icons">inbox</i> 归档 <b class="caret"></b></a><ul class="dropdown-menu"><li><a class="sidebar_archives-link" href="/archives/2021/05/">五月 2021<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2021/04/">四月 2021<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/11/">十一月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/10/">十月 2020<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/09/">九月 2020<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/07/">七月 2020<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/06/">六月 2020<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/05/">五月 2020<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/04/">四月 2020<span class="sidebar_archives-count">13</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/03/">三月 2020<span class="sidebar_archives-count">13</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/02/">二月 2020<span class="sidebar_archives-count">4</span></a></li></ul></li><li class="dropdown"><a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown"><i class="material-icons sidebar-material-icons">chrome_reader_mode</i> 分类 <b class="caret"></b></a><ul class="dropdown-menu"><li><a class="sidebar_archives-link" href="/categories/Android/">Android<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/categories/CSS%E5%AD%A6%E4%B9%A0/">CSS学习<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/HTML%E5%AD%A6%E4%B9%A0/">HTML学习<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/categories/Hadoop/">Hadoop<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/JAVAWEB/">JAVAWEB<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/JAVA%E5%AD%A6%E4%B9%A0/">JAVA学习<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/categories/JS%E5%AD%A6%E4%B9%A0/">JS学习<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/categories/Linux/">Linux<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/WEB%E6%A1%86%E6%9E%B6/">WEB框架<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/python%E5%85%A5%E9%97%A8/">python入门<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/">瞎折腾<span class="sidebar_archives-count">4</span></a></li></ul></li><li class="divider"></li><li><a href="https://huxiaofan.com" target="_blank" rel="noopener" title="生活博客"><i class="material-icons sidebar-material-icons">domain</i> 生活博客</a></li><li><a href="https://huxiaofan.com/about" target="_blank" rel="noopener" title="关于我"><i class="material-icons sidebar-material-icons">person</i> 关于我</a></li><li class="divider"></li><li><a href="/archives">文章总数 <span class="sidebar-badge">53</span></a></li></ul></div></aside><div id="back-to-top" class="toTop-wrap"><a href="#top" class="toTop"><i class="material-icons footer_top-i">expand_less</i></a></div><footer class="mdl-mini-footer" id="bottom"><div class="mdl-mini-footer--left-section sns-list"><a href="https://huxiaofan.com/go?url=https://twitter.com/huxiaofanhome/" target="_blank"><button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter"><span class="visuallyhidden">Twitter</span></button></a><a href="https://huxiaofan.com/go?url=https://www.facebook.com/profile.php?id=100013375578138" target="_blank"><button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook"><span class="visuallyhidden">Facebook</span></button></a><a href="https://git.huxiaofan.com/emptinessboy" target="_blank"><button class="mdl-mini-footer--social-btn social-btn footer-sns-github"><span class="visuallyhidden">Github</span></button></a><a href="https://huxiaofan.com/go/?url=aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NTc2MjgwMDQ=" target="_blank"><button class="mdl-mini-footer--social-btn social-btn footer-sns-bilibili"><span class="visuallyhidden">Bilibili</span></button></a><a href="https://huxiaofan.com/go/?url=https://t.me/emptinessboy" target="_blank"><button class="mdl-mini-footer--social-btn social-btn footer-sns-telegram"><span class="visuallyhidden">Telegram</span></button></a></div><div id="copyright">Copyright&nbsp;©&nbsp;<span year></span>&nbsp;帆的自留地<br><a href="http://huxiaofan.com" target="_blank" rel="noopener">晓帆</a>&nbsp;/&nbsp;<a href="https://beian.miit.gov.cn/" target="_blank" rel="nofollow"> 浙ICP备20004121号-1</a></div><div class="mdl-mini-footer--right-section"><div><div class="footer-develop-div">Hexo Theme - <span class="footer-develop-a">Material</span></div></div></div></footer><script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==",!0)</script><script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==",!0)</script><script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==",!0)</script><script type="text/ls-javascript" id="NProgress-script">NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#82bcff'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #82bcff, 0 0 15px #82bcff'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#82bcff',
        'border-left-color': '#82bcff'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);</script><script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==",!0)</script><script type="text/ls-javascript" id="window-load">$(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })</script><script type="text/ls-javascript" id="lazy-load">// Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });</script><script>var copyrightNow=(new Date).getFullYear(),textContent=document.querySelector("span[year]");copyrightSince=2019,copyrightSince===copyrightNow||0===copyrightSince?textContent.textContent=copyrightNow:textContent.textContent=copyrightSince+" - "+copyrightNow,function(){for(var t=document.querySelectorAll('script[type="text/ls-javascript"]'),e=0;e<t.length;++e){var o=t[e];lsloader.runInlineScript(o.id,o.id)}}(),console.log("\n %c 帆's Life | https://huxiaofan.com | Theme Material %c \n","color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;","color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;")</script></main></div></body></html><!-- rebuild by neat -->