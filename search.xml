<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试之浅拷贝和深拷贝？</title>
      <link href="/2021/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>这是昨天在 Boss 上随手刷到的一个看起来非常简单的面试题，也就是 JS 的深浅拷贝，（翻译成人话的化就是<strong><em>如何将 JS 的对象完整的复制一份？</em></strong>）</p><p>听起来十分简单是不是？</p><p>为啥不直接定义一个变量，然后让它等于原来的对象不就完事了？</p><p>哈哈，如果你也是这么想的，那恭喜你也掉坑里去啦！那么就让我来好好说说原因吧！</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这篇文章可能用到 VUE 的生命周期函数，如果你还不知道，可以阅读这一篇文章：</p><p>👉 <a href="https://coding.emptinessboy.com/2021/04/VUE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%95%A5%EF%BC%9F/">传送门：VUE的生命周期是啥？</a></p><p>为了真正搞明白 JS 深拷贝和浅拷贝的原理，我准备了如下初始模板代码：</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><p>模板代码基于 VUE2.6 的项目构建，html 模板如下：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;list:{{ list }}&lt;/p&gt;    &lt;p&gt;listcp:{{ listcp }}&lt;/p&gt;    &lt;p&gt;obj:{{ obj }}&lt;/p&gt;    &lt;p&gt;objcp:{{ objcp }}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>JS的 data 部分如下，我们构建了一个数组 list 和一个对象 obj 作为我们被拷贝的原始对象。listcp 和 objcp 则用来存放我们拷贝后的对象。</p><pre><code class="javascript">data() {  return {    list: [&quot;吃&quot;, &quot;睡&quot;, &quot;就是玩！&quot;],    obj: {      name: &quot;学长帆帆&quot;,      wechatid: &quot;xuezhangfanfan&quot;,      hobbies: [&quot;吃&quot;, &quot;睡&quot;, &quot;就是玩！&quot;],      major: {        web: [          {            lang1: &quot;html&quot;,            lang2: &quot;xml&quot;,          },          &quot;css&quot;,          &quot;js&quot;,        ],        webframework: [&quot;bootdtrap&quot;, &quot;vue.js&quot;, &quot;flutter&quot;],      },    },  };},</code></pre><p>这时候运行代码，应该能看到浏览器上显示了原始的对象以及为空的拷贝后对象：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/25/image-20210525222521449.png" alt="image-20210525222521449"></p><h3 id="for-in-遍历数组和对象"><a href="#for-in-遍历数组和对象" class="headerlink" title="for in 遍历数组和对象"></a>for in 遍历数组和对象</h3><p>在开始正式进行拷贝之前，我们还需要了解下 ES6 中的 for …… in 循环。我们在刚才代码的基础上，加入如下两个 for in 循环，使之分别遍历 list 和 obj 的内容。</p><pre><code class="javascript">mounted() {  for (let item in this.list) {    console.log(item);  }  for (let item in this.obj) {    console.log(item);  }},</code></pre><p>运行后打开控制台显示如下：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/26/image-20210524200119790.png" alt="image-20210524200119790"></p><p>可以看到如果遍历的对象为 Array，则 item 值为数组的索引；如果遍历的对象为 Object ，则 item 值为对象内的 key。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="直接复制对象"><a href="#直接复制对象" class="headerlink" title="直接复制对象"></a>直接复制对象</h3><p>那么我们回过来看我们刚才遇到的问题。由于 JavaScript 中对象实际都以地址进行存储，如果我们只是简单的让一个变量等于原始的对象，这一步的等号其实只复制了对象的地址。如果其中拷贝前的对象的内容发生变化，则拷贝的对象也会发送变化（其实仍然是同一个对象）。不信的话，我们用下面的代码做一下实验：</p><pre><code class="javascript">mounted() {  this.listcp = this.list;  this.objcp = this.obj;},</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/24/image-2021052420100263436d732b28bf43135.png" alt="image-20210524201002634"></p><p>可以看到运行后，浏览器输出了拷贝前和拷贝后的对象。那么我们尝试修改拷贝后的对象：</p><pre><code class="javascript">mounted() {  this.listcp = this.list;  this.objcp = this.obj;  this.listcp[0] = &quot;我改变了拷贝后的数组&quot;;  this.objcp.name = &quot;我改变了拷贝后的对象的name&quot;;},</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/24/image-20210524201116383.png" alt="image-20210524201116383"></p><p>可以看到，虽然我们修改的是拷贝后对象的内容，但是拷贝前的原始对象的内容也跟着一起改变了。</p><h3 id="一次-for-循环拷贝"><a href="#一次-for-循环拷贝" class="headerlink" title="一次 for 循环拷贝"></a>一次 for 循环拷贝</h3><p>这时你是不是要说了，这个问题简单呀，我们只需要用一个 for in 循环遍历一轮对象内的元素，然后复制到新的对象中就行了呀！</p><p>话不多说，直接上代码！</p><pre><code class="javascript">mounted() {  this.objcp = this.simpleClone(this.obj);  this.listcp = this.simpleClone(this.list);  this.listcp[0] = &quot;我改变了拷贝后的数组&quot;;  this.objcp.name = &quot;我改变了拷贝后的对象的name&quot;;},methods: {  simpleClone(obj) {    let newObj;    if (obj.constructor === Array) {      newObj = [];    } else {      newObj = {};    }    for (let key in obj) {      newObj[key] = obj[key];    }    console.log(newObj);    return newObj;  },},</code></pre><p>这里我写了一个简单的 for 循环遍历要拷贝对象的属性并赋值到新的对象。然后我们再尝试用刚才的方法修改拷贝后对象的某一条属性。</p><p>可以看到，现在我成功的修改了拷贝后对象的属性而没有影响到拷贝前的原始对象。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/24/image-20210524203216666.png" alt="image-20210524203216666"></p><p>那么是不是这样就完事大吉了呢？</p><p>其实不然，当我们尝试修改 objcp.hobbies[0]</p><pre><code class="javascript">this.objcp.hobbies[0] = &quot;我修改了，拷贝后对象内的数组里的值&quot;;</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/24/image-20210524203647675.png" alt="image-20210524203647675"></p><p>可以看到，拷贝前的原始数组又被修改了。</p><p>因为刚才的一次 for 循环只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 objcp.hobbies 和 obj.hobbies 指向同一块内存地址。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="懒人办法（使用JSON方法"><a href="#懒人办法（使用JSON方法" class="headerlink" title="懒人办法（使用JSON方法"></a>懒人办法（使用JSON方法</h3><p>由于 JS 中为我们提供了一种对象的序列化和反序列化方法 window.JSON.stringify() 和 window.JSON.parse()。使用 window.JSON.stringify() 可以快速把一个对象转换成字符串，而 window.JSON.parse() 可以快读的将字符串还原成对象，因此我们可以借用这两个简单的内置函数来拷贝一个对象。</p><pre><code class="javascript">cloneByJson(obj) {  let newObj;  newObj = JSON.parse(JSON.stringify(obj))  return newObj;},</code></pre><h3 id="递归实现深层拷贝"><a href="#递归实现深层拷贝" class="headerlink" title="递归实现深层拷贝"></a>递归实现深层拷贝</h3><p>那么如果客户机不支持 windows.JSON 呢？</p><p>其实很简单，我们可以借用递归的算法，将对象的每一个属性依次拷贝过来！</p><pre><code class="javascript">mounted() {  this.objcp = this.deepClone(this.obj);  this.listcp = this.deepClone(this.list);  this.listcp[0] = &quot;我改变了拷贝后的数组&quot;;  this.objcp.name = &quot;我改变了拷贝后的对象的name&quot;;  this.objcp.hobbies[0] = &quot;我修改了，拷贝后对象内的数组里的值&quot;;},methods: {  deepClone(obj) {    let newobj = obj.constructor === Array ? [] : {};    if (typeof obj !== &quot;object&quot;) {      return;    } else {      for (var i in obj) {        newobj[i] = typeof obj[i] === &quot;object&quot; ?           //递归进行拷贝          this.cloneObj(obj[i])           : obj[i];      }    }    return newobj;  },},</code></pre><p>现在可以看到，我们修改拷贝后的对象并不会影响拷贝前的对象啦！</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/24/image-20210524204819390.png" alt="image-20210524204819390"></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>将上面两段深拷贝的代码结合到一起，就可以得到下面最通用的深拷贝函数啦！直接 ctrl + c 就可以在项目中使用啦！</p><pre><code class="javascript">// 兼容不支持JSON的浏览器cloneObj(obj) {  if (typeof obj !== &quot;object&quot;) {    return;  }   let newobj = obj.constructor === Array ? [] : {};  if (window.JSON) {    let str = JSON.stringify(obj); //序列化对象    newobj = JSON.parse(str); //还原  } else {      for (let item in obj) {      newobj[item] =        typeof obj[item] === &quot;object&quot;          ? this.cloneObj(obj[item])          : obj[item];    }  }  return newobj;},</code></pre><blockquote><p>到这里，关于 JS 的深浅拷贝就和大家讲完啦！篇幅限制，演示的 VUE 项目完整代码请公众号后台回复 “代码深拷贝” 来获取。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> WEB框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs,javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之排序和VUE死循环</title>
      <link href="/2021/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E5%92%8CVUE%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
      <url>/2021/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E5%92%8CVUE%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>这周末出去兜了一波风，吹了吹海风。翻了翻朋友圈，感觉除了我以外的所有人周末都在学习😭</p></blockquote><p>这不，大三就要结束了，内卷的风气已经在班上悄无声息的蔓延开了。面试的忙着找书记的实习，考研的忙着最后半年的冲刺，算下来我算是那个最“颓废”的人啦。</p><p>恰巧，最近同学面试的时候，被面试官问到了各种问题。这里就给大家简单的整理一波啦。（不定时更新</p><h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><p>排序问题可以说是程序设计里最基础的算法了。恰巧我一朋友在面试的时候就被问到了冒泡排序，结果可能是因为太紧张，一时大脑空白，就没写出来。</p><p>那么这里就整理下 JS 中排序的最简单的三种实现方式。这里我采用了 一个空白的 VUE 项目为大家进行演示（因为可以用 ES6 语法）。</p><p><strong>模板代码：</strong></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;list_origin：{{list0}}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;Home&quot;,  data() {    return {      list0: [3, 1, 4, 6, 8, 5],      list1: [3, 1, 4, 6, 8, 5],      list2: [3, 1, 4, 6, 8, 5],    };  },};&lt;/script&gt;</code></pre><h3 id="自带排序方法"><a href="#自带排序方法" class="headerlink" title="自带排序方法"></a>自带排序方法</h3><p>在上面发模板代码中，我新建了一个名为 list 的数组，里面随便放了一些数字，并通过模板绑定到我们的 HTML 中进行显示。</p><p>如果一切顺利，就会看到网页上显示了原始数组的内容：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/22/image-20210522225529353.png" alt="image-20210522225529353"></p><p>而对于 JavaScript 来说，使用其数组自带的排序方法无疑是最简单快捷的。</p><p>我们只需要在需要排序的数组对象后面使用自带的 <strong>sort()</strong> 即可将原数组进行从小到大的排序。而对于需要反向排序的数组，可以在使用完 <strong>sort()</strong> 方法后调用 <strong>reverse()</strong> 方法进行倒序处理。</p><p>这里我们修改示例代码的 mounted 部分，使得页面挂载后就调用 sort 和 reverse 方法对 list1 和 list2 进行排序：</p><pre><code class="javascript">mounted() {  this.list1.sort();  this.list2.sort().reverse();},</code></pre><p>然后修改上方 html 模板，将 list1 和 list2 进行展示：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;list_origin：{{ list0 }}&lt;/p&gt;    &lt;p&gt;array_sort_method：{{ list1 }}&lt;/p&gt;    &lt;p&gt;array_sort_reverse：{{ list2 }}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>以上代码在运行后，可以看到 list1 和 list2 已经完成了排序：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/22/image-20210522232912916.png" alt="image-20210522232912916"></p><h3 id="冒泡排序-JS实现"><a href="#冒泡排序-JS实现" class="headerlink" title="冒泡排序 JS实现"></a>冒泡排序 JS实现</h3><p>那么如果不使用 JS 自带的函数，如何使用传统的冒泡排序方法对数组进行排序呢？</p><p>这里偷一张冒泡排序的原理图<em>（来源菜鸟教程）</em>：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/22/bubbleSort.gif" alt="img"></p><ol><li>从原理图我们可以看到，冒泡排序的实质是按顺序依次比较相邻的两个数，如果发现左侧的大于右侧，就将这两个数交换顺序。</li><li>如此一轮交换下来后，整个序列的最后一位就一定是整个数组中最大的那个数。那么下一次循环的时候，我们就用同样的方式找到倒数第二大的数。</li><li>这样的过程一共重复 n-1 次，就完成了整个排序过程。</li></ol><p>那么用 JS 应该怎么实现呢？其实很简单，我们只需要用两层 for 循环嵌套即可：</p><pre><code class="javascript">methods: {  bubbleSort(list) {    for (let i = 0; i &lt; list.length - 1; i++) {      for (let j = 0; j &lt; list.length - i - 1; j++) {        if (list[j] &gt; list[j + 1]) {          let temp = list[j];          list[j] = list[j + 1];          list[j + 1] = temp;        }      }    }    return list;  },},</code></pre><p>如果使用 es6 的解构赋值，则内层 for 循环的两个变量的交换还可以写的更简单：</p><pre><code class="javascript">methods: {  bubbleSort(list) {    for (let i = 0; i &lt; list.length - 1; i++) {      for (let j = 0; j &lt; list.length - i - 1; j++) {        if (list[j] &gt; list[j + 1]) {          //  借用数组解构赋值          [list[j], list[j + 1]] = [list[j + 1], list[j]];        }      }    }    return list;  },},</code></pre><p>然后我们修改 html 模板，调用刚才写的排序方法：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;list_origin：{{ list0 }}&lt;/p&gt;    &lt;p&gt;array_sort_method：{{ list1 }}&lt;/p&gt;    &lt;p&gt;array_sort_reverse：{{ list2 }}&lt;/p&gt;    &lt;p&gt;bubble_sort：{{ this.bubbleSort(list0) }}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>运行后，我们可以在网页中看到，我们使用冒泡排序函数成功将数组从小到大进行了排列：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/23/image-20210523002355390.png" alt="image-20210523002355390"></p><h3 id="选择排序-JS实现"><a href="#选择排序-JS实现" class="headerlink" title="选择排序 JS实现"></a>选择排序 JS实现</h3><p>如果你能够理解冒泡排序的原理，那么相信选择排序对你来说一定不难理解。</p><p>继续从<em>菜鸟教程</em>偷一张动图：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/23/selectionSort.gif" alt="img"></p><p>不难从图中看出，选择排序的原理就是依次遍历数组，从中找到最小的那个数，把它排到数组的第一位。然后从第二位开始继续以同样的方式寻找除去第一位以外最小的数放在第二位。</p><p>同样，选择排序的 JS 实现也需要使用两层 for 循环的嵌套使用：</p><pre><code class="javascript">methods: {  selectionSort(list) {    for (let i = 0; i &lt; list.length; i++) {      for (let j = i + 1; j &lt; list.length; j++) {        if (list[i] &gt; list[j]) {          //  解构赋值          [list[i], list[j]] = [list[j], list[i]];        }      }    }    return list;  },},</code></pre><p>这里，我们再修改下 html 模板：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;list_origin：{{ list0 }}&lt;/p&gt;    &lt;p&gt;array_sort_method：{{ list1 }}&lt;/p&gt;    &lt;p&gt;array_sort_reverse：{{ list2 }}&lt;/p&gt;    &lt;p&gt;bubble_sort：{{ this.bubbleSort(list0) }}&lt;/p&gt;    &lt;p&gt;selection_sort：{{ this.selectionSort(list0) }}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>可以在浏览器看到选择排序的结果也已经正确显示了：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/23/image-20210523115030134.png" alt="image-20210523115030134"></p><h2 id="VUE-死循环"><a href="#VUE-死循环" class="headerlink" title="VUE 死循环"></a>VUE 死循环</h2><p>这里会有好奇的小伙伴发现了我在上面的例子中将 array 对象的 sort() 和 reverse() 方法放在 vue 生命周期的 mounted 阶段进行调用，那么为什么 JS 的 sort() 和 reverse() 方法不能放在 html 模板里呢？像下面这样：</p><pre><code class="html">&lt;p&gt;array_sort_method：{{ list1.sort() }}&lt;/p&gt;&lt;p&gt;array_sort_reverse：{{ list2.sort().reverse() }}&lt;/p&gt;</code></pre><p>这里咱们不讨论原因，先看下结果，如果在 html 模板语法里直接使用了 array 对象的内置方法会怎么样呢？</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/23/image-20210523115819222.png" alt="image-20210523115819222"></p><p>可以看到，虽然浏览器显示的页面里输出了正确的排序结果，但是控制台出现了报错，发生了死循环问题。那么这个问题究竟是怎么产生的呢？</p><p>其实如果通俗易懂的来说的话，可以解释为：因为 sort 方法操作的是源对象本身，也就是直接修改了 list1 和 list2 的值。而 vue 中 html 模板在对数据进行绑定的同时有对数据的监听。</p><p>也就是说，因为 html 模板里的 sort 方法修改了 list 的值，而 list 的值改变又使得 html 模板中监听的 list 发生变化，使得 vue 重新调用了 sort 方法对当前的 list 再次排序。<span style="color:#grey"><em>而再次排序又改变了绑定的 list 的值，使得 vue 重新调用了 sort 方法对当前的 list 再次排序。而再次排序又改变了绑定的 list 的值，使得 vue 重新调用了 sort 方法对当前的 list 再次排序。而再次排序又改变了绑定的 list 的值，使得 vue 重新调用了 sort 方法对当前的 list 再次排序。……</em></span></p><img src="https://media.everdo.cn/tank/pic-bed/2021/05/23/jinzhitaowa.jpg" alt="img" style="zoom:25%"><p>那么到这里你就能理解为什么将这些方法放到生命周期里了吧？如果小伙伴对 vue 生命周期还不熟的话，可以看我之前的文章哦！</p><p><a href="https://coding.emptinessboy.com/2021/04/VUE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%95%A5%EF%BC%9F/">传送门：VUE的生命周期是啥？</a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> WEB框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬砖小记：一个简单的加载中效果</title>
      <link href="/2021/04/%E6%90%AC%E7%A0%96%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C/"/>
      <url>/2021/04/%E6%90%AC%E7%A0%96%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%AD%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>这是一个使用绝对定位实现的完美居中。</p><blockquote><p>今天下午没事，就去了波公司转转，顺便帮学长打打杂，修修BUG🤔。其中我的任务之一就是为抽奖页面做一个加载遮罩。</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="横屏"><a href="#横屏" class="headerlink" title="横屏"></a>横屏</h3><p>在公司的项目中，有一个模仿王者荣耀的<strong>横屏</strong>抽奖页面。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/25/image-20210425231419737.png" alt="image-20210425231419737"></p><p>这是一个采用 uniapp 混合开发的 APP，然鹅，似乎 uniapp 开发的 app 在进行横竖屏强制切换的时候，会出现 font-size 莫名奇妙变大的问题。</p><p>为了避免因为强制页面横屏造成的文字突然变大的问题，所以我们在抽奖页面载入时添加了定时器，在页面开始载入后 500 毫秒进行横屏的旋转。</p><pre><code class="javascript">onLoad: function() {    // 延时 500ms 进行旋转    setTimeout(() =&gt; {        plus.screen.lockOrientation(&#39;landscape-primary&#39;);     }, 500)}</code></pre><p>这样一番设置后，页面显示确实没有啥明显的问题，但是先显示竖屏，再转为横屏的效果让人看起来不是特别舒服。（大概是下面这样</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/25/2.gif" alt="动画2"></p><h3 id="遮罩"><a href="#遮罩" class="headerlink" title="遮罩"></a>遮罩</h3><p>为了缓和页面载入后再旋转导致的奇怪显示效果，我决定在横屏载入前使用一个遮罩进行遮挡。这一步的优化非常简单，直接使用了 uView 中的 u-mask组件进行了遮挡：</p><pre><code class="html">&lt;u-mask :show=&quot;maskShow&quot; :custom-style=&quot;{background: &#39;##191C3F&#39;}&quot;&gt;    &lt;view style=&quot;width: 100%; height: 100%; display: flex; justify-content: center;align-items: center;&quot;&gt;        &lt;image style=&quot;width: 100rpx; height: 100rpx;&quot; mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;    &lt;/view&gt;&lt;/u-mask&gt;</code></pre><p>上面的代码中我使用了 u-mask 组件，并向组件中放置了插槽。插槽中的容器通过 flex 布局，实现了中间嵌入的 image 组件水平和垂直居中。</p><p>然后在页面载入时显示带有加载动图的遮罩，等待页面旋转完毕后，取消遮罩显示。</p><pre><code class="javascript">onLoad: function() {    setTimeout(() =&gt; {        plus.screen.lockOrientation(&#39;landscape-primary&#39;);        setTimeout(() =&gt; {            this.maskShow = false        }, 1000)    }, 500)}</code></pre><p>这种方法确实可以达到我想要的预期效果，<strong>可是在部分配置较低的手机上，就会出现旋转已经完成，但动图还没加载出来的情况。</strong></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>综合分析了一波，感觉可能是 flex 布局的渲染较慢的缘故，为了加快响应速度，于是这里就弃用 flex 布局采用了 absolute 绝对定位的方式，来使遮罩内容更快的进行加载。</p><pre><code class="html">&lt;u-mask :show=&quot;maskShow&quot; :custom-style=&quot;{background: &#39;##191C3F&#39;}&quot;&gt;    &lt;image style=&quot;position: absolute;left: 50%; top:50%;transform: translate(-50%,-50%); width: 100rpx; height 100rpx;&quot; mode=&quot;aspectFit&quot; src=&quot;/static/imgs/loading.gif&quot;&gt;    &lt;/image&gt;&lt;/u-mask&gt;</code></pre><p>在这一步优化完成后，可以看到页面旋转的过程已经被遮罩和加载动画进行了遮挡，相比之前有着更好的用户体验。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/25/1.gif" alt="动画1"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="绝对定位的完美居中"><a href="#绝对定位的完美居中" class="headerlink" title="绝对定位的完美居中"></a>绝对定位的完美居中</h3><p>我们都知道，使用 flex 布局可以很简单的实现一个完美的居中效果。（如果你还不会，可以看看我的上一篇文章 链接）。</p><p>那么使用 absolute/fixed 绝对定位是不是也能一样简单的做一个完美居中呢？答案是可以的。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>这里我们先使用 html 建一个简单的 div。给 body 和 div 设置不同的背景颜色。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;fixed布局完美居中&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        body {            background-color: aqua;        }        body&gt;div {            width: 300px;            height: 150px;            background-color: blueviolet;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/26/image-20210426103039358.png" alt="image-20210426103039358"></p><p>现在，我们给 div 加上绝对定位布局，并且设置了 left:50%; top:50%</p><pre><code class="css">body&gt;div {    width: 300px;    height: 150px;    background-color: blueviolet;    position: absolute;    left: 50%;    top: 50%;}</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/26/image-20210426103959426.png" alt="image-20210426103959426"></p><p>咦？说好的居中呢？怎么跑到右下角去了？</p><p>其实，这里我们使用 left 和 top 属性，更改的是 div 左上角的位置，我们可以看到 div 盒子的左上角已经处于当前 body 的中间了。那么如何让我们的整个 div 居中呢？</p><p>其实很简单，我们只要让 div 向左上角偏移 1/2 自身的宽度就可以了。而 CSS 中，我们可以使用 transform 来进行位置偏移：</p><pre><code class="css">transform: translate(-50%,-50%);</code></pre><p>加上这一行代码后，我们再刷新页面，可以看到 div 盒子已经使用绝对定位固定在页面中间了！</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/26/image-20210426104828419.png" alt="image-20210426104828419"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>是不是用绝对定位来写居中也很方便呢？在实际开发中，并不是说我们一定要使用较新的 flex 布局去取代传统的浮动定位或绝对定位，而是要根据项目的需要和实际运行效果来决定我们的布局方式。</p><blockquote><p>篇幅限制，完整示例代码请公众号后台回复 ”绝对居中“ 来获取。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> CSS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE的生命周期是啥？</title>
      <link href="/2021/04/VUE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%95%A5%EF%BC%9F/"/>
      <url>/2021/04/VUE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%95%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>对于 VUE.js 的生命周期，VUE 的官方文档灰常贴心的为我们准备了一个长长的图片，和那么一小段文字注解。不过说实话第一次看的时候我也是一头雾水的。</p></blockquote><p>VUE 的生命周期，就是一个 VUE 项目从初始化到销毁的全部过程。标准的 VUE.js 项目拥有，<strong>creat，mount，update 和 destory</strong> 四个生命周期，而每个生命周期都可以分为 before 和 after 两个不同的阶段。因此 VUE.js 一共有如下 8 个生命周期的钩子函数。</p><ul><li><strong>beforeCreate</strong></li><li><strong>created</strong></li><li><strong>beforeMount</strong></li><li><strong>mounted</strong></li><li><strong>beforeUpdate</strong></li><li><strong>updated</strong></li><li><strong>beforeDestroy</strong></li><li><strong>destroyed</strong></li></ul><p>通过生命周期钩子的函数，我们可以在 vue 实例的不同阶段添加自己的代码。</p><h2 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h2><p>这里我引用了网上一位 dalao 分享的演示代码（<strong>Author</strong>：fsrookie / <strong>代码出处</strong>：<a href="https://segmentfault.com/a/1190000011381906）。" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011381906）。</a></p><p>在这段示例中，我们将从 cdn 引入 vue.js 的相关代码，并在vue 每个生命周期钩子里向控制台打印当前的 周期，el 和 data，方便我们观测 vue 生命周期的不同阶段的状态。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;vue生命周期&lt;/title&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  var vm = new Vue({    el: &#39;#app&#39;,    data: {      message: &#39;Vue的生命周期&#39;    },    beforeCreate: function() {      console.group(&#39;------beforeCreate创建前状态------&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)     },    created: function() {      console.group(&#39;------created创建完毕状态------&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化    },    beforeMount: function() {      console.group(&#39;------beforeMount挂载前状态------&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化      console.log(this.$el);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化        console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化      },    mounted: function() {      console.group(&#39;------mounted 挂载结束状态------&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化      console.log(this.$el);          console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化     },    beforeUpdate: function () {      console.group(&#39;beforeUpdate 更新前状态===============》&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el.innerHTML);      console.log(this.$el.innerHTML);         console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     },    updated: function () {      console.group(&#39;updated 更新完成状态===============》&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el.innerHTML);      console.log(this.$el.innerHTML);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     },    beforeDestroy: function () {      console.group(&#39;beforeDestroy 销毁前状态===============》&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);          console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     },    destroyed: function () {      console.group(&#39;destroyed 销毁完成状态===============》&#39;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);        console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)    }  })&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="CREAT"><a href="#CREAT" class="headerlink" title="CREAT"></a>CREAT</h2><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420090248526.png" alt="image-20210420090248526"></p><p>CREAT 可以分为 beforeCreated 和 created 两个阶段：</p><h3 id="beforeCreated"><a href="#beforeCreated" class="headerlink" title="beforeCreated"></a>beforeCreated</h3><p>此时，组件实例刚刚创建，还未进行数据观测和事件配置。此时在 beforeCreate 中拿不到任何数据。</p><p>通过控制台的输出我们也可以看到，因为 el 和 data 并未初始化，所以 methods， data， computed 等方法和数据都是不能使用的。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420093013045.png" alt="image-20210420093013045"></p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>created 将在实例创建完后立即被调用。在 beforeCreated 到 created 的阶段，vue 实例已经完成了数据观测，属性和方法的计算，但尚未开始挂载。因此可以从控制台看到此时的的 data 已经和数据进行了绑定。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420093639117.png" alt="image-20210420093639117"></p><h2 id="MOUNT"><a href="#MOUNT" class="headerlink" title="MOUNT"></a>MOUNT</h2><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420094531840.png" alt="image-20210420094531840"></p><p>MOUNT 可以分为 beforeMount 和 mounted 两个阶段：</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>检查是否存在 el 属性，存在的话进行渲染 dom 操作（此时的 dom 还是虚拟 dom，并没有挂载到真实 dom 树上去），此时可以调用根节点 el 但不能调用真实节点 refs。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420095805324.png" alt="image-20210420095805324"></p><p>此时 vue 实例还会判断 vue 对象中有没有 template 选项，如果 vue 实例对象中有template参数选项，则将其作为模板编译。如果没有 template 选项，则将外部 HTML 作为模板编译。</p><blockquote><p>template 中的模板优先级要高于 outer HTML 的优先级。</p></blockquote><p>增加 template 选项代码：</p><pre><code class="javascript">var vm = new Vue({    el: &#39;#app&#39;,    template: &quot;&lt;h1&gt;{{message +'这是在template中的'}}&lt;/h1&gt;&quot;, //在vue配置项中修改的    data: {      message: &#39;Vue的生命周期&#39;    })</code></pre><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>在 mounted 之前 h1 中还是通过 <strong></strong> 进行占位的，因为此时还有挂在到页面上，还是 JavaScript 中的虚拟 DOM 形式存在的。在 mounted 之后可以看到 h1 的内容发生了变化，此时的 dom 为真实 dom。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420100637359.png" alt="image-20210420100637359"></p><p>但是 mounted 执行完毕后，并没有挂载所有的子组件，如果需要等待整个视图都渲染完毕，可以使用 vm.$nextTick。</p><pre><code class="java">mounted(){    this.$nextTick(()=&gt;{        // 执行代码    })}</code></pre><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420102141594.png" alt="image-20210420102141594"></p><p>当 vue 发现 data 中的数据发生了改变，会<strong>触发对应组件的重新渲染</strong>，先后调用 <strong>beforeUpdate</strong> 和 <strong>updated</strong> 钩子函数。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>此钩子在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。（也就是说还有什么更改可以在这阶段一并处理，最终只重新渲染一次dom，不重复渲染了）</p><p>这里，我们通过修改 vm.message 进行测试，可以看到目前 dom 还没有更新。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420102456243.png" alt="image-20210420102456243"></p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>此时 dom 元素已经被更新了，可以对 dom 进行相关操作。<strong>（大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。此外该钩子在服务器端渲染期间不被调用）</strong></p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420102721191.png" alt="image-20210420102721191"></p><h2 id="DESTORY"><a href="#DESTORY" class="headerlink" title="DESTORY"></a>DESTORY</h2><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420103605227.png" alt="image-20210420103605227"></p><p>DESTORY 可以分为 beforeDestory 和 destoryed 两个阶段：</p><h3 id="beforeDestory"><a href="#beforeDestory" class="headerlink" title="beforeDestory"></a>beforeDestory</h3><p>这个钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<strong>一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的 dom 事件。</strong></p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420104217468.png" alt="image-20210420104217468"></p><h3 id="destoryed"><a href="#destoryed" class="headerlink" title="destoryed"></a>destoryed</h3><p>钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。（该钩子在服务器端渲染期间不被调用）</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/20/image-20210420104300481.png" alt="image-20210420104300481"></p><blockquote><p>vue 的生命周期钩子虽然只有简单的 8 个，但要理清楚每个钩子的作用以及区别还是需要一丢丢时间的。重要的是要学会如何正确的使用生命周期钩子来执行自己想要的功能。（想到我自己以前的一个 vue 页面中设置了定时器，导致跳转其他页面后，定时器还在工作，那时我捣鼓了半天都没能清掉这个定时器，就是因为没掌握 vue 生命周期才导致的。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> WEB框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS居中傻傻搞不懂？教你！</title>
      <link href="/2021/04/CSS%E5%B1%85%E4%B8%AD%E5%82%BB%E5%82%BB%E6%90%9E%E4%B8%8D%E6%87%82%EF%BC%9F%E6%95%99%E4%BD%A0%EF%BC%81/"/>
      <url>/2021/04/CSS%E5%B1%85%E4%B8%AD%E5%82%BB%E5%82%BB%E6%90%9E%E4%B8%8D%E6%87%82%EF%BC%9F%E6%95%99%E4%BD%A0%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>不会吧，不会吧，不会有人 2021 年还在用百分比写 div 居中吧？</p></blockquote><p>每每说到 CSS 如何让一个块居中，dalao 们总是会嘲笑一番这种弱智问题。然而事实上在前端小白（包括我以前）初学网页设计的时候，往往会因为这一个问题摸不着头脑，甚至出现有用百分比和 text-aligin 尝试让块元素居中的”沙雕“行为。</p><p>.. 咳咳，说的就是初学时的我。一通代码猛如虎，最后却发现写的啥都不是。</p><p><strong>那么这篇文章就让我为大家细细讲解实现水平居中的两种方式，以及 flex 布局下的垂直居中。</strong></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/22e0ab2d437d23dc616bdffd69193621.jpg" alt="无语" style="zoom:25%"><h2 id="传统浮动布局"><a href="#传统浮动布局" class="headerlink" title="传统浮动布局"></a>传统浮动布局</h2><p>相信大家也都是和我一样，从最初的 float 布局开始学习 CSS 的。float 布局通过简单的浮动和清除浮动实现了复杂的样式布局在网页中的定位。</p><h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h3><p>对于学习 CSS 的小伙伴来说，margin（外边距）和 padding（内边距）这俩个熟悉大家一定不陌生。顾名思义，margin 就是指外边距，padding 就是指内边距。除了一个个手动设置 -top，-bottom，-left，-right 以外，这两个属性都有一种通用的简写方式。</p><pre><code class="css">margin:10px 5px 15px 20px;</code></pre><p>上面这种写法，分别代表了外边距的 <strong>上，右，下，左</strong>，即 margin-top，margin-right，margin-bottom，margin-left 分别为 10px，5px，15px，20px。</p><pre><code class="css">margin:10px 5px 15px;</code></pre><p>上面这种写法，分别代表了外边距的 <strong>上，左右，下，</strong>，即 margin-top，margin-x，margin-bottom，分别为 10px，5px，15px。</p><pre><code class="css">margin:10px 5px;</code></pre><p>上面这种写法，分别代表了外边距的 <strong>上下，左右</strong>，即 margin-y，margin-x，分别为 10px，5px。</p><pre><code class="css">margin:10px;</code></pre><p>上面这种写法，则表示四边的外边距均为 10px。</p><h3 id="浮动布局实现水平居中（margin-0-auto-的由来）"><a href="#浮动布局实现水平居中（margin-0-auto-的由来）" class="headerlink" title="浮动布局实现水平居中（margin: 0, auto 的由来）"></a>浮动布局实现水平居中（margin: 0, auto 的由来）</h3><p>边距 margin 和 padding 除了可以设置为数值，还支持配置为 auto 属性，来由浏览器计算外边距。</p><p><strong>填充规则：</strong></p><ul><li>如果一侧定值，一侧 auto，则 auto 为剩余空间大小</li><li>如果两侧均是 auto，则平分剩余空间</li></ul><p>因此接下来的就很好理解了。如果我们要实现水平居中，就只需要让 margin-left 和 margin-right 为 auto 就可以让浏览器自动分配剩余的左右空间了。</p><p>这里我们写一个简单的栗子🌰：</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;HTML5&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            body{                width: 100%;                height: 100vh;                background-color: rgb(252, 205, 136);            }            .box{                width: 300px;                height: 150px;                background-color: aquamarine;            }        &lt;/style&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;box&quot;&gt;&lt;p&gt;学长帆帆&lt;/p&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>运行后效果：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412212255636.png" alt="image-20210412212255636"></p><p>这时候，我们给 class 为 box 的 div 设置 <strong>margin : 0 auto 0 auto</strong> 后</p><pre><code class="css">.box{    /* 简写 */    margin: 0 auto;    /* 居中 */    /* margin: 10px auto 10px auto; */    /* 居左 */    /* margin: 10px auto 10px 10px; */    /* 居右 */    /* margin: 10px 10px 10px auto; */    width: 300px;    height: 150px;    background-color: aquamarine;}</code></pre><p>可以看到，中间的蓝绿色 div 已经在页面中成功居中了。同样的，根据文章开头讲过的简写，我们可以将 <strong>margin : 0 auto 0 auto</strong> 简写为 <strong>margin : 0 auto</strong></p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412212229962.png" alt="image-20210412212229962"></p><h2 id="flex-布局实现"><a href="#flex-布局实现" class="headerlink" title="flex 布局实现"></a>flex 布局实现</h2><p>刚才和大家分享了浮动布局，想必大家都已经学会了水平居中的方式。但是我们强大的 flex 布局可不仅仅可以用来写水平居中，还能够写垂直居中。</p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>这里我们用一个小栗子🌰来和大家说明，如何使用 flex 布局实现水平居中：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;about&quot;&gt;    &lt;div class=&quot;box_outer&quot;&gt;      &lt;div class=&quot;box_inner&quot;&gt;&lt;p&gt;学&lt;/p&gt;&lt;/div&gt;      &lt;div class=&quot;box_inner&quot;&gt;&lt;p&gt;长&lt;/p&gt;&lt;/div&gt;      &lt;div class=&quot;box_inner&quot;&gt;&lt;p&gt;帆&lt;/p&gt;&lt;/div&gt;      &lt;div class=&quot;box_inner&quot;&gt;&lt;p&gt;帆&lt;/p&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.about {  background-color: rgb(217, 186, 247);  display: flex;  // 水平居中  justify-content: center;  width: 100%;  height: 100vh;}.box_outer {  width: 800px;  height: 500px;  background-color: bisque;}&lt;/style&gt;</code></pre><p>运行后效果：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412214116190.png" alt="image-20210412214116190"></p><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>可以看到，我们通过给外层 div 加上了 <strong>display: flex; justify-content: center;</strong> 就实现了内层 div 的水平居中。那么如果要是垂直居中呢？其实只要加一行代码：<strong>align-items: center;</strong> 即可</p><pre><code class="css">.about {  background-color: rgb(217, 186, 247);  display: flex;  // 水平居中  justify-content: center;  // 垂直居中  align-items: center;  width: 100%;  height: 100vh;}</code></pre><p>运行效果：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412214924115.png" alt="image-20210412214924115"></p><h3 id="多元素居中"><a href="#多元素居中" class="headerlink" title="多元素居中"></a>多元素居中</h3><p>既然一个单独的 div 可以通过三行代码轻松实现垂直和水平方向上的居中，那么如果是好多个div呢？其实同样的，刚才的三行代码也可以办到！</p><p>这里我们为 box_outer 内的四个 box_inner 设置样式，并且在 box_outer 的属性中加上刚才的三行居中代码：</p><pre><code class="scss">.box_outer {  width: 800px;  height: 500px;  background-color: bisque;  display: flex;  // 水平居中  justify-content: center;  // 垂直居中  align-items: center;  // flex-direction: column;  .box_inner {    width: 80px;    height: 50px;    background-color: rgb(196, 255, 242);    margin: 15px;    // float: left;    // align-self: center;  }}</code></pre><p>运行效果：</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412215925429.png" alt="image-20210412215925429"></p><p>可以看到四个 inner_box 很完美的在 outer_box 里实现了垂直水平居中。</p><h3 id="高级：改变方向"><a href="#高级：改变方向" class="headerlink" title="高级：改变方向"></a>高级：改变方向</h3><p>flex-direction 可以用来控制 flex 元素的布局排列顺序。如果我们不加以设置，将会取默认值 row。如果我们手动将 flex-direction 改为 column 会发生什么呢？</p><pre><code class="css">flex-direction: column;</code></pre><p>可以看到，原先横向排列的四个 inner_box 现在变成了竖向排列，且仍然保持了垂直和水平居中！</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/12/image-20210412220421007.png" alt="image-20210412220421007"></p><blockquote><p>那么到这里你是不是也学会了 CSS 的居中呢？如果需要源代码，可以在公众号聊天界面回复 <strong>“代码居中”</strong> 即可！</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> CSS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个 TodoList 让你上手VUE</title>
      <link href="/2021/04/%E4%B8%80%E4%B8%AATodoList%E8%AE%A9%E4%BD%A0%E4%B8%8A%E6%89%8BVUE/"/>
      <url>/2021/04/%E4%B8%80%E4%B8%AATodoList%E8%AE%A9%E4%BD%A0%E4%B8%8A%E6%89%8BVUE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>想当初，自己自学 VUE.js 的时候，很简单的看了官网的入门教程就直接上手写项目了。从自己最初接触 VUE.js 到现在也有小半年了吧。但说实话自己对 VUE.js 的理解也仅仅在基础的会用上面。</p></blockquote><p>最近开始刚好有时间，正好打算拿本书，从头到尾好好扫盲堵漏一下。刚好身边的同学也开始入门 VUE ,不妨推荐一个简单的很适合初学者练手的小🌰栗子吧。</p><p>先看下最后成品的 demo 吧：</p><p><a href="https://up.media.everdo.cn/image/FLrS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/todolist_64.gif" alt="todolist_64.gif"></a></p><p>在输入框输入待办事项，点击增加后，在下方列表显示。单击列表项，可以进行编辑，在输入框失去焦点后自动保存。点击右侧红色叉叉可以删除列表中的这一项。这个简单的小页面虽然丑了点，但是包含了数据的增删改操作，标签循环，组件的使用，真的很适合初学上手呀！</p><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>开始写第一行代码之前，我们当然要打开我们的好朋友 IDE 啦。（什么？不会有人 2021 年还在用记事本写代码吧！）然后使用 vue cli 工具新建一个项目。</p><p>如果你的电脑还没有安装过 node.js ，是时候从 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a> 下载安装一波了。如果你已经安装了 node.js 还没有安装 vue cli 的话，可以参考官网的教程：<a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/</a></p><p>安装就绪后，我们运行 vue cli 建立我们的项目：</p><pre><code class="bash">vue creat todolist</code></pre><p>接下来的配置项可以参考图片中的示例进行配置</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/todolist_1.png" alt="todolist_1.png"></p><p>项目建立完成后可以用 VisualStudio Code 或者你喜欢的 IDE 打开，也可以删除无用的 HelloWorld.vue，About.vue 等等。如果一切顺利，你就可以看到和我一样的目录树啦。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/todolist_2.png" alt="todolist_2"></p><h2 id="编写第一个-VUE"><a href="#编写第一个-VUE" class="headerlink" title="编写第一个 VUE"></a>编写第一个 VUE</h2><p>项目初始化完成后，在项目根目录可以看到三个文件夹，分别是：node_modules，public，和 src。分别用来存放 node.js 模块，公共静态文件和 vue 程序代码。通过 src 下的 router，可以看到当前的首页的路由指向的组件名为 Home。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/newtodolist_1.png" alt="newtodolist_1"></p><p>那么我们需要编辑首页的内容，就只需要编辑 Home.vue 即可。</p><h3 id="插入输入框"><a href="#插入输入框" class="headerlink" title="插入输入框"></a>插入输入框</h3><p>这里我们先做代表事项列表的第一个部分，输入框和提交按钮。这一步灰常简单，只需要使用 HTML 中的 input 标签就可以实现：</p><pre><code class="html">&lt;form&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入待办事项&quot; v-model=&quot;inPut&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;增加&quot; @click=&quot;addList&quot; /&gt;&lt;/form&gt;</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/newtodolist_2.png" alt="newtodolist_2"></p><p>这样，我们就使用 input 标签做了一个简单的输入框和按钮。这里我们使用了 v-model 属性双向绑定了 input 的变量，并且在按钮 button 的 v-on:click 事件绑定了函数 addList()</p><h3 id="数据绑定和方法实现"><a href="#数据绑定和方法实现" class="headerlink" title="数据绑定和方法实现"></a>数据绑定和方法实现</h3><p>单纯在 input 标签绑定数据是不够的，我们还需要在 vue 文件中脚本部分的 data 中添加 inPut，并添加方法 addList() 的实现。这里，我们先额外添加一个数组 toDoList 用来存放待办事项列表。</p><pre><code class="vue">&lt;script&gt;export default {  name: &quot;Home&quot;,  data() {    return {      inPut: &quot;&quot;,      toDoList: [],    };  },  methods: {    addList() {      this.toDoList.push(this.inPut);      console.log(this.toDoList, this.inPut);      this.inPut = &quot;&quot;;    },  }}&lt;/script&gt;</code></pre><p>当用户点击表单旁的增加按钮时，就会调用定义的 addList 方法。其中利用数组自带的 push 方法，将输入框输入的内容添加到数组 todoList 中。</p><h3 id="用循环实现列表"><a href="#用循环实现列表" class="headerlink" title="用循环实现列表"></a>用循环实现列表</h3><p>接下来我们一起想办法将 toDoList 数组中的内容逐一遍历显示到页面中，其中最方便的就是使用 vue 的 v-for 循环功能。</p><pre><code class="html">&lt;ul class=&quot;list&quot;&gt;      &lt;li v-for=&quot;(item, index) in toDoList&quot; :key=&quot;index&quot;&gt;        &lt;list-item          :item=&quot;item&quot;          :index=&quot;index&quot;          @save=&quot;saveItem&quot;          @delete=&quot;deleteItem&quot;        /&gt;      &lt;/li&gt;&lt;/ul&gt;</code></pre><p>为了实现点击文字切换输入框的功能，我们把具体的每一条事项封装成了 listItem 组件。并向组件传递了 item，index 这两组数据，同时为组件添加了 save 和 delete 的回调方法。</p><h2 id="编写-listItem-组件"><a href="#编写-listItem-组件" class="headerlink" title="编写 listItem 组件"></a>编写 listItem 组件</h2><p>由于要实现点击进入编辑和失去焦点自动保存，我们可以将这一部分的代码独立处理，封装成组件来使用。在 components 文件夹中新建 listItem.vue 即可快速创建一个组件。</p><h3 id="模板布局"><a href="#模板布局" class="headerlink" title="模板布局"></a>模板布局</h3><p>这里最合适的布局方案就是采用段落 <code>&lt;p&gt;</code> 标签来展示单条待办事项的内容，使用 input 标签来展示点击待办事项后显示的输入框。</p><pre><code class="vue">&lt;template&gt;  &lt;span&gt;    &lt;p v-show=&quot;!active&quot;&gt;      &lt;span style=&quot;float: left&quot; @click=&quot;activeInput&quot;&gt;{{ item }}&lt;/span&gt;      &lt;span style=&quot;float: right&quot; @click=&quot;deleteItem&quot;&gt;❌&lt;/span&gt;    &lt;/p&gt;    &lt;input v-show=&quot;active&quot; type=&quot;text&quot; v-model=&quot;text&quot; @blur=&quot;inactiveInput&quot; /&gt;  &lt;/span&gt;&lt;/template&gt;</code></pre><p>同时通过 @click 事件在点击文本时，动态修改 active 的属性值来控制是显示文本还是显示输入框。同时使用输入框的 @blur 事件触发失去焦点的动作（修改 active 为 false）。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>设计完页面模板后，就只需要根据模板里出现的数据进行绑定即可。这里不要忘记用 props 接收父组件传过来的参数 item 和 index。</p><pre><code class="vue">&lt;script&gt;// @ is an alias to /srcexport default {  name: &quot;ListItem&quot;,  components: {},  props: [&quot;item&quot;, &quot;index&quot;],  data() {    return {      text: &quot;&quot;,      active: false,    };  },  methods: {    //方法  },};&lt;/script&gt;</code></pre><h3 id="方法实现（调用父组件方法）"><a href="#方法实现（调用父组件方法）" class="headerlink" title="方法实现（调用父组件方法）"></a>方法实现（调用父组件方法）</h3><p>当待办事项文本被点击时触发 activeInput，于是改变 this.active 的值来切换输入框的显示，并通过 this.text = this.item 使得输入框的文字和当前文本一致。</p><p>当失去交点时，调用 inactiveInput 方法，由于待办事项数组存放在父组件 Home.vue 中，因此需要通过 this.$emit 来执行父组件中绑定的回调函数。</p><p>当点击删除图标后，调用 deleteItem 方法，调用父组件的 delete 回调来删除数组中的指定位置元素。</p><pre><code class="javascript">methods: {    activeInput() {      this.active = true;      this.text = this.item;    },    inactiveInput() {      this.$emit(&quot;save&quot;, this.index, this.text);      this.active = false;    },    deleteItem() {      this.$emit(&quot;delete&quot;, this.index);    },},</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/newtodolist_3.png" alt="newtodolist_3"></p><h3 id="父组件方法实现"><a href="#父组件方法实现" class="headerlink" title="父组件方法实现"></a>父组件方法实现</h3><p>父组件中绑定回调的函数，saveItem 和 deleteItem 分别使用了 javascript 中数组自带的 splice 方法对 todoList 数组中的数据做了修改和删除。</p><pre><code class="javascript">methods: {    addList() {      this.toDoList.push(this.inPut);      console.log(this.toDoList, this.inPut);      this.inPut = &quot;&quot;;    },    saveItem(index, content) {      console.log(&quot;saveItem&quot;, index, content);      this.toDoList.splice(index, 1, content);    },    deleteItem(index) {      console.log(&quot;deleteItem&quot;, index);      this.toDoList.splice(index, 1);    },},</code></pre><h2 id="使用CSS美化"><a href="#使用CSS美化" class="headerlink" title="使用CSS美化"></a>使用CSS美化</h2><p>项目很简单，只需要使用一点点 CSS 稍作美化即可。这里我主要做了简单的居中处理，并设置了宽高和背景色等。</p><pre><code class="vue">&lt;style scoped lang=&quot;scss&quot;&gt;.home {  width: 250px;  height: 500px;  background-color: rgb(166, 219, 255);  padding: 40px;  display: flex;  flex-direction: column;  align-items: center;  .list {    margin-left: -25px;    width: 200px;  }}&lt;/style&gt;</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/newtodolist_4.png" alt="newtodolist_4"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>到这里，一个简单的包含基本数据操作的小 demo 就完成了，对于 VUE 的初学者熟悉 VUE.js 的特性还是灰常棒滴。当然这个案例也还有可以改进的地方，比如说可以用 LocalStorage 存储 todoList 数组，就可以长时间保存列表等等。</p><blockquote><p>篇幅限制，完整代码请公众号后台回复 ”代码ToDo“ 来获取。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue,前端,demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStrom 构建 Vue 并与 bootstrap 集成</title>
      <link href="/2020/11/%E4%BD%BF%E7%94%A8-WebStrom-%E6%9E%84%E5%BB%BA-Vue3-x-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/11/%E4%BD%BF%E7%94%A8-WebStrom-%E6%9E%84%E5%BB%BA-Vue3-x-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>最近因为一个项目需要使用 vue.js ，所以特地上来学习一波。</p><p>因为看到官方 vue,js 已经更行到了 3.x 版本了。为了更好的学习新知识（其实是为了偷懒），打算直接从 vue.js 3.0 开始学习。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>相比直接使用 html 来进行 vuejs 的开发，使用 vue-cli 可以很方便的帮我们一键创建 vue 项目。看起来很高大上是不是？但这背后是需要准备 vue-cli 必备的运行环境的。</p><p>这里我是用的 IDE 是 Jetbrains 的 WebStorm。当然，使用 visual studio code 也是可以很方便进行 vue 的开发的。</p><h3 id="安装-npm-和-webstorm"><a href="#安装-npm-和-webstorm" class="headerlink" title="安装 npm 和 webstorm"></a>安装 npm 和 webstorm</h3><ul><li><a href="https://www.jetbrains.com/webstorm/download/#section=windows" target="_blank" rel="noopener">WebStorm 下载</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 下载</a></li></ul><p>这里为大家贴出了最新版的下载地址。下载安装的话很简单，一路 next 基本不会遇到什么问题。这里就不再赘述了。</p><p><a href="https://up.media.everdo.cn/image/jTrJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/node.png" alt="node.png"></a></p><p><a href="https://up.media.everdo.cn/image/jXvy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/webstorm.png" alt="webstorm.png"></a></p><p>安装完 node.js 以后，我们试着在终端输入命令：</p><pre><code class="bash"># 查看 node 版本node --version# 查看 npm 版本npm --version</code></pre><p>在我们安装 node.js 的时候，其实系统也会一并为我们安装好 npm 包管理器。如果 node 安装完成后，在刚才的终端找不到命令的话，我们还需要手工添加环境变量。</p><h3 id="修改-npm-源"><a href="#修改-npm-源" class="headerlink" title="修改 npm 源"></a>修改 npm 源</h3><p>由于各种你懂的原因，在没有使用特殊操作的情况下，国内访问 npm 的源会非常慢，为了方便下面的安装。我们可以使用淘宝为我们提供的 npm 源，也可以直接使用淘宝的 cnpm。</p><p>使用下面的命令就可以一键将源设为淘宝源：</p><pre><code class="bash"># 设置 淘宝镜像源npm config set registry https://registry.npm.taobao.org# 查看 使用的 镜像源npm config get registry</code></pre><p><strong>还原办法：</strong></p><pre><code class="bash"># 还原办法npm config set registryhttps://registry.npmjs.org# 查看 使用的 镜像源npm get registry </code></pre><p>如果设置成功后应该可以看到和我一样的输出：</p><p><a href="https://up.media.everdo.cn/image/jCld" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_5.png" alt="vuejslearn_5.png"></a></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><blockquote><p>之前我一直没有在 webstorm 找到创建 vue.js 3 的入口，一度以为是 IDE 不支持。于是乎傻傻的尝试了先在 webstrom 创建 vue2.x 的项目，再一路 <code>npm install vue@next</code> 更新到 3.x 版本。</p></blockquote><p>但事实上，这个入口是存在的，哈哈哈哈哈。而且我今天才发现，，（所以特地写文记录下</p><h3 id="设置项目信息"><a href="#设置项目信息" class="headerlink" title="设置项目信息"></a>设置项目信息</h3><p>打开 webstrom，选择新建项目。其中 node 和 vue-cli 的安装路径系统会自动检测</p><p><a href="https://up.media.everdo.cn/image/jpDl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_1.jpg" alt="vuejslearn_1.jpg"></a></p><p>要注意哦，如果要创建 vue3.x 项目的话，这里千万不要勾上。不然系统会自动为我们创建 vue2.x 的项目。</p><h3 id="手动选择-vue-版本"><a href="#手动选择-vue-版本" class="headerlink" title="手动选择 vue 版本"></a>手动选择 vue 版本</h3><p>这时候，IDE 并不会像选择了自动选项那样，一股脑帮我们把整个项目创建好。而是会在下方的运行窗口里显示选择 vue 版本的选项。</p><p><a href="https://up.media.everdo.cn/image/jtf0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_2.jpg" alt="vuejslearn_2.jpg"></a></p><p>这里使用键盘方向键就可以切换版本。选择后，回车确认即可。</p><p>然后我们要做的就是泡杯茶，等待慢吞吞的 npm 在那儿把项目构建完。</p><p><a href="https://up.media.everdo.cn/image/jUjL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_6.png" alt="vuejslearn_6.png"></a></p><p>不出意外的话，当进度条跑完，就可以看到项目文件下 package.json 文件里的 vue 版本已经显示为 3.0.0</p><p><a href="https://up.media.everdo.cn/image/jwGD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_3.jpg" alt="vuejslearn_3.jpg"></a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>项目构建完成后，系统自动生成的 src 文件夹就是存放代码的地方，并且系统已经为我们创建了一个 helloworld 的模板：</p><p><a href="https://up.media.everdo.cn/image/jZNc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_7.png" alt="vuejslearn_7.png"></a></p><p>运行下看看：</p><p><a href="https://up.media.everdo.cn/image/j5t2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/04/vuejslearn_8.png" alt="vuejslearn_8.png"></a></p><h2 id="bootStrap-集成"><a href="#bootStrap-集成" class="headerlink" title="bootStrap 集成"></a>bootStrap 集成</h2><p>由于 BootStrap 框架高度依赖 jQuery，而 vue.js 已经可以取代 jQuery 的多数功能。同一个项目中使用两套 js 框架会显得比较冗余。因此，Bootstrap-Vue 就为我们解决了这个问题。</p><h3 id="创建-vue2-x-项目"><a href="#创建-vue2-x-项目" class="headerlink" title="创建 vue2.x 项目"></a>创建 vue2.x 项目</h3><p>由于 bootstrap-vue 尚未很好的兼容 vue3，至少截止我写这篇文章的时候。所以想要在 vue 项目中使用 bootstrap 最稳妥的方案就是使用 vue2.x 版本进行构建。</p><p><a href="https://up.media.everdo.cn/image/jKIZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_2.png" alt="Image_2.png"></a></p><p>这里设置了必要的组件和配置项。关于配置项会在文末有具体的解释。</p><p>完成配置后，等待系统的自动构建。此时系统会为我们创建一个普通的 vue-2.0 项目。我们还需要使用 vue-cli 安装 bootstrap-vue 插件。</p><ul><li><a href="https://bootstrap-vue.org/" target="_blank" rel="noopener">插件官网 bootstrap-vue.org</a></li></ul><p><a href="https://up.media.everdo.cn/image/onhY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_3.png" alt="Image_3.png"></a></p><p>这里可以看到使用 cli 方式为 vue 项目添加 bootstrap 支持非常发容易。只需要下面一行命令：</p><pre><code class="bash"># 进入项目目录vue add bootstrap-vue</code></pre><p><a href="https://up.media.everdo.cn/image/oBys" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_4.png" alt="Image_4.png"></a></p><p>安装成功！</p><p><a href="https://up.media.everdo.cn/image/o7ra" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_5.png" alt="Image_5.png"></a></p><p>这时，我们可以看到 package.json 里面已经有了相关的插件信息。</p><h3 id="运行-bootStrap-实例"><a href="#运行-bootStrap-实例" class="headerlink" title="运行 bootStrap 实例"></a>运行 bootStrap 实例</h3><p>为了测试 bootStrap 能否正常在 vue 项目中工作。我们使用下面的 navbar 代码模板进行测试。</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;b-navbar toggleable=&quot;lg&quot; type=&quot;dark&quot; variant=&quot;info&quot;&gt;      &lt;b-navbar-brand href=&quot;#&quot;&gt;NavBar&lt;/b-navbar-brand&gt;      &lt;b-navbar-toggle target=&quot;nav-collapse&quot;&gt;&lt;/b-navbar-toggle&gt;      &lt;b-collapse id=&quot;nav-collapse&quot; is-nav&gt;        &lt;b-navbar-nav&gt;          &lt;b-nav-item href=&quot;#&quot;&gt;Link&lt;/b-nav-item&gt;          &lt;b-nav-item href=&quot;#&quot; disabled&gt;Disabled&lt;/b-nav-item&gt;        &lt;/b-navbar-nav&gt;        &lt;!-- Right aligned nav items --&gt;        &lt;b-navbar-nav class=&quot;ml-auto&quot;&gt;          &lt;b-nav-form&gt;            &lt;b-form-input size=&quot;sm&quot; class=&quot;mr-sm-2&quot; placeholder=&quot;Search&quot;&gt;&lt;/b-form-input&gt;            &lt;b-button size=&quot;sm&quot; class=&quot;my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/b-button&gt;          &lt;/b-nav-form&gt;          &lt;b-nav-item-dropdown text=&quot;Lang&quot; right&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;EN&lt;/b-dropdown-item&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;ES&lt;/b-dropdown-item&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;RU&lt;/b-dropdown-item&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;FA&lt;/b-dropdown-item&gt;          &lt;/b-nav-item-dropdown&gt;          &lt;b-nav-item-dropdown right&gt;            &lt;!-- Using &#39;button-content&#39; slot --&gt;            &lt;template v-slot:button-content&gt;              &lt;em&gt;User&lt;/em&gt;            &lt;/template&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;Profile&lt;/b-dropdown-item&gt;            &lt;b-dropdown-item href=&quot;#&quot;&gt;Sign Out&lt;/b-dropdown-item&gt;          &lt;/b-nav-item-dropdown&gt;        &lt;/b-navbar-nav&gt;      &lt;/b-collapse&gt;    &lt;/b-navbar&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>把这段代码简单的直接粘贴到 App.vue 中：</p><p><a href="https://up.media.everdo.cn/image/oRu3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_6.png" alt="Image_6.png"></a></p><p>使用 npm-server 运行的效果：</p><p><a href="https://up.media.everdo.cn/image/ooVG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/Image_1.png" alt="Image_1.png"></a></p><p>可以看到 bootstarp 的导航栏已经正确显示在网页中！已经成功在 vue 项目中使用 bootstrap。</p><h2 id="vue-cli-配置项说明"><a href="#vue-cli-配置项说明" class="headerlink" title="vue-cli 配置项说明"></a>vue-cli 配置项说明</h2><pre><code class="bash"># 构建项目vue create vue-admin</code></pre><p><a href="https://up.media.everdo.cn/image/jusI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/3.jpg" alt="3.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/o4GX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/4.jpg" alt="4.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/oPk4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/5.jpg" alt="5.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/oItM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/6.jpg" alt="6.jpg"></a></p><p><strong>路由模式有两种：hash、histor：</strong></p><p>hash - 即地址栏URL中的 <strong style="color:red">#</strong> 符号；如：<a href="http://www.abc.com/" target="_blank" rel="noopener">http://www.abc.com/</a><strong style="color:red">#</strong>/hello</p><blockquote><p>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（怎么去除URL中的“<strong style="color:red">#</strong>”号，此方法<br>需要后端 Apache 或 Nginx 进行简单的路由配置，否则会报404。）</p><p><em>注：这两个配置就是解决URL有没有 “<strong style="color:red">#</strong>” 号的问题，如果不在意 “#” 号这个东西，就用hash。在意就用 history。</em></p></blockquote><p><a href="https://up.media.everdo.cn/image/oJoi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/7.jpg" alt="7.jpg"></a></p><p>代码规范一般选择 Prettier：</p><p><a href="https://up.media.everdo.cn/image/j8yB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/8.jpg" alt="8.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/jalt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/9.jpg" alt="9.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/jLrk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/10.jpg" alt="10.jpg"></a></p><p>用于第二次快速创建项目：</p><p><a href="https://up.media.everdo.cn/image/jlVx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/05/11.jpg" alt="11.jpg"></a></p><h3 id="VUE-UI"><a href="#VUE-UI" class="headerlink" title="VUE UI"></a>VUE UI</h3><p>新版的 VUE 工具为我们提供了一个方便操作的 UI，可以直接通过 VUE UI 快速的安装项目需要的插件，依赖，修改添加一些基本配置。</p><p>启动命令：（在项目目录运行）</p><pre><code class="bash">vue ui</code></pre><p><a href="https://up.media.everdo.cn/image/o2s9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/09/vue-ui.png" alt="vue-ui.png"></a></p><p>启动后效果如下：</p><p><a href="https://up.media.everdo.cn/image/oFKj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/09/start-vue-ui.png" alt="start-vue-ui.png"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> WEB框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 的输入输出重定向（转）</title>
      <link href="/2020/10/Linux-%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2020/10/Linux-%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>本文 <strong>转载</strong> 编辑自大佬 <a href="https://aimuke.github.io/linux/2019/05/29/redirect/" target="_blank" rel="noopener">https://aimuke.github.io/linux/2019/05/29/redirect/</a> 的文章</p><p>因为这两天我按照学校课程进行 Linux 实验的时候，发现教科书上说的 Linux 输入输出重定向好像根本行不通。看了各种资料，越看越稀里糊涂。直到看到这一篇，秒懂（奥力给！！）</p></blockquote><a id="more"></a><p><code>&gt;/dev/null 2&gt;&amp;1</code> 含义</p><ul><li><code>/dev/null</code> ：代表空设备文件</li><li><code>&gt;</code> ：代表重定向到哪里，例如：<code>echo &quot;123&quot; &gt; /home/123.txt</code></li><li><code>1</code> ：表示stdout标准输出，系统默认值是 <code>1</code>，所以 <code>&gt;/dev/null</code> 等同于 <code>1&gt;/dev/null</code></li><li><code>2</code> ：表示stderr标准错误</li><li><code>&amp;</code> ：表示等同于的意思，<code>2&gt;&amp;1</code>，表示 <code>2</code> 的输出重定向等同于 <code>1</code></li></ul><p><code>&gt;/dev/null 2&gt;&amp;1</code> 语句含义：</p><ul><li><code>&gt;/dev/null</code> ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。</li><li><code>2&gt;&amp;1</code> ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</li></ul><h2 id="shell-重定向介绍"><a href="#shell-重定向介绍" class="headerlink" title="shell 重定向介绍"></a>shell 重定向介绍</h2><p>就像我们平时写的程序一样，一段程序会处理外部的输入，然后将运算结果输出到指定的位置。在交互式的程序中，输入来自用户的键盘和鼠标，结果输出到用户的屏幕，甚至播放设备中。而对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。</p><p>shell 脚本也一样，但是我们一般在使用 shell 命令的时候，更多地还是通过键盘输入，然后在屏幕上查看命令的执行结果。如果某些情况下，我们需要将 shell 命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><blockquote><p>文件描述符是与文件输入、输出关联的整数。它们用来跟踪已打开的文件。最常见的文件描述符是 stidin、stdout、和 stderr。我们可以将某个文件描述符的内容重定向到另外一个文件描述符中。</p></blockquote><p>当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：</p><table><thead><tr><th align="left">类型</th><th align="left">文件描述符</th><th align="left">默认情况</th><th align="left">对应文件句柄位置</th></tr></thead><tbody><tr><td align="left">标准输入（standard input）</td><td align="left"><strong>0</strong></td><td align="left">从键盘获得输入</td><td align="left">/proc/slef/fd/0</td></tr><tr><td align="left">标准输出（standard output）</td><td align="left"><strong>1</strong></td><td align="left">输出到屏幕（即控制台）</td><td align="left">/proc/slef/fd/1</td></tr><tr><td align="left">错误输出（error output）</td><td align="left"><strong>2</strong></td><td align="left">输出到屏幕（即控制台）</td><td align="left">/proc/slef/fd/2</td></tr></tbody></table><p>所以我们平时在执行 shell 命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将 1 指向文件，那么标准的输出就会输出到文件中。</p><p><strong>输出描述符不指定时，默认值为 <code>1</code> , 输入不指定默认为 <code>0</code></strong>， 如:</p><pre><code class="sh">command &gt; file.txtcommand 2&gt; command &lt; file</code></pre><p>等同于</p><pre><code class="sh">command 1&gt; file.txtcommand 2&gt; 1command 0&lt; file</code></pre><p><code>&amp;&gt; file</code> 将 <code>1</code> 和 <code>2</code> 都重定向到 <code>file</code></p><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><h3 id="输出重定向-gt-和-gt-gt"><a href="#输出重定向-gt-和-gt-gt" class="headerlink" title="输出重定向 &gt; 和 &gt;&gt;"></a>输出重定向 &gt; 和 &gt;&gt;</h3><p>重定向操作符号有两个 <code>&gt;</code> 和 <code>&gt;&gt;</code> 。符号的左边表示文件描述符，<strong>如果没有的话表示<code>1</code>，也就是标准输出</strong>。符号的右边可以是一个文件，也可以是一个输出设备。</p><p>尽管这两个操作符都可以将重定向到文件，但是前者<code>&gt;</code>会先清空文件，再写入内容；后者<code>&gt;&gt;</code>会将内容追加到现有文件的尾部。（对了，重定向的操作制定的文件如果原来不存在的话，重定向的操作会主动创建这个文件名的文件的）</p><p>输出重定向的使用方式很简单，基本的一些命令如下：</p><table><thead><tr><th align="left">命令</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">command &gt;filename</td><td align="left">把标准输出 重定向 到新文件中</td></tr><tr><td align="left">command 1&gt;filename</td><td align="left">同上</td></tr><tr><td align="left">command &gt;&gt;filename</td><td align="left">把标准输出 追加 到文件中</td></tr><tr><td align="left">command 1&gt;&gt;filename</td><td align="left">同上</td></tr><tr><td align="left">command 2&gt;filename</td><td align="left">把标准<strong>错误</strong> 重定向 到新文件中</td></tr><tr><td align="left">command 2&gt;&gt;filename</td><td align="left">把标准<strong>错误</strong> 追加 到新文件中</td></tr></tbody></table><p>为了更好地理解输出重定向，感受重定向的“魅力”，我们看一下以下的例子：我们创建一个测试目录，目录下面仅有一个 1.txt 文件。</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ echo &quot;123456&quot; &gt; 1.txt[huxiaofan@huxiaofan-centos8 learn]$ ll总用量 4-rw-rw-r-- 1 huxiaofan huxiaofan 7 10月 15 03:22 1.txt[huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txtls: 无法访问 &#39;2.txt&#39;: 没有那个文件或目录1.txt</code></pre><p>在我们执行 <code>ls 1.txt 2.txt</code> 之后，一共有两种输出，其中 ls: 无法访问 2.txt：没有那个文件或目录是错误输出，1.txt是标准输出。</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txt 1&gt; outls: 无法访问&#39;2.txt&#39;: 没有那个文件或目录[huxiaofan@huxiaofan-centos8 learn]$ cat out1.txt[huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txt 1&gt;&gt; outls: 无法访问&#39;2.txt&#39;: 没有那个文件或目录[huxiaofan@huxiaofan-centos8 learn]$ cat out1.txt1.txt</code></pre><p>在上述命令中，我们将<strong>原来的标准输出重定向到了 out 文件中</strong>，所以控制台只剩下了错误提示。并且当执行了追加操作时，out 文件的内容非但没有被清空，反而又多了一条 1.txt。</p><p>同理，我们也可以将错误输出重定向到文件中：</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txt 2&gt;&gt; err1.txt[huxiaofan@huxiaofan-centos8 learn]$ cat errls: 无法访问&#39;2.txt&#39;: 没有那个文件或目录[huxiaofan@huxiaofan-centos8 learn]$ [huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txt 2&gt; err &gt; out[huxiaofan@huxiaofan-centos8 learn]$ cat out1.txt[huxiaofan@huxiaofan-centos8 learn]$ cat errls: 无法访问&#39;2.txt&#39;: 没有那个文件或目录[huxiaofan@huxiaofan-centos8 learn]$ </code></pre><p>看到这里，朋友们可能会发现 <code>&gt;out 2&gt;err</code> 和我们在一开头提到的 <code>&gt;/dev/null 2&gt;&amp;1</code> 已经很像了，别急，这待会再说。</p><pre><code class="sh">cmd &gt; output.txt 2&gt;&amp;1cmd &amp;&gt; output.txtcmd &gt;&amp; output.txt  #三个表达式效果一样哒~</code></pre><h3 id="输入重定向-lt"><a href="#输入重定向-lt" class="headerlink" title="输入重定向 &lt;"></a>输入重定向 &lt;</h3><p>在理解了输出重定向之后，理解输入重定向就会容易得多。对输入重定向的基本命令如下：</p><table><thead><tr><th align="left">命令</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">command &lt;filename</td><td align="left">以 filename 文件作为标准输入</td></tr><tr><td align="left">command 0&lt;filename</td><td align="left">同上</td></tr><tr><td align="left">command &lt;&lt;delimiter</td><td align="left">从标准输入中读入，直到遇到 delimiter 分隔符</td></tr></tbody></table><p>我们使用 <code>&lt;</code> 对输入做重定向，如果符号左边没有写值，那么默认就是 <code>0</code>。</p><h4 id="CAT-命令简单解析"><a href="#CAT-命令简单解析" class="headerlink" title="CAT 命令简单解析"></a>CAT 命令简单解析</h4><p>我们这次以 <code>cat</code> 命令为例，如果 <code>cat</code> 后面没有跟文件名的话，那它的作用就是将标准输入（比如键盘）回显到标准输出（比如屏幕）上：</p><blockquote><p>补充：类似初学编程时的应声虫程序，你输入啥，它在屏幕上打印啥：</p></blockquote><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ cat123123testtest</code></pre><p>我们可以将利用输入重定向，将我们在键盘上敲入的字符写入到文件中。我们需要使用 <code>ctrl+c</code> 来结束输入：</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ cat &gt;out123test^C[huxiaofan@huxiaofan-centos8 learn]$ cat out123test</code></pre><p>那么<code>&lt;&lt;</code>又是什么作用呢？我们再看：</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ cat &gt; out &lt;&lt; end&gt; aaa&gt; bbb&gt; ccc&gt; end[huxiaofan@huxiaofan-centos8 learn]$ cat outaaabbbccc[huxiaofan@huxiaofan-centos8 learn]$ </code></pre><p>我们看到，当我们输入完<code>cat &gt;out &lt;&lt;end</code>，然后敲下回车之后，命令并没有结束，此时<code>cat</code>命令像一开始一样，等待你给它输入数据。然后当我们敲入<code>end</code>之后，cat命令就结束了。<code>end</code>之前输入的字符都已经被写入到了out文件中。这就是输入分割符的作用。</p><h4 id="CAT-演示输出重定向"><a href="#CAT-演示输出重定向" class="headerlink" title="CAT 演示输出重定向"></a>CAT 演示输出重定向</h4><p>好了，此时我们觉得自己在键盘上敲比较累，还是直接让 <code>cat</code> 读取一个文件吧。那么我们需要利用输入重定向：</p><pre><code class="sh"># 先清空 out 文件[huxiaofan@huxiaofan-centos8 learn]$ echo &gt; out[huxiaofan@huxiaofan-centos8 learn]$ cat out[huxiaofan@huxiaofan-centos8 learn]$ echo -e  &quot;123\n456\n789&quot; &gt; input[huxiaofan@huxiaofan-centos8 learn]$ cat input123456789[huxiaofan@huxiaofan-centos8 learn]$ cat &lt; input &gt; out# 其实这一步效果相当于把 input 文件作为输入，输入到 cat 里，再输出到 out 文件[huxiaofan@huxiaofan-centos8 learn]$ cat out123456789[huxiaofan@huxiaofan-centos8 learn]$ </code></pre><p>神奇的事情发生了，out文件里面的内容被替换成了input文件里的内容。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="重定向绑定"><a href="#重定向绑定" class="headerlink" title="重定向绑定"></a>重定向绑定</h3><p>好了，在有了以上知识的基础上，我们再来看开头提到的 <code>&gt;/dev/null 2&gt;&amp;1</code>。这条命令其实分为两命令，一个是 <code>&gt;/dev/null</code>，另一个是 <code>2&gt;&amp;1</code>。</p><ul><li><p><code>&gt;/dev/null</code></p><p>这条命令的作用是将标准输出 <code>1</code> 重定向到 <code>/dev/null</code> 中。<code>/dev/null</code> 代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了 <code>&gt;/dev/null</code> 之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。</p></li><li><p><code>2&gt;&amp;1</code></p><p>这条命令用到了重定向绑定，采用 <code>&amp;</code> 可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。</p></li></ul><p>linux 在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以 <code>&gt;/dev/null 2&gt;&amp;1</code> 的作用就是让标准输出重定向到 <code>/dev/null</code>中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了 <code>/dev/null</code> 中，错误输出同样也被丢弃了。执行了这条命令之后，<strong>该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中</strong>。</p><h3 id="nohup结合"><a href="#nohup结合" class="headerlink" title="nohup结合"></a>nohup结合</h3><p>我们经常使用 <code>nohup command &amp;命令</code> 形式来启动一些后台程序，比如一些 java 服务：</p><pre><code class="sh"># nohup java -jar xxxx.jar &amp;</code></pre><p>为了不让一些执行信息输出到前台（控制台），我们还会加上刚才提到的 <code>&gt;/dev/null 2&gt;&amp;1</code> 命令来丢弃所有的输出：</p><pre><code class="sh"># nohup java -jar xxxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><h3 id="gt-file-2-gt-amp-1-和-2-gt-amp-1-gt-file-的区别"><a href="#gt-file-2-gt-amp-1-和-2-gt-amp-1-gt-file-的区别" class="headerlink" title="&gt;file 2&gt;&amp;1 和 2&gt;&amp;1 &gt;file 的区别"></a><code>&gt;file 2&gt;&amp;1</code> 和 <code>2&gt;&amp;1 &gt;file</code> 的区别</h3><p>再回到文章的开头，我说我弄反了 <code>&gt;file</code> 和 <code>2&gt;&amp;1</code> 拼装的顺序，导致出了一点小问题。乍眼看这两条命令貌似是等同的，但其实大为不同。刚才提到了，linux 在执行 shell 命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析 <code>2&gt;&amp;1 &gt;file</code>：</p><ul><li><p><code>2&gt;&amp;1</code>，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。</p></li><li><p><code>&gt;file</code>，将标准输出<code>1</code>重定向到file中。</p></li></ul><p>我们用一个表格来更好地说明这两条命令的区别：</p><table><thead><tr><th align="left">命令</th><th align="left">标准输出</th><th align="left">错误输出</th></tr></thead><tbody><tr><td align="left">&gt;file 2&gt;&amp;1</td><td align="left">file</td><td align="left">file</td></tr><tr><td align="left">2&gt;&amp;1 &gt;file</td><td align="left">file</td><td align="left">屏幕</td></tr></tbody></table><h3 id="gt-file-2-gt-amp-1-和-gt-file-2-gt-file-区别"><a href="#gt-file-2-gt-amp-1-和-gt-file-2-gt-file-区别" class="headerlink" title="&gt;file 2&gt;&amp;1 和 &gt;file 2&gt;file 区别"></a><code>&gt;file 2&gt;&amp;1</code> 和 <code>&gt;file 2&gt;file</code> 区别</h3><p>那么可能会有些同学会疑问，为什么要用重定向绑定，而不是像 <code>&gt;file 2&gt;file</code> 这样子重复一遍呢。</p><p>为了回答这个问题，我们回到刚才介绍输出重定向的场景。我们尝试将标准输出和错误输出都定向到out文件中：</p><pre><code class="sh">[huxiaofan@huxiaofan-centos8 learn]$ ls 1.txt 2.txt &gt;out 2&gt;out[huxiaofan@huxiaofan-centos8 learn]$ cat outa.txt�法访问b.txt: 没有那个文件或目录</code></pre><p>WTF？竟然出现了乱码，这是为啥呢？这是因为 <strong>采用这种写法，标准输出和错误输出会抢占往 out 文件的管道</strong>，所以可能会导致输出内容的时候出现缺失、覆盖等情况。现在是出现了乱码，有时候也有可能出现只有 error 信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。</p><p>而且，由于 out 文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体 IO 效率不如 &gt;file 2&gt;&amp;1 来得高。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>首先 <code>&gt; file 2&gt;file</code> 的意思是将命令所产生的标准输出信息，和错误的输出信息送到file 中。<code>&gt; file 2&gt;file</code> 这样的写法，stdout 和 stderr都直接送到 file 中，file 会被打开两次,这样 stdout 和 stderr 会互相覆盖，这样写相当使用了 FD1 和 FD2 两个同时去抢占file 的管道。</p><p>而 <code>&gt;file 2&gt;&amp;1</code> 这条命令就将 stdout 直接送向 file, <strong>stderr 继承了 FD1 管道后</strong>，再被送往 file。此时，file 只被打开了一次，也只使用了一个管道 FD1，它包括了 stdout 和 stderr 的内容。</p><p>从 IO 效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写 shell 脚本的时候,较多的时候我们会 <code>command &gt; file 2&gt;&amp;1</code> 这样的写法。</p><h4 id="为何-2-gt-amp-1-要写在后面？"><a href="#为何-2-gt-amp-1-要写在后面？" class="headerlink" title="为何 2&gt;&amp;1 要写在后面？"></a>为何 <code>2&gt;&amp;1</code> 要写在后面？</h4><pre><code class="sh">command &gt; file 2&gt;&amp;1 </code></pre><p>首先是 <code>command &gt; file</code> 将标准输出重定向到file中， <code>2&gt;&amp;1</code> 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。</p><pre><code class="sh">command 2&gt;&amp;1 &gt;file </code></pre><p><code>2&gt;&amp;1</code> 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。<code>&gt;file</code> 后输出才被重定向到file，但标准错误仍然保持在终端。</p><p>用strace可以看到：</p><ol><li><code>command &gt; file 2&gt;&amp;1</code> 这个命令中实现重定向的关键系统调用序列是：<pre><code class="sh">open(file) == 3 dup2(3,1) dup2(1,2)</code></pre></li><li><code>command 2&gt;&amp;1 &gt;file</code> 这个命令中实现重定向的关键系统调用序列是：<pre><code class="sh">dup2(1,2) open(file) == 3 dup2(3,1)</code></pre>可以考虑一下不同的 <code>dup2()</code> 调用序列会产生怎样的文件共享结构。请参考APUE 3.10, 3.12</li></ol><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>接着本文的场景，下面命令，错误输出会输出到什么地方呢？同学们可以在评论区留言回答哦~</p><pre><code class="sh"># ls a.txt b.txt 2&gt;&amp;1 &gt;/dev/null 2&gt;&amp;1</code></pre><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h3><blockquote><p><code>/dev/null</code> 是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null这个设备通常也被成为位桶（bit bucket）或黑洞。</p><p>《linux shell脚本攻略》<br>简单地理解就是，重定向操作给这个 <code>/dev/null</code> 文件的所有东西都会被丢弃。</p></blockquote><p>因为这些文件描述符输出的字符串，总是会显示出来的。如果我们在 shell 编程的时候，操作到某一条命令的返回结果，我们不想要这个时候又不想让这个输出结果打印到屏幕上（打印错误，多不好看对不对 ^_^）我们就可以重定向到 <code>/dev/null</code> 这个文件来，由 <code>/dev/null</code> 这个文件负责处理后事。这个丢弃的结果又不能粗暴的认为是删除错误输出，这个操作是一个丢弃重定向输入输出的操作。</p><p>形象地理解就是，ATM 机打印的纸质流水账单（stdout和stderr）本来应该你来保存处理的，但是你又没有用放在手里（打印屏幕）又碍事，所以账单从你的手里重新被丢到了垃圾桶（<code>/dev/null</code>）了。但是，垃圾桶的垃圾是怎么处理的你是不知道的。</p><p>不知道上面的描述，答主是不是能明白这三个知识点了？只要理解了上面的三个点，其实答主的第三个问题很好滴能解决了。</p><p>让一个变量获得命令输出的结果，是下面这样的处理：</p><pre><code class="sh">i=$(ls 123.txt)</code></pre><p>这样，<code>i</code> 就能获得命令 <code>ls 123.txt</code> 输出的标准输出。错误提示（标准错误）依然会打印到屏幕上显示。</p><pre><code class="sh">i=$(ls 123.txt 2&gt; /dev/null)</code></pre><p>这样的命令，<code>ls</code> 命令如果出现了错误提示，就会被重定向到 <code>/dev/null</code> 垃圾桶去了。所以，屏幕上不会打印任何输出关于错误的提示字符。在这个命令的操作中，<code>i</code> 获得文件 stdout 标准输出，也就是文件述符1的屏幕输出结果” <code>123.txt</code> “。</p><p>如果，这个 <code>123.txt</code> 文件不存在，<code>i</code> 就肯定什么都拿不到，因为错误提示被 <code>/dev/null</code> 吃了（划掉），被重定向丢弃了屏幕也不显示错误提示。所以，<code>i</code> 就是个什么都没有的空变量。基本就是如下效果一样：</p><pre><code class="sh">i=&#39;&#39;</code></pre><h4 id="存在的意义："><a href="#存在的意义：" class="headerlink" title="存在的意义："></a><strong>存在的意义：</strong></h4><p><code>/dev/null&gt; file</code> 的意义在与 要输出到的文件不会被删除就可以进行清空。如果你通过删除后在新建一个文件的方式来清空的话，可能由于权限的原因不能被删除获取新建。还有可能在你刚删除文件后，另外一个程序就需要读取这个文件，这时就会出现错误。</p><h2 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h2><p><a href="http://www.tldp.org/LDP/abs/html/io-redirection.html" target="_blank" rel="noopener">Chapter 20. I/O Redirection</a></p><pre><code class="sh">n&lt;&amp;-Close input file descriptor n.0&lt;&amp;-, &lt;&amp;-Close stdin.n&gt;&amp;-Close output file descriptor n.1&gt;&amp;-, &gt;&amp;-Close stdout.</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了linux重定向的原理以及一些基本命令，并且详细地分析了 <code>&gt;/dev/null 2&gt;&amp;1</code> 这个命令以及一些注意点。</p><p>总而言之，平时用到最多的就是 <code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code> 命令</p><blockquote><p>此处保留原作者参考文献：</p><ul><li><a href="https://www.cnblogs.com/tinywan/p/6025468.html" target="_blank" rel="noopener">Shell脚本-/dev/null 2&gt;&amp;1详解</a></li><li><a href="http://blog.jobbole.com/109355/" target="_blank" rel="noopener">shell 中的&gt;/dev/null 2&gt;&amp;1 是什么鬼？</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html" target="_blank" rel="noopener">linux重定向总结</a></li><li><a href="https://blog.csdn.net/reyleon/article/details/11595985" target="_blank" rel="noopener">&gt;/dev/null 2&gt;&amp;1 和 2&gt;&amp;1 &gt;/dev/null的区别</a></li><li><a href="https://www.zhihu.com/question/53295083" target="_blank" rel="noopener">shell程序中 2&gt; /dev/null 代表什么意思？</a></li><li><a href="https://blog.csdn.net/ithomer/article/details/9288353" target="_blank" rel="noopener">Linux Shell 1&gt;/dev/null 2&gt;&amp;1 含义</a></li><li><a href="https://askubuntu.com/questions/514748/what-does-dev-null-mean-in-a-shell-script" target="_blank" rel="noopener">What does /dev/null mean in a shell script?</a></li><li><a href="http://www.tldp.org/LDP/abs/html/io-redirection.html" target="_blank" rel="noopener">Chapter 20. I/O Redirection</a></li></ul></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Hadoop 伪分布式搭建 Hbase</title>
      <link href="/2020/10/%E5%9F%BA%E4%BA%8E-Hadoop-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-Hbase/"/>
      <url>/2020/10/%E5%9F%BA%E4%BA%8E-Hadoop-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-Hbase/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>上面我们已经完成了在Hyper-V中运行Ubuntu以及安装Hadoop，可以看我前面两篇文章：</p><ul><li><p><a href="https://coding.emptinessboy.com/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8A%EF%BC%89/">Hyper-V中运行Ubuntu</a></p></li><li><p><a href="https://coding.emptinessboy.com/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8B%EF%BC%89/">安装Hadoop并配置伪分布式</a></p></li></ul><p>现在在之前步骤的基础上，继续安装一波 Hbase 数据库</p><h2 id="下载解压-Hbase"><a href="#下载解压-Hbase" class="headerlink" title="下载解压 Hbase"></a>下载解压 Hbase</h2><h3 id="下载二进制文件"><a href="#下载二进制文件" class="headerlink" title="下载二进制文件"></a>下载二进制文件</h3><p>这里要根据大家之前安装的 Hadoop 来挑选对应的 Hbase 版本。具体的版本之间的对应关系，可以看下面的 Apache 官方文档：</p><ul><li><a href="https://hbase.apache.org/book.html#java" target="_blank" rel="noopener">https://hbase.apache.org/book.html#java</a></li></ul><p><a href="https://up.media.everdo.cn/image/R60l" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/hadoop-hbase-version.png" alt="hadoop-hbase-version.png"></a></p><p>由于我安装的是 Hadoop3.3 版本，所以要安装 Hbase 2.3.x 版本，和之前的 Hadoop 一样，我们可以从镜像站下载：</p><ul><li><a href="https://www.apache.org/dyn/closer.lua/hbase/2.3.2/hbase-2.3.2-bin.tar.gz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.lua/hbase/2.3.2/hbase-2.3.2-bin.tar.gz</a></li></ul><p><a href="https://up.media.everdo.cn/image/RWdd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/2020-10-12-192029.png" alt="2020-10-12-192029.png"></a></p><p>在终端直接运行命令：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local$ sudo wget https://downloads.apache.org/hbase/2.3.2/hbase-2.3.2-bin.tar.gz</code></pre><p><a href="https://up.media.everdo.cn/image/RN80" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-093431.png" alt="-2020-10-12-093431.png"></a></p><p>接下来只需要一步解压，Hbase 就可以像 Hadoop 一样开箱即用了。</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local$ sudo tar -zxf hbase-2.3.2-bin.tar.gzhadoop@huxiaofan-ubuntu:/usr/local$ sudo mv hbase-2.3.2 hbase</code></pre><p>经过这一步操作，Hbase 已经被安装到了 /usr/local/hbase 下面了。</p><p><a href="https://up.media.everdo.cn/image/Rm3D" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-192244.png" alt="-2020-10-12-192244.png"></a></p><p>但此时需要注意的是，由于是使用 sudo 来进行解压的，所以解压得到的文件所有者并不是 hadoop 用户，会为我们后面的运行带来一定的问题。所以现在还需要修改下整个 hbase 目录的权限。</p><blockquote><p>修改前的权限情况</p></blockquote><p><a href="https://up.media.everdo.cn/image/R99L" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-193757.png" alt="-2020-10-12-193757.png"></a></p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local$ sudo chown -R hadoop:hadoop hbase</code></pre><blockquote><p>修修改用户和用户组后</p></blockquote><p><a href="https://up.media.everdo.cn/image/REUc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-193812.png" alt="-2020-10-12-193812.png"></a></p><h2 id="进一步的安装配置"><a href="#进一步的安装配置" class="headerlink" title="进一步的安装配置"></a>进一步的安装配置</h2><h3 id="配置-path-变量（可选）"><a href="#配置-path-变量（可选）" class="headerlink" title="配置 path 变量（可选）"></a>配置 path 变量（可选）</h3><p>PATH 环境变量用来指定命令的搜索路径。如果待运行的程序不在当前目录，操作系统便可以去依次搜索PATH变量变量中记录的目录，如果在这些目录中找到待运行的程序，操作系统便可以运行。</p><blockquote><p><strong>声明方法：</strong></p><p>PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;: …… :&lt; PATH n &gt;<br>export PATH</p></blockquote><p>可以自己在 <code>&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;</code> 加上指定的路径，中间用冒号隔开。</p><p>可以利用 <code>echo $PATH</code> 查看当前当前系统PATH路径</p><p>现在我们修改 path 使之全局生效。这里我们不仅配置 Hbase 的环境变量，也同时配置 Hadoop 的变量。而我们要做的很简单，只需要将 sbin 或者 bin 这些二进制文件的路径添加到 path 里即可。</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local$ sudo vim  /etc/profile</code></pre><p>在下面追加如下内容，（已有的不要重复追加）：</p><pre><code class="bash"># JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# HADOOP BINexport PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin:/usr/local/hbase/bin</code></pre><p>运行命令 <code>source /etc/profile</code> 来让我们新配置的变量立刻生效：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local$ source /etc/profile</code></pre><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>配置完成 path 变量后，我们就可以在系统的任意目录下运行 hadoop 和 hbase 的 bin 下面的脚本和程序了：</p><p>这里我们使用 hadoop version 来测试下</p><p><a href="https://up.media.everdo.cn/image/RfB2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-194027.png" alt="-2020-10-12-194027.png"></a></p><h3 id="配置-hbase-env-sh"><a href="#配置-hbase-env-sh" class="headerlink" title="配置 hbase-env.sh"></a>配置 hbase-env.sh</h3><p>我们需要将必要的环境变量重新写入一份到 hbase-env.sh，并且需要额外做两项 zookeeper 和 hbase classpath 的配置。</p><p>下面使用 vim 编辑器打开文件：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ vim /usr/local/hbase/conf/hbase-env.sh</code></pre><p>追加如下内容：</p><pre><code class="bash"># JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# HBASE_CLASSPATHexport HBASE_CLASSPATH=/usr/local/hadoop/conf# HBASE_MANAGES_ZKexport HBASE_MANAGES_ZK=true</code></pre><p>其中 HBASE_CLASSPATH 用来指定 hbase 的配置文件目录。 HBASE_MANAGES_ZK=true 表示使用 hbase 自带的 zookeeper，不使用自己搭建的独立 zookeeper。</p><p><a href="https://up.media.everdo.cn/image/RsxZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-195104.png" alt="-2020-10-12-195104.png"></a></p><h3 id="配置-hbase-site-xml"><a href="#配置-hbase-site-xml" class="headerlink" title="配置 hbase-site.xml"></a>配置 hbase-site.xml</h3><p>hbase-site.xml 位于 /usr/local/hadoop/conf 也就是 Hbase 默认的配置文件保存目录下。<strong>这里我们直接配置伪分布式模式。</strong></p><p><strong>初始内容：</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;  &lt;property&gt;    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.tmp.dir&lt;/name&gt;    &lt;value&gt;./tmp&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>这里使用 vim 命令直接编辑：</p><p><a href="https://up.media.everdo.cn/image/RzCk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-200520.png" alt="-2020-10-12-200520.png"></a></p><p><strong>完整配置：</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;  &lt;property&gt;    &lt;name&gt;hbase.rootdir&lt;/name&gt;    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;    &lt;!-- 用于指定 Hbase 的数据存储位置 --&gt;    &lt;!-- 由于在伪分布式模式下，我们使用 Hadoop 的 HDFS 来存储 Hbase 的数据 --&gt;    &lt;!-- 所以这一步的 hbase.rootdir 设置为 Hbase 在 HDFS 的存储路径--&gt;    &lt;!-- 如果是单机 模式，就直接使用 file://路径 来指定文件位置--&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;    &lt;!-- 由于采用了伪分布式模式，需要使用到自带的 zookeeper --&gt;    &lt;!-- 所以这一项要设置为 true --&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.tmp.dir&lt;/name&gt;    &lt;value&gt;./tmp&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;</code></pre><h2 id="运行和排错"><a href="#运行和排错" class="headerlink" title="运行和排错"></a>运行和排错</h2><p>到这里，按照教科书的说明，可以直接运行命令启动 Hadoop 和 Hbase 了。因为 Hbase 的文件存储依赖 Hadoop 的 HDFS，所以我们需要先启动 Hadoop 再启动 Hbase。</p><p><strong>运行命令：</strong></p><p>由于前面我们配置 path 变量的时候已经添加了 Hadoop 和 Hbase，所以现在可以直接运行启动脚本。</p><pre><code class="bash"># 启动命令start-all.shstart-hbase.sh</code></pre><p>使用 JPS 命令查看当前的 Java 进程运行状态：</p><p><a href="https://up.media.everdo.cn/image/R1JB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-201044.png" alt="-2020-10-12-201044.png"></a></p><p>出现下列的进程，可以看到进程已经全部启动。</p><pre><code>应该出现的进程列表：JpsHmasterHQuorumPeerNameNodeHregionServerSecondaryNameNodeDataNode</code></pre><h3 id="排错-multiple-SLF4J-bindings"><a href="#排错-multiple-SLF4J-bindings" class="headerlink" title="排错 multiple SLF4J bindings"></a>排错 multiple SLF4J bindings</h3><p>但是我们可以看到系统存在警告：</p><pre><code>SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/hbase/lib/client-facing-thirdparty/slf4j-log4j12-1.7.30.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.……SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]127.0.0.1: running zookeeper, logging to /usr/local/hbase/bin/../logs/hbase-hadoop-zookeeper-huxiaofan-ubuntu.outrunning master, logging to /usr/local/hbase/bin/../logs/hbase-hadoop-master-huxiaofan-ubuntu.out</code></pre><blockquote><p>出现这个错误的原因，是 Hadoop 中的 jar 包和 HBase 中的包版本不一致，就会出现对应的 warnning 信息</p></blockquote><p>网上广为流传的方法是删除冲突 jar 包中的其中的一个来解决问题。但是在我的数次试验后，发现如果照这样操作，不论是删 Hadoop 里的 jar 包，还是删除 Hbase 里的包，都会出现启动时报错，找不到 java 类的 error。</p><p>本来只是一个 warring，删除后直接变成 Error。说明网上的这个方法肯定是行不通的。</p><p>最后几经努力，<strong>找到了正确的解决方案：只要在 hbase-env.sh 中加一行配置就行。</strong></p><pre><code class="bash">export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=&quot;true&quot;</code></pre><p>事实上这句话本来就在配置文件中存在，只要取消注释就行。这句话的作用就是禁止 Hbase 查找 Hadoop 的 Classs。</p><p><a href="https://up.media.everdo.cn/image/RMdt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-205501.png" alt="-2020-10-12-205501.png"></a></p><p>完成这波配置后，再次启动 Hbase：</p><p><a href="https://up.media.everdo.cn/image/Rv1x" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-210832.png" alt="-2020-10-12-210832.png"></a></p><p>可以看到刚才看到的长长一堆的报错都消失了。</p><h3 id="排错-NoNode-for-hbase-master"><a href="#排错-NoNode-for-hbase-master" class="headerlink" title="排错 NoNode for /hbase/master"></a>排错 NoNode for /hbase/master</h3><p>本来想着大功告成，可以进入 Hbase 的 shell 来操作数据库了。可现实又给了我当头一棒。我还是太年轻了，虽然 Hbase 启动成功了，但是一旦进入 Hbase Shell，输入 status 就又会再次报错。</p><pre><code class="bash">hbase(main):001:0&gt; statusERROR: KeeperErrorCode = NoNode for /hbase/masterFor usage try &#39;help &quot;status&quot;&#39;Took 0.0899 seconds</code></pre><p>出现这个问题的原因是，我之前在保存 hbase-site.xml 配置文件的时候，对存储路径的部分进行了修改：</p><pre><code class="xml">&lt;name&gt;hbase.rootdir&lt;/name&gt;&lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;我之前这一行填写的是 hdfs://127.0.0.1:9000/hbase后面改成了 localhost 造成了这个问题</code></pre><p>问题的根本原因是修改了 hdfs 的路径，导致了文件的不完整，hadoop 上文件与本地文件不一致。</p><blockquote><p>解决方法参考了这篇文章 <a href="https://blog.csdn.net/haiyan09/article/details/99863987" target="_blank" rel="noopener">https://blog.csdn.net/haiyan09/article/details/99863987</a></p></blockquote><ol><li>关闭所有进程（hadoop 和 hbase）</li><li>启动 hadoop（因为需要操作 hdfs）</li><li>删除 /hbase 文件</li></ol><p>这里我直接简单粗暴的把 jps 里面列出来的进程都 kill 掉了。然后直接启动 hadoop：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ start-all.shWARNING: Attempting to start all Apache Hadoop daemons as hadoop in 10 seconds.WARNING: This is not a recommended production deployment configuration.WARNING: Use CTRL-C to abort.Starting namenodes on [localhost]Starting datanodesStarting secondary namenodes [huxiaofan-ubuntu]Starting resourcemanagerStarting nodemanagers</code></pre><p>查看hadoop 根目录：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ hadoop fs -ls /Found 1 itemsdrwxr-xr-x   - hadoop supergroup          0 2020-10-12 21:18 /hbase</code></pre><p>退出安全模式：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ hdfs dfsadmin -safemode leaveSafe mode is OFF</code></pre><p>删除 /hbase 文件：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ hadoop fs -rm -r  /hbase  Deleted /hbasehadoop@huxiaofan-ubuntu:~$ hadoop fs -ls /</code></pre><p>启动 Hbase：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ start-hbase.sh</code></pre><p><a href="https://up.media.everdo.cn/image/RyaI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-212918.png" alt="-2020-10-12-212918.png"></a></p><p><strong>现在我们进入 Hbase Shell 然后运行 status 来看看现在还会不会报刚才的错误：</strong></p><p><a href="https://up.media.everdo.cn/image/RX3X" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-212826.png" alt="-2020-10-12-212826.png"></a></p><p>可以看到现在已经可以正常显示状态了。</p><h3 id="排错-Unable-to-load-native-hadoop-library"><a href="#排错-Unable-to-load-native-hadoop-library" class="headerlink" title="排错 Unable to load native-hadoop library"></a>排错 Unable to load native-hadoop library</h3><p>我们可以看到，刚才在启动 Hbase Shell 的时候，系统还有一条警告：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ hbase shell2020-10-12 21:18:43,234 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platforble</code></pre><p><a href="https://up.media.everdo.cn/image/RCEi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-211452.png" alt="-2020-10-12-211452.png"></a></p><p>当然这条警告是不影响 Hbase 运行的。也可以完全忽视掉它。当然眼不见心不烦，我选择手动修复这一条警告，<strong>而且这个库文件有助于提高 Hbase 的运行速度：</strong></p><blockquote><p>这个问题，官方已经给出了解决方案：</p><p><a href="http://hbase.apache.org/book.html#hadoop.native.lib" target="_blank" rel="noopener">http://hbase.apache.org/book.html#hadoop.native.lib</a></p></blockquote><p>使用命令测试：<code>hadoop checknative -a</code> 后发现，我的 hadoop 其实是已经包含了Hadoop Native Libraries 的。跳出警告的原因就是 Hbase 没有识别到这个库。</p><p><strong>要做的很简单：</strong></p><p>我们只需要把库文件的地址加入到 hbase-env.sh 就可以了。</p><pre><code class="bash"># 在 hbase-env.sh 中追加下面内容# LIBexport LD_LIBRARY_PATH=/usr/local/hadoop/lib/native:$LD_LIBRARY_PATH</code></pre><p>使用 vim 进行编辑：</p><p><a href="https://up.media.everdo.cn/image/RSZ4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-220237.png" alt="-2020-10-12-220237.png"></a></p><p><em>注，如果你的 Hadoop 没法加载本地库，则需要把下面的内容追加到 /etc/profile 或者 /usr/local/hadoop/etc/hadoop/hadoop-env.sh 中：</em></p><pre><code class="bash">export  HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport  HADOOP_HOME=/usr/local/hadoopexport  HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;</code></pre><p>保存后，重新启动 Hbase，进入 Hbase Shell 的时候，就不会跳出上面那样的警告啦。</p><p><a href="https://up.media.everdo.cn/image/RtBM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-220456.png" alt="-2020-10-12-220456.png"></a></p><h3 id="Tips：启动和关闭脚本"><a href="#Tips：启动和关闭脚本" class="headerlink" title="Tips：启动和关闭脚本"></a>Tips：启动和关闭脚本</h3><p>配置完成环境变量后我们可以使用 shart-dfs.sh 来启动 hadoop。使用 stop-dfs.sh 或者 stop-all.sh 来关闭 hadoop。</p><p>但是对于 hbase 来说，启动和关闭 hbase 需要单独的命令：</p><pre><code class="bash"># 启动 hbasestart-hbase.sh# 停止 hbasestop-hbase.sh</code></pre><p>使用 hadoop 的 stop-all.sh，虽然从名字上来看可以用来停止所有 hadoop 相关的服务。但事实上没法停止 hbase。如下图：</p><p><a href="https://up.media.everdo.cn/image/RtBM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-220456.png" alt="-2020-10-12-220456.png"></a></p><h4 id="stop-all-sh-卡住"><a href="#stop-all-sh-卡住" class="headerlink" title="stop-all.sh 卡住"></a>stop-all.sh 卡住</h4><p>对于这种情况，我们可以运行 <code>hbase-daemon.sh stop master</code> 先停止 master 节点服务。再运行 stop-all.sh</p><h2 id="开启-Hbase-的网页控制面板"><a href="#开启-Hbase-的网页控制面板" class="headerlink" title="开启 Hbase 的网页控制面板"></a>开启 Hbase 的网页控制面板</h2><blockquote><p>关于开启 hadoop WEB 信息界面的，可以查看我的上一篇文章</p></blockquote><p>与 hadoop 不同， hbase的master web 默认是不运行的，所以需要自己配置默认端口。 所需要做的只要在 hbase-site.xml 中加入以下内容即可：</p><pre><code class="xml">  &lt;property&gt;      &lt;name&gt;hbase.master.info.port&lt;/name&gt;      &lt;value&gt;16010&lt;/value&gt;      &lt;!-- WEB 管理界面端口 --&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.regionserver.info.port&lt;/name&gt;    &lt;value&gt;16030&lt;/value&gt;    &lt;!-- 节点信息查看端口 --&gt;  &lt;/property&gt;</code></pre><p>以上配置文件的端口号都可以自定义。</p><p><a href="https://up.media.everdo.cn/image/ROCa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/-2020-10-12-222508.png" alt="-2020-10-12-222508.png"></a></p><p>下面只需要在防火墙放行端口就可以通过宿主机的浏览器进行访问啦！</p><pre><code class="bash">iptables -I INPUT -p tcp --dport 16010 -j ACCEPTiptables -I INPUT -p tcp --dport 16030 -j ACCEPTservice iptables restart</code></pre><p>重启相关服务后，应该可以看到和我一样的界面：</p><p><a href="https://up.media.everdo.cn/image/RZJs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/hbase-web.png" alt="hbase-web.png"></a></p><p><a href="https://up.media.everdo.cn/image/R5e3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/13/hbase-web-console.png" alt="hbase-web-console.png"></a></p><h2 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h2><h3 id="hbase-env-sh"><a href="#hbase-env-sh" class="headerlink" title="hbase-env.sh"></a>hbase-env.sh</h3><pre><code class="bash">export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=&quot;true&quot;# Override text processing tools for use by these launch scripts.# export GREP=&quot;${GREP-grep}&quot;# export SED=&quot;${SED-sed}&quot;# JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# HBASE_CLASSPATHexport HBASE_CLASSPATH=/usr/local/hadoop/conf# HBASE_MANAGES_ZKexport HBASE_MANAGES_ZK=true# LIBexport LD_LIBRARY_PATH=/usr/local/hadoop/lib/native:$LD_LIBRARY_PATH</code></pre><h3 id="hbase-site-xml"><a href="#hbase-site-xml" class="headerlink" title="hbase-site.xml"></a>hbase-site.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;  &lt;property&gt;    &lt;name&gt;hbase.rootdir&lt;/name&gt;    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;      &lt;name&gt;hbase.master.info.port&lt;/name&gt;      &lt;value&gt;16010&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.regionserver.info.port&lt;/name&gt;    &lt;value&gt;16030&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/local/hbase/tmp&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hyper-V中运行Ubuntu以及安装Hadoop（下）</title>
      <link href="/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h1 id="安装并运行-Hadoop"><a href="#安装并运行-Hadoop" class="headerlink" title="安装并运行 Hadoop"></a>安装并运行 Hadoop</h1><p>继上一篇，我们已经完成了在 Hyper-V 下的 Ubuntu 部署，接下来就可以准备安装 Hadoop 啦。为了防止出错以及意外导致之前的数据丢失，我在本次操作前特地为虚拟机创建了一个还原点，使用其他虚拟机软件的宝贝们可以点击里面的创建快照选项。其原理不同，但起到的效果是差不多的。</p><h2 id="创建-hadoop-用户，并配置免密登录"><a href="#创建-hadoop-用户，并配置免密登录" class="headerlink" title="创建 hadoop 用户，并配置免密登录"></a>创建 hadoop 用户，并配置免密登录</h2><p>使用 useradd 命令添加一个名为 hadoop 的用户以方便我们的后续操作。这里先使用有密码的用户来测试。</p><pre><code class="bash">useradd hadoop</code></pre><p><a href="https://up.media.everdo.cn/image/Bgqk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/09/-2020-10-09-145530.png" alt="-2020-10-09-145530.png"></a></p><p>测试密码可以正常登录后，我们生成 ssh_key 使用密钥来进行登录。</p><h3 id="加入-sudoers"><a href="#加入-sudoers" class="headerlink" title="加入 sudoers"></a>加入 sudoers</h3><p>为了方便操作，我们赋予 hadoop 用户 sudo 权限。</p><p><strong>第一步：</strong>修改/etc/sudoers文件权限为读写权限 <code>chmod +x /etc/sudoers</code></p><p><strong>第二步：</strong>修改/etc/sudoers文件内容，执行 <code>visudo 或者 vim /etc/sudoers</code></p><p><a href="https://up.media.everdo.cn/image/RHbx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/09/-2020-10-09-182208.png" alt="-2020-10-09-182208.png"></a></p><p>在文件中加入下列代码：</p><pre><code>hadoop  ALL=(ALL)   NOPASSWD:ALL</code></pre><p>这时，当我们使用 hadoop 用户登录服务器的时候，执行 sudo 命令，就不需要在输入 root 密码了！</p><h3 id="生成-ssh-私钥"><a href="#生成-ssh-私钥" class="headerlink" title="生成 ssh 私钥"></a>生成 ssh 私钥</h3><pre><code class="bash"># 这一步是生成RSA私钥$ cd .ssh$ ssh-keygen -t ras</code></pre><p><a href="https://up.media.everdo.cn/image/BlXB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/09/-2020-10-09-150048.png" alt="-2020-10-09-150048.png"></a></p><h3 id="生成公钥并保存"><a href="#生成公钥并保存" class="headerlink" title="生成公钥并保存"></a>生成公钥并保存</h3><blockquote><p>authorized_keys 是linux 操作系统下，专门用来存放公钥的地方，只要公钥放到了服务器的正确位置，并且拥有正确的权限，你才可以通过你的私钥，免密登录linux服务器</p></blockquote><p>这一步执行生成公钥的命令</p><pre><code class="bash">$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys</code></pre><p><a href="https://up.media.everdo.cn/image/R44t" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/09/-2020-10-09-150228.png" alt="-2020-10-09-150228.png"></a></p><p>到这一步，Hadoop 用户登陆时执行 <code>ssh localhost</code> 已经不需要输入密码了。</p><h2 id="安装-openJDK-8"><a href="#安装-openJDK-8" class="headerlink" title="安装 openJDK 8"></a>安装 openJDK 8</h2><blockquote><p>Hadoop 是基于 Java 语言开发的，所以需要安装 JDK 环境，首先需要根据官方的说明安装适合 Hadoop 使用的 JDK。</p></blockquote><p>官网对于 JDK 版本的说明：<a href="https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions</a></p><p><a href="https://up.media.everdo.cn/image/RJ0I" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-10-092045.png" alt="-2020-10-10-092045.png"></a></p><p>可以看到 Hadoop 2.x 的版本是使用 java7 开发的，但可以运行在 java7 和 java8 上，而 hadoop 3.x 是使用 Java8 开发的，可以运行在 Java8 和 Java11 上，但若要编译，只能使用 Java8</p><p><strong><em>所以，安装 jdk8 是最稳妥的方案啦！</em></strong></p><pre><code class="bash"># apt-get install openjdk-8-jdk openjdk-8-jre</code></pre><p><a href="https://up.media.everdo.cn/image/RhFi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/2020-10-09-152706-1.png" alt="2020-10-09-152706-1.png"></a></p><h3 id="配置-JAVA-HOME-环境变量"><a href="#配置-JAVA-HOME-环境变量" class="headerlink" title="配置 JAVA_HOME 环境变量"></a>配置 JAVA_HOME 环境变量</h3><p>到此为止 apt 包管理器已经帮我们一键安装 java8 了。但是想要运行 hadoop 的话，还需要配置 $JAVA_HOME 环境变量。</p><blockquote><p>dpkg -l 命令会列出系统中所有已安装的软件包信息。结合grep，可以过滤出自己想要的内容。</p></blockquote><pre><code class="bash"># 先找到java8的安装路径root@huxiaofan-ubuntu:~# dpkg -L openjdk-8-jdk | grep &#39;bin&#39;/usr/lib/jvm/java-8-openjdk-amd64/bin/usr/lib/jvm/java-8-openjdk-amd64/bin/appletviewer/usr/lib/jvm/java-8-openjdk-amd64/bin/jconsoleroot@huxiaofan-ubuntu:~# /usr/lib/jvm/java-8-openjdk-amd64/bin/java -versionopenjdk version &quot;1.8.0_265&quot;OpenJDK Runtime Environment (build 1.8.0_265-8u265-b01-0ubuntu2~20.04-b01)OpenJDK 64-Bit Server VM (build 25.265-b01, mixed mode)</code></pre><p>这一步可以看到在我虚拟机上 Java8 的 bin 路径在 <code>/usr/lib/jvm/java-8-openjdk-amd64/bin</code></p><p><a href="https://up.media.everdo.cn/image/Rn94" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-153615.png" alt="-2020-10-09-153615.png"></a></p><h4 id="配置环境变量我们有三种方法："><a href="#配置环境变量我们有三种方法：" class="headerlink" title="配置环境变量我们有三种方法："></a><strong>配置环境变量我们有三种方法：</strong></h4><p><strong><em>方法一：export PATH</em></strong></p><pre><code class="bash">root@huxiaofan-ubuntu:~# export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/root@huxiaofan-ubuntu:~# echo $JAVA_HOME/usr/lib/jvm/java-8-openjdk-amd64/</code></pre><p>由于这是一种临时的变量导入方法，重启就失效，所以这里不采取这种方式。</p><p><strong><em>方法二：修改 .bashrc 或 .bash_profile</em></strong></p><p>通过修改用户目录下的~/.bashrc文件进行配置：</p><pre><code class="bash">hadoop@huxiaofan-ubuntu:~$ vim .bash_profile# 然后在后面追加一行# export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/hadoop@huxiaofan-ubuntu:~$ source .bash_profile hadoop@huxiaofan-ubuntu:~$ echo $JAVA_HOME/usr/lib/jvm/java-8-openjdk-amd64/</code></pre><p>这种方法永久有效且仅对当前用户有效。</p><p><strong><em>方法三：修改 /etc/profile</em></strong></p><p>这种方法永久有效，且对所有用户有效，这里我最终采用的是这个方式</p><pre><code class="bash">vim  /etc/profile</code></pre><p><a href="https://up.media.everdo.cn/image/R7OM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-162242.png" alt="-2020-10-09-162242.png"></a></p><p>保存后重启虚拟机，然后输入命令 <code>export</code> 来查看现有的环境变量：</p><p><a href="https://up.media.everdo.cn/image/RR7Y" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-162505.png" alt="-2020-10-09-162505.png"></a></p><p>这里已经可以看到 JAVA_HOME 了。而且重启和更换用户登录都会有效。至此，Hadoop 运行所需的 Java 环境已经搭建完成。</p><h2 id="下载安装-Hadoop"><a href="#下载安装-Hadoop" class="headerlink" title="下载安装 Hadoop"></a>下载安装 Hadoop</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>由于直接下载原始仓库较慢，在 Hadoop 官网，可以看到有三个国内的镜像站可以为我们提供快速的下载。分别是北京外国语大学，清华大学和北京理工的镜像站。</p><p><a href="https://up.media.everdo.cn/image/Rjqa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-10-131714.png" alt="-2020-10-10-131714.png"></a></p><p>因为 Hadoop 是开箱即用的，我们只要从中下载 hadoop 的压缩包，在有 Java 运行环境的平台上就可以直接运行了。</p><p>我使用了 wget 工具进行安装包的下载。如果没有 wget，可以使用 <code>apt-get install wget -y</code> 先安装 wget</p><pre><code class="bash"># 我下载的是3.3.0版本$ wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</code></pre><p><a href="https://up.media.everdo.cn/image/RoXs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-160040.png" alt="-2020-10-09-160040.png"></a></p><h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><p>下载完成后，使用 tar 命令进行解压缩。并将解压得到的 hadoop3.3.0 文件夹移动到 Linux 默认的软件安装位置 /usr/local/ 目录下。</p><pre><code class="bash">$ tar -zxf hadoop-3.3.0.tar.gzroot@huxiaofan-ubuntu:/home/hadoop# mv hadoop-3.3.0 /usr/local/hadooproot@huxiaofan-ubuntu:/home/hadoop# ls /usr/localbin  etc  games  hadoop  include  lib  man  sbin  share  srcroot@huxiaofan-ubuntu:/home/hadoop# ls /usr/local -lah总用量 44Kdrwxr-xr-x 11 root   root   4.0K 十月    9 16:07 .drwxr-xr-x 14 root   root   4.0K 八月    1 00:28 ..drwxr-xr-x 10 hadoop hadoop 4.0K 七月    7 03:50 hadoop</code></pre><p><a href="https://up.media.everdo.cn/image/RFH3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-160802.png" alt="-2020-10-09-160802.png"></a></p><p>到这里，单机模式的 hadoop 已经可以开箱即用啦！</p><p>我们运行下 hadoop version 查看下当前 hadoop 的版本信息：</p><p><a href="https://up.media.everdo.cn/image/R3bG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-162712.png" alt="-2020-10-09-162712.png"></a></p><h3 id="伪分布式模式配置"><a href="#伪分布式模式配置" class="headerlink" title="伪分布式模式配置"></a>伪分布式模式配置</h3><h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a><strong>准备工作：</strong></h4><p>因为在集群环境下，即使系统已经正确地配置了JAVA_HOME，也可能会出现找不到 JAVA_HOME 的错误，所以这里为防止出错，先在 hadoop-env.sh 中，再显示地重新声明一遍 JAVA_HOME</p><pre><code class="bash">cd /usr/local/hadoop/etc/hadoop/vim hadoop-env.shhadoop@huxiaofan-ubuntu:/usr/local/hadoop$ lsbin  include  libexec          licenses-binary  NOTICE-binary  README.txt  shareetc  lib      LICENSE-binary  LICENSE.txt      NOTICE.txt     sbinhadoop@huxiaofan-ubuntu:/usr/local/hadoop$ find . -name &quot;hadoop-env.sh&quot;./etc/hadoop/hadoop-env.shhadoop@huxiaofan-ubuntu:/usr/local/hadoop$ vim ./etc/hadoop/hadoop-env.sh</code></pre><p>在配置文件中加入 <code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/</code></p><p><a href="https://up.media.everdo.cn/image/RA09" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-163425.png" alt="-2020-10-09-163425.png"></a></p><h4 id="配置-core-site-xml"><a href="#配置-core-site-xml" class="headerlink" title="配置 core-site.xml"></a>配置 core-site.xml</h4><p>core-site.xml 位于 /usr/local/hadoop/etc/hadoop</p><p><strong>初始内容：</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;&lt;/configuration&gt;</code></pre><p>这里使用 vim 命令直接编辑：</p><p><a href="https://up.media.everdo.cn/image/RD8j" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-180837.png" alt="-2020-10-09-180837.png"></a></p><p><strong>完整配置：</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;!-- 用于保存临时文件 --&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;!-- 指定 HDFS 的访问地址 --&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="配置-hdfs-site-xml"><a href="#配置-hdfs-site-xml" class="headerlink" title="配置 hdfs-site.xml"></a>配置 hdfs-site.xml</h4><p>hdfs-site.xml 位于 /usr/local/hadoop/etc/hadoop</p><p><strong>初始内容：</strong></p><p>默认的初始内容和 core-site.xml 是一样的，默认为空白。这里使用 vim 命令直接编辑：</p><p><a href="https://up.media.everdo.cn/image/RYFO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-181724.png" alt="-2020-10-09-181724.png"></a></p><p><strong>完整配置：</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;!--指定HDFS副本数量--&gt;        &lt;!-- 伪分布式只有一个节点，所以只有一个副本 --&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;!-- 设定 DFS 名称节点的元数据保存目录 --&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;!-- 设定数据节点的数据保存目录 --&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><blockquote><p>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p></blockquote><h4 id="执行名称节点格式化"><a href="#执行名称节点格式化" class="headerlink" title="执行名称节点格式化"></a>执行名称节点格式化</h4><pre><code class="bash">cd /usr/local/hadoop/./bin/hdfs namenode -format </code></pre><p>成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。</p><p><a href="https://up.media.everdo.cn/image/Rb96" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-182439.png" alt="-2020-10-09-182439.png"></a></p><h2 id="试启动-Hadoop"><a href="#试启动-Hadoop" class="headerlink" title="试启动 Hadoop"></a>试启动 Hadoop</h2><p>Hadoop 的启动脚本位于 /usr/local/hadoop/sbin 下，启动只需要 ```bash /sbin/start-dfs.sh`` 即可</p><p>同理要停止 hadoop 的话，只需要执行 <code>bash /sbin/stop-dfs.sh</code> 或者 <code>bash /sbin/stop-all.sh</code></p><pre><code class="bash">hadoop@huxiaofan-ubuntu:/usr/local/hadoop$ bash /sbin/start-dfs.sh</code></pre><p>脚本执行完成后，可以输入命令 <code>jps</code> 来查看 DataNode，NameNode，SecondaryNameNode 有没有正常启动。</p><p><a href="https://up.media.everdo.cn/image/Ri7S" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-182724.png" alt="-2020-10-09-182724.png"></a></p><p>如图没有任何错误输出，说明启动成功。</p><h3 id="查看-HDFS-WEB-界面"><a href="#查看-HDFS-WEB-界面" class="headerlink" title="查看 HDFS WEB 界面"></a>查看 HDFS WEB 界面</h3><h4 id="hadoop3-3-之巨坑"><a href="#hadoop3-3-之巨坑" class="headerlink" title="hadoop3.3 之巨坑"></a>hadoop3.3 之巨坑</h4><p>在做完这一切后，按照教科书的说明，我尝试着用 curl 命令访问内网的 50070 端口</p><pre><code class="bash">root@huxiaofan-ubuntu:/home/hadoop# curl -v 127.0.0.1:50070* About to connect() to 127.0.0.1 port 50070 (#0)*   Trying 127.0.0.1...* Connection refused* Failed connect to 127.0.0.1:50070; Connection refused* Closing connection 0curl: (7) Failed connect to 127.0.0.1:50070; Connection refused</code></pre><p>使用 <code>lsof -i:50070</code> 查看端口监听情况，发现没有任何进程使用 50070 端口，可是此时 hadoop 应该已经启动了来着。</p><p>于是乎</p><p>一通百度。。</p><p>按照百度尝试编辑配置文件 hdfs-site.xml 增加这一段内容:</p><pre><code class="xml">&lt;property&gt;    &lt;name&gt;dfs.namenode.http.address&lt;/name&gt;    &lt;value&gt;0.0.0.0:50070&lt;/value&gt;&lt;/property&gt;</code></pre><p>结果没有任何作用。</p><p>直到我 Google 一下发现：</p><p><a href="https://up.media.everdo.cn/image/RQCJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/hadoopprot.png" alt="hadoopprot.png"></a></p><p><strong>原来是 Hadoop 3.x 版本把 NameNode 原先的50070端口 变成 9870了！！！</strong></p><p>赶紧在防火墙放行 9870</p><pre><code class="bash">iptables -I INPUT -p tcp --dport 9870 -j ACCEPTservice iptables restart</code></pre><p>现在，使用物理机的浏览器访问虚拟机的 IP 地址 <a href="http://192.168.137.100:9870" target="_blank" rel="noopener">http://192.168.137.100:9870</a> 果然看到 HDFS 的 web 界面了。</p><p><a href="https://up.media.everdo.cn/image/RrxQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/10/-2020-10-09-190839.png" alt="-2020-10-09-190839.png"></a></p><p>至此 Hadoop 学习的环境搭建完毕。</p><h2 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h2><h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h3><pre><code class="bash">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# HADOOPexport  HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport  HADOOP_HOME=/usr/local/hadoopexport  HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;</code></pre><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a>/etc/profile</h3><pre><code class="bash"># JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# HADOOP BINexport PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin:/usr/local/hbase/bin# HADOOPexport  HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport  HADOOP_HOME=/usr/local/hadoopexport  HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hyper-V中运行Ubuntu以及安装Hadoop（上）</title>
      <link href="/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2020/10/%E5%9C%A8Hyper-V%E4%B8%AD%E8%BF%90%E8%A1%8CUbuntu%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Hadoop%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h1 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h1><p>在 Windows 中运行 Linux 的方法有两种。传统的就是安装虚拟机了，当然这两年也逐渐流行使用 WSL（Windows下的 linux 子系统）。由于使用 Linux 是为了完成学校的大数据相关课程，故为了减少折腾，采用传统的虚拟机安装大法。</p><h2 id="虚拟机软件"><a href="#虚拟机软件" class="headerlink" title="虚拟机软件"></a>虚拟机软件</h2><p>Windows 下常用的虚拟机软件有 Vmware-WorkStation，以及 Oracle 的 virtualBox。由于考虑我在学校使用的平板电脑的配置，以及那小的可怜的影片。为了不为难我的可怜的PC平板二合一，我决定使用 Windows 平台自带的 Hyper-V 来进行虚拟化系统的搭建。</p><p><a href="https://up.media.everdo.cn/image/BdQB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/05/vtsoftware.md.jpg" alt="vtsoftware.md.jpg"></a></p><blockquote><p>这里真的大力安利一下 Hyper-V。可能不少人会对这个 Bug 软家的产品嗤之以鼻。(Windows 都那么难用，这 Hyper-V 肯定不行)。不过你要这样想，这个虚拟化平台买 Windows 就送，免费使用，界面简洁，占空间少。就这样还要啥自行车？</p></blockquote><p>相比 Vmware 以及 VirtualBox ，Hyper-v 固然失去了增强的交互体验，3D图形加速。<strong>但也额外带来了动态内存以及更好的高达万兆的虚拟机网络适配器。</strong></p><p><a href="https://up.media.everdo.cn/image/Bbhk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/05/hyper-v.png" alt="hyper-v.png"></a></p><blockquote><p>听说有的大佬想上 ProxmoxBox 以及 VmwareExsi，在这里给土豪大佬们端茶。其实我之前有在蜗牛星际上装过 Proxmox，不过要拿它来跑 Ubuntu 虚拟机就算了吧。</p></blockquote><h3 id="启用-Hyper-V"><a href="#启用-Hyper-V" class="headerlink" title="启用 Hyper-V"></a>启用 Hyper-V</h3><p>不需要苦逼的下载安装，只需要在添加下 Windows功能，然后重启下电脑，Hyper-V 就安装好了。</p><p><a href="https://up.media.everdo.cn/image/Beyt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/05/2020-10-05-120345.png" alt="2020-10-05-120345.png"></a></p><p>重启后，可以在开始菜单的程序列表处找到 Hyper-V 管理器</p><p><a href="https://up.media.everdo.cn/image/Biux" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/05/-2020-10-05-205758.png" alt="-2020-10-05-205758.png"></a></p><h3 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h3><p>打开后，就来创建第一个虚拟机吧！</p><p>首先，需要准备需要安装的操作系统的镜像，Ubuntu 的可以从这里下载：</p><p><a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">https://ubuntu.com/download/desktop</a></p><p>下载完成对应的 ISO 镜像文件后，就可以新建虚拟机，新建时我选择了 4 核心的虚拟 CPU 以及 1GB 的动态内存。然后为虚拟机添加虚拟磁盘和虚拟 DVD 驱动器。驱动器的镜像就选择刚才下载的 ISO。</p><p><a href="https://up.media.everdo.cn/image/BQYI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/05/65.png" alt="65.png"></a></p><blockquote><p>关于虚拟机的代数问题：看到网上不少教程都说 HYper-V 下部署 Linux 虚拟机需要创建时设置为一代虚拟机，选择第二代就有可能无法启动。</p><p>这里就给大家辟谣下：<strong>其实不论是一代还是二代虚拟机都是支持 Linux 的</strong>，两者的区别为，一代虚拟机使用传统的 BIOS 进行引导，而二代虚拟机使用了最新的 UEFI 进行引导。<strong>从使用体验上来说区别并不大，初次安装时其实没必要纠结使用哪一种。</strong></p></blockquote><h3 id="调整启动参数"><a href="#调整启动参数" class="headerlink" title="调整启动参数"></a>调整启动参数</h3><p>如果你和我一样使用了二代的虚拟机，并且启动时看到了如下的界面：</p><p><a href="https://up.media.everdo.cn/image/BqsX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/06/66.png" alt="66.png"></a></p><p>不要慌，这只是卡在了 UEFI 的安全校验上。</p><p>简单粗暴应对这一问题的方法就是直接把 UEFI 的安全启动直接关闭就好。当然也可以和我一样，单纯把安全校验选项切换为开源VM，<strong>而无需关闭安全启动。</strong></p><p><a href="https://up.media.everdo.cn/image/BxKi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/06/26.png" alt="26.png"></a></p><p>调整完毕后，点击启动虚拟机，就可以进入 Ubuntu 的安装界面啦。</p><h2 id="安装-Ubuntu-系统"><a href="#安装-Ubuntu-系统" class="headerlink" title="安装 Ubuntu 系统"></a>安装 Ubuntu 系统</h2><p>开机！</p><p><a href="https://up.media.everdo.cn/image/B624" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/29.png" alt="29.png"></a></p><p>开启虚拟机后，等待一段时间的加载，我们能看到一个简约清爽的欢迎界面：</p><p><a href="https://up.media.everdo.cn/image/BNkM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/31.png" alt="31.png"></a></p><p>选择语言，其实这里更推荐设置英文，因为中文界面下的 bash 命令行终端输出的调试信息也会变成中文，因为 Linux 中文资料较少，遇到报错时搜索错误会比较困难。不过后期也可以对此进行调整。</p><blockquote><p>或许把系统设置为英文，但保留 Gnome 桌面的中文是一个最佳选择</p></blockquote><p>接下来就是愉（wu）快（nao）的下一步：</p><p><a href="https://up.media.everdo.cn/image/BkwY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/35.png" alt="35.png"></a></p><p>泡杯茶，耐心等待进度条跑完 ……</p><p><a href="https://up.media.everdo.cn/image/B9ha" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/37.png" alt="37.png"></a></p><p>再一次虚拟机重启的时候就可以看到熟悉的欢迎界面啦！！</p><p><a href="https://up.media.everdo.cn/image/BEQs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/39.png" alt="39.png"></a></p><h3 id="配置虚拟机网络"><a href="#配置虚拟机网络" class="headerlink" title="配置虚拟机网络"></a>配置虚拟机网络</h3><p>Hyper下支持三种模式的网络：</p><p><a href="https://up.media.everdo.cn/image/BcT3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/07/-2020-10-07-185017.png" alt="-2020-10-07-185017.png"></a></p><p>其中如果虚拟机处在 <strong>内部网络</strong> 虚拟交换机，那么Windows将为虚拟机提供一个独立的 NAT 内网，此时 Windows 的宿主机可以通过这个虚拟的网络访问虚拟机，但虚拟机无法通过网络直接访问物理机。<strong>这种方式下，可以使用 NAT 端口映射将虚拟机内部的端口暴露在物理机上。</strong></p><p>如果是使用 <strong>外部网络</strong> ，那么相当于被大家熟知的网卡桥接，虚拟机的网卡会和物理机网卡处于同一局域网，并需要上级路由器为其分配一个 IP 地址。</p><p>如果是 <strong>专用网络</strong>，那么 Windows 宿主机无法直接访问虚拟机，虚拟机也不能直接访问 Windows 主机，但是同一台宿主机上的多个虚拟机之间可以通过内部 IP 地址进行互相访问。</p><p>考虑到我用于运行虚拟机的电脑是笔记本，会处于各种不同的网络环境。为了减少折腾，这里我选择最简单的内部交换机，使用一个固定的内部 IP 来访问虚拟机。</p><p><a href="https://up.media.everdo.cn/image/BfuG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/43.png" alt="43.png"></a></p><p>可以看到物理机已经可以 ping 通虚拟机了。</p><h3 id="配置-NAT-网络"><a href="#配置-NAT-网络" class="headerlink" title="配置 NAT 网络"></a>配置 NAT 网络</h3><p>考虑到后续可能会需要将虚拟机的端口暴露在局域网中，这里为 NAT 端口映射做一些准备：</p><blockquote><p>为了让 Windows 物理机可以以一个固定的 IP 来访问虚拟机，我在 Linux 中将随机分配 ip 地址改为静态地址。并且在 Hyper-V 设置中将虚拟网卡的 mac 地址设成静态</p></blockquote><p><a href="https://up.media.everdo.cn/image/Bv26" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/-2020-10-08-200707.png" alt="-2020-10-08-200707.png"></a></p><p>操作的方法很简单，只需要到系统的控制面板，将现在正在使用的网络适配器共享给 Linux 虚拟机就可以了。</p><p><a href="https://up.media.everdo.cn/image/BzY9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/46.png" alt="46.png"></a></p><p>在这一步操作过后虚拟机的 IP 段就会从原来的 172.* 变成 192.168.137.0/24。所以这一步操作完成后，我们还需要到 Linux 中把 IP 地址修改成和现在一样的网段。</p><p><a href="https://up.media.everdo.cn/image/B0zj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/47.png" alt="47.png"></a></p><p>两侧都完成配置后，使用宿主机 ping 虚拟机，成功 ping 通！</p><p><a href="https://up.media.everdo.cn/image/Bymn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/48.png" alt="48.png"></a></p><p>此后如果需要进行端口映射，只需要到 <strong><em>Windows 网络适配器，网络共享，设置</em></strong> 里面添加端口就行。</p><h2 id="启用-ssh"><a href="#启用-ssh" class="headerlink" title="启用 ssh"></a>启用 ssh</h2><h3 id="连不上-ssh-的排错"><a href="#连不上-ssh-的排错" class="headerlink" title="连不上 ssh 的排错"></a>连不上 ssh 的排错</h3><p>到这时以为大功告成的我，欢天喜地的拿出 Xhell 大法，尝试连接我的虚拟机，确意外的提示连接被拒绝。</p><p><a href="https://up.media.everdo.cn/image/BTwS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/66.png" alt="66.png"></a></p><p>明明刚才是可以 ping 通的呀？使用 telnet 查看 22 端口，发现 ssh 默认使用的 22 号端口似乎没有开放。</p><p>/托腮</p><p>一通思考后，我屏幕上输入了 <code>ps -e | grep ssh</code></p><p><a href="https://up.media.everdo.cn/image/BSqJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/-2020-10-08-204159cadb8aaf89625405.png" alt="-2020-10-08-204159cadb8aaf89625405.png"></a></p><blockquote><p>似乎有一些异样？</p><p>确实，通过进程可以看到现在只有一个ssh-agent的客户端在运行，但似乎没有任何对外提供ssh的服务存在。</p></blockquote><p>到这里就知道应该怎么办啦，我们只需要安装一下 openssh-server 就可以了。在命令行运行命令：</p><pre><code class="bash">$ sudo apt-get upgrade$ sudo apt-get install openssh-server</code></pre><p><a href="https://up.media.everdo.cn/image/BpTy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/67.png" alt="67.png"></a></p><p>在终端输入 y 来确认安装，安装后，重新使用 ps 命令查看 ssh 相关的进程：</p><p><a href="https://up.media.everdo.cn/image/Bw4d" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/68.png" alt="68.png"></a></p><p>可以看到 sshd 服务已经成功启用了。</p><p>使用 xshell 尝试连接，成功！</p><p><a href="https://up.media.everdo.cn/image/BOYl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/69.png" alt="69.png"></a></p><h3 id="使用-root-远程登录"><a href="#使用-root-远程登录" class="headerlink" title="使用 root 远程登录"></a>使用 root 远程登录</h3><p>到这里我已经可以使用普通用户身份 huxiaofan 远程登录我的虚拟机了，但还没法远程使用 root 账户登录。因此需要做下面的两个操作：</p><h4 id="设置-root-用户密码"><a href="#设置-root-用户密码" class="headerlink" title="设置 root 用户密码"></a>设置 root 用户密码</h4><p>这一步非常简单，使用 passwd 命令就能轻松搞定：</p><pre><code class="bash">$ sudo passwd root</code></pre><p>设置成功后我们使用 su 命令尝试切换当前用户身份：</p><pre><code class="bash">$ su root#</code></pre><p><a href="https://up.media.everdo.cn/image/BUz0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/70.png" alt="70.png"></a></p><p>可以看到已经成功切换到 root 身份。但此时还是无法用 root 账户远程登录。</p><h4 id="允许-root-远程登录"><a href="#允许-root-远程登录" class="headerlink" title="允许 root 远程登录"></a>允许 root 远程登录</h4><p>这一步的关键需要修改 sshd 服务的配置文件。所以使用 vi 编辑器来修改 sshd_conf。</p><pre><code class="bash">$ vi /etc/sshd/sshd_conf</code></pre><p>找到下面这一行 <code>PermitRootLogin yes</code> 然后将其取消注释即可。对了，不要忘记重新启动 ssh 服务。</p><pre><code class="bash">$ service sshd restart</code></pre><p><a href="https://up.media.everdo.cn/image/BZLD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/71.png" alt="71.png"></a></p><p>尝试使用 root 用户远程登录成功！</p><p><a href="https://up.media.everdo.cn/image/BG2L" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/72.png" alt="72.png"></a></p><h3 id="Tips-去除烦人的提示"><a href="#Tips-去除烦人的提示" class="headerlink" title="Tips 去除烦人的提示"></a>Tips 去除烦人的提示</h3><p>如果和我一样，每次在连上 ssh 的时候就有如下的错误信息：</p><pre><code>Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection</code></pre><p>这个错误可能发生在某次失败的 apt 命令操作后。而想要解决也很简单：</p><ol><li>移除 ： /var/lib/ubuntu-release-upgrader/release-upgrade-available</li><li>运行 ： /usr/lib/ubuntu-release-upgrader/release-upgrade-motd</li></ol><pre><code class="bash"># rm /var/lib/ubuntu-release-upgrader/release-upgrade-available# cd /usr/lib/ubuntu-release-upgrader# ./release-upgrade-motd</code></pre><p><a href="https://up.media.everdo.cn/image/BKmc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/08/73_LI.jpg" alt="73_LI.jpg"></a></p><p>运行后，重新使用 ssh 登录就不会看到那条错误信息啦。</p><h2 id="Tips-启用增强会话（妙啊！）"><a href="#Tips-启用增强会话（妙啊！）" class="headerlink" title="Tips 启用增强会话（妙啊！）"></a>Tips 启用增强会话（妙啊！）</h2><blockquote><p>2020-10-19 更新 启用增强会话</p><p><strong>注意！需要在 Hyper-V 中使用二代虚拟机！</strong></p></blockquote><p>用剪贴板直接同步文字，虚拟机直接访问物理机磁盘。谁说这样的功能非得是 VMware 才有的呢？</p><p>用了几天的 Hyper-V 自带的连接虚拟机图形界面功能，这画面简直（掉帧，高时延，分辨率低……），而且不能在虚拟机和宿主机之间传文件，但其实，Hyper-V 也是可以和其他虚拟机软件一样为我们提供更加流畅好用的图形界面的。</p><p>不同于 VMware 的通过安装驱动 VMwareTools 的方法。Hyper-V 使用的是 XORG 下 XRDP 远程桌面的形式，（间接）实现了增强交互的目的。（这不同于 Hyper-V 默认连接到虚拟机的类似于 IPMI 虚拟显示器的形式。</p><p>启用的过程很简单，只需要直接运行下面的脚本（需要先安装 GIT）：</p><pre><code class="bash"># 脚本来自微软官方的 GitHub# 使用时根据自己系统版本选择git clone https://github.com/microsoft/linux-vm-tools.gitcd ./linux-vm-tools/ubuntu/20.04/sudo chmod +x ./install.shsudo ./install.sh</code></pre><p><a href="https://up.media.everdo.cn/image/jnal" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_1.png" alt="ubuntu-xrdp_1.png"></a></p><p>等待运行完，会提示重启虚拟机，同样不要忘记需要手动重启。</p><p><a href="https://up.media.everdo.cn/image/jBA0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_3.png" alt="ubuntu-xrdp_3.png"></a></p><p>重启后，进入该目录再次运行一次 install.sh。</p><pre><code class="bash">sudo bash /linux-vm-tools/ubuntu/20.04/install.sh</code></pre><p><a href="https://up.media.everdo.cn/image/jRcD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_4.png" alt="ubuntu-xrdp_4.png"></a></p><p>此时我们已经使用脚本自动化的安装，配置完了 XRDP。然后我们回到 Hyper-V 配置，来确认下是不是已经再 Hyper-V 中启用了增强会话。</p><p><a href="https://up.media.everdo.cn/image/jjZL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_2.png" alt="ubuntu-xrdp_2.png"></a></p><p>这时候，可能心急的小伙伴就试着去开虚拟机了，结果发现，哎呀，为啥虚拟机连接上面增强会话的按钮还是灰色的呢？别急，下面是很关键的一步：</p><pre><code class="powershell">Set-VM -VMName 你的虚拟机名字 -EnhancedSessionTransportType HvSocket# Set-VM -VMName Ubuntu2020 -EnhancedSessionTransportType HvSocket</code></pre><p><a href="https://up.media.everdo.cn/image/j2Rc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_5.png" alt="ubuntu-xrdp_5.png"></a></p><p>这时候赶紧打开虚拟机体验一波吧！（由于是登录前对增强会话进行设置，所以需要关闭Linux的自动登录）</p><p><a href="https://up.media.everdo.cn/image/jF62" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_6.png" alt="ubuntu-xrdp_6.png"></a></p><p>可以看到增强会话的设置项已经出现了。可以配置虚拟机访问物理机磁盘和剪贴板了！</p><p><a href="https://up.media.everdo.cn/image/j3SZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_7.png" alt="ubuntu-xrdp_7.png"></a></p><p>使用 Xorg 的 Xrdp 可以获得更好的画质和更低的延时：</p><p><a href="https://up.media.everdo.cn/image/jDPk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/19/ubuntu-xrdp_8.png" alt="ubuntu-xrdp_8.png"></a></p><blockquote><p>下一篇继续更新</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb初试 使用IDEA平台</title>
      <link href="/2020/09/JavaWeb%E5%88%9D%E8%AF%95-%E4%BD%BF%E7%94%A8IDEA%E5%B9%B3%E5%8F%B0/"/>
      <url>/2020/09/JavaWeb%E5%88%9D%E8%AF%95-%E4%BD%BF%E7%94%A8IDEA%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p><strong><em>不知道为啥自己选了这门课，好像 JSP 是淘汰了蛮久的技术吧。emm，不过既然学了就好好学</em></strong></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>首先 JAVAWEB 是使用 JSP 进行开发的，基于 JAVA EE 企业级环境。所以，JDK 这样的环境是必不可少的。</p><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h3><p><strong>关于 JDK 相关的内容，可以参考我之前的文章：</strong><a href="https://coding.emptinessboy.com/2020/02/JAVA%E5%AD%A6%E4%B9%A0%E4%B9%8BJDK%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">JAVA入坑之JDK环境安装到HelloWorld</a></p><p>这里需要注意的是，由于 JAVAWEB 是企（gu）业（dong）级的产品，所以目前最新版本的 JAVA15 是不兼容的，我们需要手动下载旧版本的 <strong>JDK1.8</strong></p><h3 id="集成开发环境-IDEA"><a href="#集成开发环境-IDEA" class="headerlink" title="集成开发环境 IDEA"></a>集成开发环境 IDEA</h3><p>由于自己之前初学 JAVA 的时候就用的 inteliJ IDEA 感觉比较顺手，所以这里我下载了 inteliJ IDEA 作为我学习 JAVAWEB 的集成开发环境</p><p><a href="https://up.media.everdo.cn/image/7mMl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/intelij.png" alt="intelij.png"></a></p><h3 id="ServerLet-服务器"><a href="#ServerLet-服务器" class="headerlink" title="ServerLet 服务器"></a>ServerLet 服务器</h3><p>这里有两种方案，一种是使用重量级的 Oracle 的 <strong>glassfish5</strong>，另一种是使用免费的 Appache 基金会的 <strong>Tomcat</strong>（汤姆猫）</p><p><a href="https://up.media.everdo.cn/image/7cDD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/apachetomcat.png" alt="apachetomcat.png"></a></p><h2 id="开始-HelloWorld"><a href="#开始-HelloWorld" class="headerlink" title="开始 HelloWorld"></a>开始 HelloWorld</h2><blockquote><p>这里说一下我选择的方案，使用 inteliJ IDEA 集成开发环境，以及 JDK1.8 作为开发使用。选择 轻量级的 Tomcat 作为运行 JSP 的服务器。</p></blockquote><p>一切就绪后，就开始动手操作啦！</p><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><p>在我的电脑，已经有 JDK 了，我设置的默认 JDK 版本是 14，但不影响我使用 JDK8，只需要在 IDEA 创建项目的时候将项目设置为 JDK8 即可</p><p>然后就是下载 TomCat。官网：<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a></p><p>这一步不管是下载 WindowsInstaller 可执行安装程序，亦或是下载 zip 格式的压缩包，都没有任何关系。至于安装程序的版本，最后会生成 Tomcatw 这个程序用来控制 Tomcat 服务器的启动，方便修改配置文件等。</p><p>安装完毕后，一定要记住安装的目录。然后你就可以看到和我一样的下面的控制界面了。</p><p><a href="https://up.media.everdo.cn/image/7fcL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/tomcatinstall.png" alt="tomcatinstall.png"></a></p><p>点击左下方的 Start ，我们可以简单的测试一下 Tomcat 是不是已经可以正常的在我们的系统上工作：</p><p><strong>我们在浏览器输入： <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></strong></p><p><a href="https://up.media.everdo.cn/image/70j2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/tomcathello.png" alt="tomcathello.png"></a></p><p>如果你和我一样，看到了图示的 Tomcat 欢迎界面，那么说明 Tomcat 的安装已经成功了。</p><h4 id="IDEA-的坑"><a href="#IDEA-的坑" class="headerlink" title="IDEA 的坑"></a>IDEA 的坑</h4><p>这里我是通过 ToolBox 下载 IDEA 的。很方便很好用，强烈推荐。</p><p>点击 Install，然后慢悠悠的喝杯茶，emm，悠闲，巴适。。。。。大概 30min 过去后，看到恼人的安装条终于跑到了99%。于是回到电脑桌前，打开 IDEA 后，尝试创建一个 JAVAWEB 项目。</p><p><a href="https://up.media.everdo.cn/image/716Z" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/IDEAempty.png" alt="IDEAempty.png"></a></p><pre><code>咦？JAVAWEB 项目的按钮在哪？看了一通百度，也没找到别人所说的 WEB A品牌力擦体哦那？？？</code></pre><p>不得已，求助 Google，看到国外大佬对此的回答：</p><p><a href="https://up.media.everdo.cn/image/7Mpk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/need-untimate.png" alt="need-untimate.png"></a></p><blockquote><p>大意就是，这个 IDEA 里面没有 JavaEE 相关的东西是很正常的，因为我们用的是 Community 版本，也就是免费版的 IDEA。只要升级成付费的 Ultimate 版本，就可以愉快的使用 JavaEE 了。</p></blockquote><p>看到这里，果断点了 Ultimate 版本的安装。继续一杯茶时间的等待🤣</p><p><a href="https://up.media.everdo.cn/image/7yIB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/installIDEA.png" alt="installIDEA.png"></a></p><p>终于安装好了，登录我的账号激活下。付费版的图标和免费版略有不同，感觉好像很高大上的样子。</p><p>这回，打开属性的创建项目窗口，瞬间组件多了很多有没有？</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/newproject.png" alt="newproject.png"></p><h3 id="建立-JavaEE-项目"><a href="#建立-JavaEE-项目" class="headerlink" title="建立 JavaEE 项目"></a>建立 JavaEE 项目</h3><p><strong>但是因为我使用的是最新的 inteliJ2020 版本，所以和网上查到的新建 WEB-APPLICATION 的方法不太一样。</strong></p><p>使用 2020 版的 idea 没有2019版那样快捷的 java enterprise模块 的选项，我们需要先创建一个普通的 java 程序项目：</p><p><a href="https://up.media.everdo.cn/image/oAoO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_1.png" alt="idea-start-js-p_1.png"></a></p><p>像这样什么模板都不用选择：</p><p><a href="https://up.media.everdo.cn/image/oDk6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_2.png" alt="idea-start-js-p_2.png"></a></p><p>在项目创建完成后，点击左侧菜单按钮，选择项目结构，在项目模块处导入 Tomcat 的包，这一步需要先完成 Tomcat 与 idea 的关联，在本文后面有提到：</p><p><a href="https://up.media.everdo.cn/image/oVwn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_3.png" alt="idea-start-js-p_3.png"></a></p><p>到这里重点来了，我们现在需要为这个项目添加模块，让它变成一个 Jsp 项目应该有的样子。</p><p><a href="https://up.media.everdo.cn/image/obhS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_4.png" alt="idea-start-js-p_4.png"></a></p><p>我们需要做的是选中左侧目录树中的项目根目录，右键添加框架支持：</p><p><a href="https://up.media.everdo.cn/image/odQQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_5.png" alt="idea-start-js-p_5.png"></a></p><p>点击确认后，我们熟悉的 jsp 项目的基本目录就会被自动生成了。</p><hr><p><strong>以下是不做推荐的新建项目的方法：</strong></p><p><del>我们需要参考最新的官方文档：来自JetBrains 官方：<strong><a href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-ee-application.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-ee-application.html</a></strong></del></p><p><del>这里我们需要先创建 Java Enterprise 项目，记得 SDK 版本一定要选择 Java8 或者 Java1.8 ，构建工具选择 Maven，测试程序选择 Junit。</del></p><p><a href="https://up.media.everdo.cn/image/7Xvx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/newjavaweb.png" alt="newjavaweb.png"></a></p><p><del>到了这一步选择库和框架时，我们勾选 Servelet （Web应用程序框架）。然后在下一步时输入项目名称就可以了！</del></p><p><a href="https://up.media.everdo.cn/image/7ClI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/javawebhello.png" alt="javawebhello.png"></a></p><h3 id="Tomcat-与-IDEA-的关联"><a href="#Tomcat-与-IDEA-的关联" class="headerlink" title="Tomcat 与 IDEA 的关联"></a>Tomcat 与 IDEA 的关联</h3><p>刚创建完成项目，我们需要多等待一会，等 Maven 同步完成后，我们方能创建我们的第一个网页文件。</p><p>在此之前，我们可以先配置 Tomcat 与 IDEA 的关联：</p><pre><code>打开设置 ---&gt; 构建，执行，部署 ---&gt; 应用程序服务器</code></pre><p>点击左上角小小的加号 “+”，然后选择 TomcatServer。</p><p><a href="https://up.media.everdo.cn/image/7wG4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/addnew.png" alt="addnew.png"></a></p><p>接下来在弹出的窗体中输入 TomCat 的安装路径（前面让大家把路径记下来就是这么回事）。</p><p><a href="https://up.media.everdo.cn/image/7pDX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/addtomcat.png" alt="addtomcat.png"></a></p><p>最后，保存下相关信息就可以了</p><p><a href="https://up.media.everdo.cn/image/7tfi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/appserver.png" alt="appserver.png"></a></p><h3 id="添加运行选项"><a href="#添加运行选项" class="headerlink" title="添加运行选项"></a>添加运行选项</h3><p>刚刚添加了 Tomcat 到服务器选项还是不够的。我们还需要配置运行选项：</p><pre><code>从主菜单中，选择运行| 编辑配置。在“ 运行/调试配置”对话框中，单击添加按钮，展开Tomcat Server节点，然后选择“ 本地”。修复运行配置设置对话框底部出现的所有警告。</code></pre><p><a href="https://up.media.everdo.cn/image/7KIs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/tomcatrun.png" alt="tomcatrun.png"></a></p><h3 id="新建网页文件"><a href="#新建网页文件" class="headerlink" title="新建网页文件"></a>新建网页文件</h3><p>三杯茶喝完，我们的项目应该也差不多同步完成了，我们可以展开目录树：</p><p><a href="https://up.media.everdo.cn/image/7UjM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/fileTree.png" alt="fileTree.png"></a></p><p>找到下面的路径。</p><pre><code>src/main/webapp</code></pre><p>此时，如果我们的项目已经初始化完成，这时候就可以右键 <strong>webapp</strong> 文件夹，新建 JSP/JSPX 文件啦！（如果项目还没完成初始化，是不会有这个选项的，耐心等待进度条跑完就可以啦！）</p><blockquote><p>下图勘误：应该为 <strong>webapp</strong> 文件夹中新建文件</p></blockquote><p><a href="https://up.media.everdo.cn/image/7ZNY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/newjavasp.png" alt="newjavasp.png"></a></p><p>新建一个 HelloWorld 的 JSP 文件，然后写入代码：</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: huxia  Date: 2020/9/16 0016  Time: 23:33  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;% out.println(&quot;Hello World！&quot;); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(&quot;Hello, EmptinessBoy！&quot;); %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="https://up.media.everdo.cn/image/75pa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/newjavawebhello.png" alt="newjavawebhello.png"></a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>激动人心的时刻终于来了，这时只要右键 运行文件 ，就可以直接在浏览器看到我们刚才写的文件运行效果啦！</p><p><a href="https://up.media.everdo.cn/image/7Lr3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/16/helloworld.png" alt="helloworld.png"></a></p><h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><h4 id="坑-A-控制台乱码"><a href="#坑-A-控制台乱码" class="headerlink" title="坑 A 控制台乱码"></a>坑 A 控制台乱码</h4><p>Tomcat 控制台输出部分乱码。原因为汤姆猫默认的 UTF-8 和 Windows 系统默认 GBK 不一致。</p><p><strong>解决方法：</strong></p><p>修改 Tomcat 10.0\conf\logging.properties 文件，新增一行：</p><pre><code class="conf">java.util.logging.ConsoleHandler.encoding = GBK</code></pre><p>解决后：</p><p><a href="https://up.media.everdo.cn/image/B4G6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/bug2.png" alt="bug2.png"></a></p><h4 id="坑-B-代码提示异常"><a href="#坑-B-代码提示异常" class="headerlink" title="坑 B 代码提示异常"></a>坑 B 代码提示异常</h4><p>具体异常表现为：<strong>无法解析方法’println(java.lang.String)’</strong></p><p><a href="https://up.media.everdo.cn/image/7lVj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/bug1.png" alt="bug1.png"></a></p><p><strong>解决方法：</strong></p><p>打开项目结构 –&gt; 模块</p><p><a href="https://up.media.everdo.cn/image/78vG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/bug1-fix.png" alt="bug1-fix.png"></a></p><p>选中项目名，选则右边的依赖：</p><p><a href="https://up.media.everdo.cn/image/7al9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/bug1-fix1.png" alt="bug1-fix1.png"></a></p><p>选中 Tomcat，把 Tomcat 加入依赖即可</p><p><a href="https://up.media.everdo.cn/image/7ufO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/bug1-fix2.png" alt="bug1-fix2.png"></a></p><h4 id="坑-C-未配置关闭端口"><a href="#坑-C-未配置关闭端口" class="headerlink" title="坑 C 未配置关闭端口"></a>坑 C 未配置关闭端口</h4><p>如果出现如下的报错：未配置关闭端口。通过OS信号关闭服务器。服务器未关闭</p><p>解决方法很简单，只要编辑 Tomcat 安装目录下配置文件夹下的 server.xml。找到 server port 这一行，把原先的 -1 修改为 8005 即可</p><p><a href="https://up.media.everdo.cn/image/RG1G" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/15/c018f52c8bce858bf57f4ce74cb225f4.png" alt="c018f52c8bce858bf57f4ce74cb225f4.png"></a></p><h4 id="坑-D-Tomcat9-兼容性"><a href="#坑-D-Tomcat9-兼容性" class="headerlink" title="坑 D Tomcat9 兼容性"></a>坑 D Tomcat9 兼容性</h4><p>实测 Tomcat9.39 即使导入了正确的包也可能存在语法提示错误，提示某个 class 不存在之类的。</p><p>事实上这个问题不影响程序的最终运行。但 ide 上红色的报错会让人很难受。</p><p>解决方法就是，手动建立第三方库，然后将 Tomcat 安装目录下 lib 文件夹中需要的包复制到我们刚才建的第三方库目录即可：</p><p><a href="https://up.media.everdo.cn/image/oeTJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/11/12/idea-start-js-p_7.png" alt="idea-start-js-p_7.png"></a></p><p>把 servelet-api.jar 等包复制到 WEB-INF 下面的这个目录即可。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA,WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍片不用买胶片！从云下载MR源文件DICOM</title>
      <link href="/2020/09/%E6%87%92%E5%BE%97%E8%B7%91%E5%8C%BB%E9%99%A2%EF%BC%81%E4%BB%8E%E4%BA%91%E4%B8%8B%E8%BD%BDMR%E6%BA%90%E6%96%87%E4%BB%B6DICOM/"/>
      <url>/2020/09/%E6%87%92%E5%BE%97%E8%B7%91%E5%8C%BB%E9%99%A2%EF%BC%81%E4%BB%8E%E4%BA%91%E4%B8%8B%E8%BD%BDMR%E6%BA%90%E6%96%87%E4%BB%B6DICOM/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>这是一个因 阑尾炎？ 泡在医院的暑假</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NOTE：从暑假开始，自己就一直闹肚子，一会腹泻一会肚子疼的，看了消化科的医生，诊断为肠功能紊乱，服用各种益生菌治疗了整整一个月。然后吃各种肠胃药的效果就是时好时坏，然后然后，我整个暑假都没吃上冰淇淋（差评！</p><p>就这样一直折腾到9月初，肚子越来越疼。到医院翻看了6月时做的ct，医生觉得我的阑尾有问题。为了进一步确诊，就去拍了MR。</p><h2 id="拍片"><a href="#拍片" class="headerlink" title="拍片"></a>拍片</h2><p>如果你想知道做MR大概是一种什么样的感受？</p><p><strong>一句话概括就是，躺进一个非常巨大的机器（超导磁体）里，然后身上绑一个大大的线圈，闭上眼睛听一段20分钟震耳欲聋的duangduangdaung，kakaka，zhizhizhi的交响曲。</strong></p><p>在这过程中，从机器巨大的洞里，还会吹出冰冷冰冷的风。昏暗的灯光，发出巨响震动的机器。 <strong><em>虽然没有网上说的那么吓人，不过也不是一种让人愉悦的体验</em></strong></p><p>渡劫般度过这段时间后，剩下的就是花几个小时等待报告。</p><h2 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h2><p>由于 MR 是在另一家医院拍的，医院只能给出一张 A4 纸打印的报告单。要胶片的话得额外掏 50 元胶片费。好在系统提供了一个云胶片的二维码入口，方便用手机简单查看影像。</p><p>那么问题就来了，如果要去别的医院让医生帮你诊断的话，外院医生不可能凭一个小小手机屏幕的模糊云影像帮你做具体的诊断。因为 —— 这根本看不清啊。就算你花钱领了胶片，可是你知道 CT 或 MR 一次拍片可是有数百张影像，好几个序列的。印在胶片上的都是医生帮你挑选过的典型的几个图像。如果医生没挑出来在胶片上的， 很可能就因此漏诊了。</p><p><a href="https://up.media.everdo.cn/image/7x6Q" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/11/218960cbffd570226f7d04d1f7973eae.png" alt="218960cbffd570226f7d04d1f7973eae.png"></a></p><h2 id="云影像"><a href="#云影像" class="headerlink" title="云影像"></a>云影像</h2><p>感谢科技的进步和医疗技术的发展，使得影像数据可以被数字化的保存在云平台，并通过云服务让我们查看。不过有点遗憾的在于，提供的云影像在清晰度和操作上都逊于实体影像。</p><p>由于是浏览器提供的影像工作台，导致了画面渲染起来的卡顿和掉帧。最重要的是，这些数据都是在云端的，并不在我的手里，万一在需要阅片的时候，云服务暂停了，或者哪天超过了存储限定日期。这些数据很可能就被删除了。</p><p><a href="https://up.media.everdo.cn/image/7WpJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/12/1.png" alt="1.png"></a></p><h2 id="把云影像变为数字影像"><a href="#把云影像变为数字影像" class="headerlink" title="把云影像变为数字影像"></a>把云影像变为数字影像</h2><p>为了真正获得自己的影像拍摄数据，我决定想办法下载到真正的原始影像。毕竟花了好几百拍的片呐！</p><blockquote><p>经过各种“多方求学”，了解到医学数字影像文件都是 DICOM 格式的。只有搞到这一套片子才能看到自己完整的扫描结构。</p></blockquote><h3 id="尝试下载"><a href="#尝试下载" class="headerlink" title="尝试下载"></a>尝试下载</h3><p>最开始能想到的方法，无非就是云平台自身提供的下载按钮。刚找到下载入口的时候，还因此小小的兴奋了一番。以为只要这么一步就可以成功了。</p><p>然而，真的按下那个按钮的时候才知道原来这个按钮只能用来下载单张的 JPG 格式图像。并不能下载到完整的影像文件。</p><h3 id="分析网页"><a href="#分析网页" class="headerlink" title="分析网页"></a>分析网页</h3><p>这时候细心的我发现，白色的网页边框中显示云影像的区域似乎是一个 iFrame 形式的嵌套。</p><p><a href="https://up.media.everdo.cn/image/BJon" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/2.png" alt="2.png"></a></p><p>从图片中可以看到嵌套的 iFrame 页面的具体网址。在提取获得网址以后，尝试进行访问，看看现在的效果。</p><pre><code>提取到的网址：https://nbss.mtywcloud.com/ICCWebClient/Image/ViewerV2?AllowQuery=0&amp;DicomDirPath=http://nb-lihuili01/192.168.141.11/检查单号/Exam/ExamImage/一串编号/DICOMDIR&amp;BusinessID=又一串编号&amp;BusinessType=Exam&amp;DocumentService=https%3a%2f%2fnbss.mtywcloud.com%2fDocumentService%2f&amp;OrganizationID=编号-X&amp;AuthorizeID=编号&amp;Token=编号</code></pre><p>单独访问这个页面可以看到，整个浏览器完整的显示了一个云影像的页面。</p><p><a href="https://up.media.everdo.cn/image/BPNS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/3.png" alt="3.png"></a></p><p>但单单这样还是不够的，别忘了我们的最终目的是把我们的胶片下载到本地。</p><h3 id="分析-URL"><a href="#分析-URL" class="headerlink" title="分析 URL"></a>分析 URL</h3><p>盯着开发工具里的 network 半天，也没找着啥玄机来。于是决定回头分析现在的 URL。从 URL 来看，可以把刚才的 URL 分成两部分。一部分是前面云影像平台的 URL，后面的是我拍片所在医院名字开头的 hostname。看起来像是一个局域网服务器的样子。</p><pre><code>提取到的网址第一部分：https://nbss.mtywcloud.com/ICCWebClient/Image/ViewerV2?AllowQuery=0&amp;DicomDirPath=第二部分：http://nb-lihuili01/192.168.141.11/检查单号/Exam/ExamImage/一串编号/DICOMDIR&amp;BusinessID=又一串编号&amp;BusinessType=Exam&amp;DocumentService=https%3a%2f%2fnbss.mtywcloud.com%2fDocumentService%2f&amp;OrganizationID=编号-X&amp;AuthorizeID=编号&amp;Token=编号</code></pre><p>单独访问第一个 URL 试试：</p><p><a href="https://up.media.everdo.cn/image/BItQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/4.png" alt="4.png"></a></p><p>可以看到，云影像浏览器的框架已经被载入，但是弹出 JS 的报错，获取检查信息错误。而我们的第二个 URL 很明显是一个内网的地址，没法进行直接访问。</p><p>看起来此路不通啊！</p><p>等等，难道我就要这样放弃么？当然不会啦！</p><h3 id="继续拆解"><a href="#继续拆解" class="headerlink" title="继续拆解"></a>继续拆解</h3><p>再仔细观察刚才拆分得到的第二组 URL：</p><pre><code>第二部分：http://nb-lihuili01/192.168.141.11/检查单号/Exam/ExamImage/一串编号/DICOMDIR&amp;BusinessID=又一串编号&amp;BusinessType=Exam&amp;DocumentService=https%3a%2f%2fnbss.mtywcloud.com%2fDocumentService%2f&amp;OrganizationID=编号-X&amp;AuthorizeID=编号&amp;Token=编号</code></pre><p>观察后我发现，在整个 url 后半部分传参 DocumentService 的地方，藏着一个被 encode 的 url：</p><pre><code>https%3a%2f%2fnbss.mtywcloud.com%2fDocumentService%2f&amp;OrganizationID=编号-X&amp;AuthorizeID=编号&amp;Token=编号</code></pre><p>尝试将上述 URL 进行解码，果然有所发现：</p><pre><code>解码后结果：https://nbss.mtywcloud.com/DocumentService/&amp;OrganizationID=编号&amp;AuthorizeID=编号&amp;Token=编号</code></pre><p>尝试直接访问解码后的结果，可以看到 服务器 是 IIS，脚本语言使用的是 asp.net 。访问后系统报了一个 500 的错误。</p><p><strong>貌似接口不允许直接访问？</strong></p><p>那么直接访问 DocumentService 这个路径试试？</p><p><a href="https://up.media.everdo.cn/image/BnhJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/6.png" alt="6.png"></a></p><p>访问完简直眼前一亮的感觉有没有？居然所有的接口都写在这里了！连怎样使用都有</p><h3 id="访问下载接口"><a href="#访问下载接口" class="headerlink" title="访问下载接口"></a>访问下载接口</h3><blockquote><p>所以到此为止，我们可以判断。提取到的网址第一部分：<a href="https://nbss.mtywcloud.com/ICCWebClient/Image/ViewerV2?AllowQuery=0&amp;DicomDirPath=" target="_blank" rel="noopener">https://nbss.mtywcloud.com/ICCWebClient/Image/ViewerV2?AllowQuery=0&amp;DicomDirPath=</a> 就是一个单纯的云影像浏览器。并不包含影像内容。</p></blockquote><p>通过将实际片子所在的下载接口传参到云影像浏览器，就可以使用云影像平台进行看图。</p><p>换而言之，只要按照规范传递参数，其他地方的片子，其实也是可以用这个云影像浏览器打开的。</p><p>所以，对于我们要下载片子而言，其实只要访问下载接口就可以了。</p><p><strong>访问下载接口：</strong></p><p><a href="https://up.media.everdo.cn/image/B7ry" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/7.png" alt="7.png"></a></p><p>继续报错，不过莫慌。这里看到错误内容为 businessID 和 fileUid不能同时为空。</p><p>而其实我们在刚才拆分 URL 时，可以看到第二部分是含有 businessID 的：</p><blockquote><p>第二部分：</p><p><a href="http://nb-lihuili01/192.168.141.11/检查单号/Exam/ExamImage/一串编号/DICOMDIR&amp;***BusinessID=又一串编号***&amp;BusinessType=Exam&amp;DocumentService" target="_blank" rel="noopener">http://nb-lihuili01/192.168.141.11/检查单号/Exam/ExamImage/一串编号/DICOMDIR&amp;***BusinessID=又一串编号***&amp;BusinessType=Exam&amp;DocumentService</a></p></blockquote><p>最后拷贝 businessID ，访问接口：</p><p><a href="https://up.media.everdo.cn/image/BByd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/842c77fb6ec1750fd5421d977b9574b4.png" alt="842c77fb6ec1750fd5421d977b9574b4.png"></a></p><p>看到第一个，熟悉的 dicom（医学通用影像格式文件） 有没有，大概有150M左右的一个压缩包。</p><p>下载后解压：</p><p><a href="https://up.media.everdo.cn/image/BRll" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/1.png" alt="1.png"></a></p><h2 id="阅片"><a href="#阅片" class="headerlink" title="阅片"></a>阅片</h2><p>可以看到下载后的 dicom 文件，其实是由若干 dcm 文件，和一个 DICOMDIR 索引文件构成。</p><p>我们只需要用 dicom 阅片软件打开索引文件，软件就会自动帮我们导入各种序列。</p><p><a href="https://up.media.everdo.cn/image/BoV0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/22cabbab54dfe4435.png" alt="22cabbab54dfe4435.png"></a></p><p>从影像上数了一下，一共有500多张不同序列的图片。软件会自动在阅片时进行三维的定位，并且可以进行窗宽窗位的调节。</p><p>相比平时我们做完检查后，付钱然后拿到一个只有区区几十个图片的胶片比。获得这样的影像能够真正提高影像的实用价值。方便医生诊断以及减少重复的，无谓的检查。</p><p>最后，放个动图展示下 dicom 影像播放序列时的画面。这下你应该就知道电子影像的优势了吧？</p><blockquote><p>emm，为了隐私，紫色的为打上的马赛克</p></blockquote><p><a href="https://up.media.everdo.cn/image/B2sD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/hxfmri.gif" alt="hxfmri.gif"></a></p><p>PS：下周就要动手术切阑尾了，希望自己一切顺利！</p><p>另外，慢性阑尾炎诊断过程真的很难。拖了整整两个月。期间我竟然被迫自学起了CT和MRI的阅片。</p><p><a href="https://up.media.everdo.cn/image/BFGL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/09/17/learnmri.jpg" alt="learnmri.jpg"></a></p><p>虽然最后并没有什么卵用，诊断还是得靠医生。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医学 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-学习笔记05（文件和编码）</title>
      <link href="/2020/07/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%89/"/>
      <url>/2020/07/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%EF%BC%88%E6%96%87%E4%BB%B6%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="文件编码解码"><a href="#文件编码解码" class="headerlink" title="文件编码解码"></a>文件编码解码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><blockquote><p><strong>Unicode</strong> 是 <strong>「字符集」</strong> ， <strong>UTF-8</strong> 是 <strong>「编码规则」</strong><br><br><br>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）<br>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</p></blockquote><p>计算机内存里面使用的是 unicode，硬盘里面使用的是 utf-8。因为存储 utf-8 更加节约空间。</p><p>utf-8 是变长的也就意味着用户输入字符 “你好ab” 的时候，如果内存也用 utf-8 则需要经历一个计算的过程，然后才能存储，这个时候计算消耗的时间会非常的多（总时间 = 计算机时间 + 存储时间）但如果内存里面的编码采用 unicode 则不需要计算</p><p>我们现在使用的编辑器默认都是 utf-8</p><h3 id="python-字符编码"><a href="#python-字符编码" class="headerlink" title="python 字符编码"></a>python 字符编码</h3><p>python3 内部默认使用的是 unicode 码</p><pre><code class="python"># 编码与解码s = &#39;hello world 你好&#39;# 编码:将人看的变成计算机能够看的懂的res = s.encode(&#39;utf-8&#39;)print(res)  # b&#39;hello world \xe4\xbd\xa0\xe5\xa5\xbd&#39;&quot;&quot;&quot;在python中的bytes类型你可以直接看成二进制格式&quot;&quot;&quot;# 解码:将计算机看到懂的变成人能看的懂print(res.decode(&#39;gbk&#39;))print(res.decode(&#39;utf-8&#39;))print(res.decode())&gt;&gt;&gt; b&#39;hello world \xe4\xbd\xa0\xe5\xa5\xbd&#39;hello world 浣犲ソhello world 你好hello world 你好</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>计算机文件，是存储在某种<strong>长期储存</strong>设备上的一段数据流。其特点是所存信息可以长期、多次使用，不会因为断电而消失。</p><p>计算机文件可分为二种： <strong>二进制文件和文本文件</strong></p><ul><li>图形文件及文字处理程序等计算机程序都属于二进制文件。</li><li>文本文件则是可以用文字处理程序阅读的简单文本文件。</li></ul><h3 id="文件读写步骤"><a href="#文件读写步骤" class="headerlink" title="文件读写步骤"></a>文件读写步骤</h3><ol><li>打开文件</li><li>处理数据</li><li>关闭文件</li></ol><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><pre><code class="python">fileobj = open(filename, mode)</code></pre><p>fileobj 是 open() 返回的文件对象，filename 是该文件的文件名。</p><p>mode 是指明文件类型和操作的字符串。</p><ul><li>mode 的第一个字母表明对其的操作。</li><li>mode 的第二个字母是文件类型：<ul><li>t（可省略）代表文本类型文件；</li><li>b 代表二进制类型文件。</li></ul></li></ul><h4 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h4><table><thead><tr><th>文件打开模式</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>只读模式 (默认)</td></tr><tr><td>“w”</td><td>覆盖写模式 (不存在则新创建；存在则重写新内容)</td></tr><tr><td>“a”</td><td>追加模式 (不存在则新创建；存在则只追加内容)</td></tr><tr><td>“x”</td><td>创建写模式 (不存在则新创建；存在则出错)</td></tr><tr><td>“+”</td><td>与 r/w/a/x 一起使用，增加读写功能</td></tr><tr><td>“t”</td><td>文本类型</td></tr><tr><td>“b”</td><td>二进制类型</td></tr></tbody></table><h4 id="文件读写函数"><a href="#文件读写函数" class="headerlink" title="文件读写函数"></a>文件读写函数</h4><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>open()</td><td>打开文件</td></tr><tr><td>read(size)</td><td>从文件读取长度为size的字符串，如果未给定或为负则读取所有内容</td></tr><tr><td>readline()</td><td>读取整行，<strong>返回字符串</strong></td></tr><tr><td>readlines()</td><td>读取所有行并 <strong>返回列表</strong></td></tr><tr><td>write(s)</td><td>把字符串 s 的内容写入文件</td></tr><tr><td>writelines(s)</td><td>向文件写入一个元素为字符串的列表，如果需要换行则要自己加入每行的换行符。</td></tr><tr><td>seek(off, whence=0)</td><td>设置文件当前位置</td></tr><tr><td>tell()</td><td>返回文件读写的当前位置</td></tr><tr><td>close()</td><td>关闭文件。关闭后文件不能再进行读写操作。</td></tr></tbody></table><h4 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h4><blockquote><p><strong>文本文件内容（hello.txt）：</strong></p><p>Hello, I am emptinessboy! 你好，我是 emptinessboy!</p></blockquote><p><strong>文本方式打开：</strong></p><pre><code class="python">textfile1 = open(&quot;hello.txt&quot;,&quot;rt&quot;,encoding=&quot;utf-8&quot;)  # 打开文件（文本方式）t = textfile1.readline() # 读取文件print(t)    # 处理数据（打印文件）textfile1.close()   # 关闭文件&gt;&gt;&gt; Hello, I am emptinessboy!   你好，我是 emptinessboy!</code></pre><p><strong>二进制方式打开：</strong></p><pre><code class="python">textfile2 = open(&quot;hello.txt&quot;,&quot;rb&quot;)  # 打开文件（二进制方式）t = textfile2.readline() # 读取文件print(t)    # 处理数据（打印文件）textfile2.close()   # 关闭文件&gt;&gt;&gt; b&#39;Hello, I am emptinessboy!   \xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8c\xe6\x88\x91\xe6\x98\xaf emptinessboy!\r\n&#39;</code></pre><p><a href="https://up.media.everdo.cn/image/R8Aj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-read-file.png" alt="python-read-file.png"></a></p><h5 id="文件复制-demo"><a href="#文件复制-demo" class="headerlink" title="文件复制 demo"></a>文件复制 demo</h5><p>复制文件不需要考虑行结构，用 read 函数就可以了。这里将 hello.txt 复制为 hello_copy.txt</p><pre><code class="python">source1 = open(&quot;hello.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) # UTF-8模式读取原始文件并，赋给对象source1source2 = open(&quot;hello_copy.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;) # UTF-8模式读创建待写入文件并，赋给对象source2s1 = source1.read() # 从文件1读取所有内容source2.write(s1) # 写入内容source2.close() # 关闭文件流source1.close()</code></pre><p><a href="https://up.media.everdo.cn/image/RaEO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-filecp.png" alt="python-filecp.png"></a></p><p>从复制后的文件可以看到，复制后的行结构没用改变</p><h4 id="多行文件读写"><a href="#多行文件读写" class="headerlink" title="多行文件读写"></a>多行文件读写</h4><p>多行文件读写</p><p>用 readlines() 读写多行文件，用嵌套列表存放多行内容</p><pre><code class="python">f=open(&quot;score.txt&quot;,&quot;r&quot;)    for line in f.readlines():        print(line) #处理行f.close()</code></pre><h5 id="多行文本读取-demo"><a href="#多行文本读取-demo" class="headerlink" title="多行文本读取 demo"></a>多行文本读取 demo</h5><p>我们尝试读取下刚才的 hello_copy.txt</p><pre><code class="python">f1 = open(&quot;hello_copy.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)  # utf-8模式打开文件f2 = f1.readlines()  # 将多行变成列表（数组）print(f2)for l in f2:    print(l, end=&quot;&quot;)f1.close()&gt;&gt;&gt; [&#39;Hello, I am emptinessboy!   你好，我是 emptinessboy!\n&#39;, &#39;Hello, I am emptinessboy!   你好，我是 emptinessboy!\n&#39;, &#39;Hello, I am emptinessboy!   你好，我是 emptinessboy!&#39;]Hello, I am emptinessboy!   你好，我是 emptinessboy!Hello, I am emptinessboy!   你好，我是 emptinessboy!Hello, I am emptinessboy!   你好，我是 emptinessboy!</code></pre><p><strong>实际应用：计算总评分：</strong></p><p>这里先建一个如下格式的文本，用来存放测试信息：</p><p><a href="https://up.media.everdo.cn/image/RuRn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-read-lines-demo.png" alt="python-read-lines-demo.png"></a></p><p>这个案例中，我们使用嵌套列表来存放多行内容：我们计算每一个学生的总评</p><blockquote><p>总评 = 笔试 * 50% + 平时 * 25% + 实验 * 25%</p></blockquote><pre><code class="python">f = open(&quot;score&quot;, &quot;r&quot;,encoding=&quot;utf-8&quot;)head = f.readline()  # 读表头行newhead = head[:-1] + &#39;\t总评成绩&#39;print(newhead)for line in f.readlines(): # 这一步python会从我们刚才读取文件的位置继续往下读取，而不会从头开始    l = line.split() # 将读取的一行字符串继续按空格拆分为嵌套列表    # 例如第一行会变成 [&#39;2050921018&#39;, &#39;詹延峰&#39;, &#39;计算数学&#39;, &#39;65&#39;, &#39;85&#39;, &#39;76&#39;]    s = round(int(l[3]) * 0.5 + int(l[4]) * 0.25 + int(l[5]) * 0.25, 2)  # 求总评分    print(&#39; &#39;.join(l) + &#39; &#39; + str(s))  # 加空格对齐f.close()</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/j4WS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-read-lines-result.png" alt="python-read-lines-result.png"></a></p><h4 id="文件操作拆解"><a href="#文件操作拆解" class="headerlink" title="文件操作拆解"></a>文件操作拆解</h4><pre><code class="python">f = open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)  # 默认就是r模式 read模式 只读模式&quot;&quot;&quot;在打开文本文件的时候如果你不指定编码，那么编码就依据当前操作系统的默认编码windows     GBKlinux       utf8Mac         ASCII&quot;&quot;&quot;# f是一个文件对象 调用文件对象的一些方法就能够操作该文件data = f.read()f.close()  # 向操作系统发起关闭文件的请求 回收资源&quot;&quot;&quot;打开一个文件包含两部分资源，应用程序的变量 f 和操作系统打开的文件。在操作完毕一个文件之后必须把与该文件的这两部分资源回收变量 f 是python程序里面不需要你回收（python有自动的垃圾回收机制）open 打开的资源存在与操作系统中（需要手工回收）&quot;&quot;&quot;</code></pre><h3 id="with-open-取代-open"><a href="#with-open-取代-open" class="headerlink" title="with open 取代 open"></a>with open 取代 open</h3><p>with 用来创建临时运行环境</p><p>作用：with用于创建一个临时的运行环境，运行环境中的代码执行完后自动安全退出环境。</p><p>文件操作：使用 ope n进行文件操作使建议使用 with 创建运行环境，可以不用 close() 方法关闭文件，无论在文件使用中遇到什么问题都能安全的退出，即使发生错误，退出运行时环境时也能安全退出文件并给出报错信息。</p><p><strong>关键字 with 用于上下文管理（推荐使用）</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    data = f.read()&quot;&quot;&quot;在执行完with代码块之后 with会自动帮你调用close方法&quot;&quot;&quot;# with一次性打开多个文件with open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f1,\        open(&#39;b.txt&#39;,&#39;r&#39;) as f2:    pass</code></pre><h4 id="文件的操作模式"><a href="#文件的操作模式" class="headerlink" title="文件的操作模式"></a>文件的操作模式</h4><h5 id="r-模式（read）"><a href="#r-模式（read）" class="headerlink" title="r 模式（read）"></a>r 模式（read）</h5><p>r 模式打开文件 文件必须存在否则直接报错。基本格式如下：</p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    pass# 例如：    with open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    data = f.read()  # 读取文件内所有的内容    print(data)</code></pre><p>基于 r 模式，实现用户认证功能，文件作为数据库：</p><pre><code class="python">username = input(&#39;&gt;&gt;&gt;:&#39;).strip()password = input(&#39;&gt;&gt;&gt;:&#39;).strip()with open(&#39;userinfo&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    for line in f:  # f文件对象可以被for循环 类似于一行行的读取文件内容        # 切割字符串        usr, pwd = line.strip(&#39;\n&#39;).split(&#39;|&#39;)        if username == usr and password == pwd:            print(&#39;登陆成功&#39;)            # 只要验证成功了 for循环就没有必要再执行了            break    else:        print(&#39;用户名或密码错误&#39;)</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/jHSQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-file-r.png" alt="python-file-r.png"></a></p><h5 id="w-模式（write）"><a href="#w-模式（write）" class="headerlink" title="w 模式（write）"></a>w 模式（write）</h5><p>w 模式下文件不存在，也不会报错，反而会自动创建该文件。因此 w 模式一定要慎用，文件路径前面最好加一个 r 取消转义</p><ol><li>先清空目标文件</li><li>才是写入内容</li></ol><p>基本格式如下：</p><pre><code class="python">with open(r&#39;b.txt&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    pass# 文件路径取消转义with open(r&#39;b.txt&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    pass</code></pre><p><strong>简单写入案例：</strong></p><pre><code class="python">with open(&#39;filew&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    f.write(&#39;你追我...\n&#39;)    f.write(&#39;你追我...\n&#39;)    f.write(&#39;你追我...\n&#39;)    f.write(&#39;heiheihei 666\n&#39;)# f.close 在 with 模式下可以不写</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/jIey" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-file-w-1.png" alt="python-file-w-1.png"></a></p><p>1.在文件不关闭的情况下 连续的写入，后写的内容一定跟在前写的内容后面</p><p>2.如果重新以w模式打开文件，则会先清空该文件</p><h5 id="a-模式（append）"><a href="#a-模式（append）" class="headerlink" title="a 模式（append）"></a>a 模式（append）</h5><p>a 模式下文件不存在，也会自动创建该文件。文件存在的情况下 a 模式打开之后文件指针会直接移动到文件末尾。</p><pre><code class="python">with open(&#39;c.txt&#39;,&#39;a&#39;,encoding=&#39;utf-8&#39;) as f:    passwith open(&#39;c.txt&#39;,&#39;a&#39;,encoding=&#39;utf-8&#39;) as f:    f.write(&#39;11111\n&#39;)    f.write(&#39;22222\n&#39;)</code></pre><p>基于 a 模式实现用户的注册功能：</p><pre><code class="python">username = input(&#39;&gt;&gt;&gt;:&#39;).strip()password = input(&#39;&gt;&gt;&gt;:&#39;).strip()with open(&#39;userinfo.txt&#39;,&#39;a&#39;,encoding=&#39;utf-8&#39;) as f:    res = &#39;%s|%s\n&#39;%(username,password)    f.write(res)</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/jhMd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/10/17/python-file-a.png" alt="python-file-a.png"></a></p><h5 id="模式"><a href="#模式" class="headerlink" title="+ 模式"></a>+ 模式</h5><p><strong>Python 读写文件模式</strong>：在生产环境中我们只单纯的使用 r/w/a 读写分离，一般不用 +</p><ol><li><strong>r</strong> 打开只读文件，该文件必须存在。</li><li><strong>r+</strong> 打开可读写的文件，该文件必须存在。</li><li><strong>w</strong> 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</li><li><strong>w+</strong> 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li><li><strong>a</strong> 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。</li><li><strong>a+</strong> 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。</li><li>上述的形态字符串都可以再加一个 b 字符，如 rb、w+b 或 ab+ 等组合，加入 b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在 POSIX 系统，Linux 都会忽略该字符。</li></ol><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><strong>最好先判断是否可读写：</strong></p><pre><code class="python">print(f.readable())  # 判断当前是否可读print(f.writable())  # 判断当前是否可写</code></pre><p>读取文本文件的几种方法：</p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;rt&#39;,encoding=&#39;utf-8&#39;) as f:    # 法一：    # 全部读取  当文件内容过大的时候 该方法可能会导致内存溢出    # 该方法执行完毕之后文件的指针会移动到文件末尾    data = f.read()    # 法二：    # 读取一行内容 指针会移动到第二行的首部    data = f.readline()    # 法三：    # 读取每一行内容 存放于列表中 当文件过大的情况下也不推荐使用    data = f.readlines()    # 法四（推荐）：    # 我们在读取文件内容的时候 一般都是用for循环    for line in f:        print(line)</code></pre><p>写入文本文件的推荐方法：</p><p>Python_write和writelines的区别</p><ol><li>write()需要传入一个字符串做为参数,否则会报错</li><li>writelines()既可以传入字符串又可以传入一个字符序列,并将该字符序列写入文件<ul><li>注意 ：writelines必须传入的是字符序列,不能是数字序列。</li><li>错误写法如：list_1023 = [1,2,3,4,5]</li></ul></li></ol><pre><code class="python">with open(&#39;b.txt&#39;,&#39;wt&#39;,encoding=&#39;utf-8&#39;) as f:    f.write(&#39;111&#39;)    f.writelines([&#39;aaa\n&#39;,&#39;bbb\n&#39;,&#39;ccc\n&#39;])    # 立刻将内存数据刷到硬盘 类似于ctrl+s    f.flush()</code></pre><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><p>有两种方法可以实现文件修改：</p><ol><li>将文件内容全部读取到内存 在内存中修改完毕之后覆盖原来的内容</li><li>重新创建一个新文件 然后将老文件内容一行行读取到内存修改之后写入新文件<br>之后将老文件删除 将新文件名修改为老文件名 完成替换</li></ol><p><strong>适用于小文件：</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    data = f.read()with open(&#39;a.txt&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    f.write(data.replace(&#39;tony&#39;,&#39;jason&#39;)) #替换</code></pre><p>上面的方法在文件修改过程中同一份数据只有一份。文件过大的时候比较吃资源。</p><p><strong>适用于大文件：</strong></p><pre><code class="python">import oswith open(&#39;a.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as read_f,\    open(&#39;a.backend.txt&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as write_f:    for line in read_f:        write_f.write(line.replace(&#39;tony&#39;,&#39;jason&#39;)) #替换os.remove(&#39;a.txt&#39;)os.rename(&#39;a.backend.txt&#39;,&#39;b.txt&#39;)</code></pre><p>这种方法不会占用太多的内存，不过在文件修改的时候同一份数据存了两份 比较消耗硬盘空间</p><h3 id="主动控制文件内指针移动"><a href="#主动控制文件内指针移动" class="headerlink" title="主动控制文件内指针移动"></a>主动控制文件内指针移动</h3><p>大前提：文件内指针的移动都是 bytes 为单位，唯一列外的是 t 模式下的 read(n)，n 是以字符串为单位。</p><pre><code class="python"># 字符模式with open(&#39;a.txt&#39;,&#39;rt&#39;,encoding=&#39;utf-8&#39;) as f:    data = f.read(3)  # 读取三个字符    print(data)# 字节模式with open(&#39;a.txt&#39;,&#39;rb&#39;) as f:    data = f.read(3)  # 读取三个字节    print(data)</code></pre><h4 id="用-seek-控制指针"><a href="#用-seek-控制指针" class="headerlink" title="用 seek 控制指针"></a>用 seek 控制指针</h4><p>控制指针移动有三种模式，语法如下：</p><pre><code class="python">seek(指针移动的字节数，模式)</code></pre><ul><li>0 模式：以文件开头作为移动的参照</li><li>1 模式：以指针当前位置作为移动的参照</li><li>2 模式：以文件末尾作为移动的参照</li></ul><blockquote><p>其中 0 模式以在 t 和 b 下使用，而 1 和 2 模式只能在b模式下使用</p></blockquote><p>测试文件如下：</p><pre><code class="python"># a.txt哈哈哈1234567890abcdefghijklmnopqrstuvwxyz吼</code></pre><p><strong>读取三个字符：</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;rt&#39;,encoding=&#39;utf-8&#39;) as f:    data = f.read(3)  # 读取三个字符    print(data)&gt;&gt;&gt; 哈哈哈</code></pre><p><strong>读取三个字节：</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;rb&#39;) as f:    data = f.read(3)  # 读取三个字节    print(data)&gt;&gt;&gt; b&#39;\xe5\x93\x88&#39;</code></pre><p><strong>光标向后移动三个字节：（t模式）</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;rt&#39;,encoding=&#39;utf-8&#39;) as f:    f.seek(3,0)  # utf8用一个 bytes 表示英文 3个 bytes 表示中文    print(f.tell())  # 查看当前文件指针距离文件开头的位置 结果是3    print(f.read())&gt;&gt;&gt; 3哈哈1234567890abcdefghijklmnopqrstuvwxyz吼</code></pre><p><strong>光标向后移动六个字节：（b模式）</strong></p><pre><code class="python">with open(&#39;a.txt&#39;,&#39;rb&#39;) as f:    f.seek(6,0)    print(f.read().decode(&#39;utf-8&#39;))&gt;&gt;&gt; 哈1234567890abcdefghijklmnopqrstuvwxyz吼</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习笔记04（函数）</title>
      <link href="/2020/07/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89/"/>
      <url>/2020/07/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>函数是重用的程序段。它们允许你给一段语句命名一个名字。<em>函数的使用必须遵循先定义后调用的原则</em></p><p>定义函数的语法结构：</p><pre><code class="python">def 函数名(参数1，参数2，参数3...):  &quot;&quot;&quot;函数注释&quot;&quot;&quot;  # 函数体代码(函数的功能)  return 返回值</code></pre><blockquote><p>1.def 定义函数的关键字<br><br>2.函数名 函数名指向函数内存地址 是对函数体代码的引用<br><br>3.括号 括号内定义参数 参数可有可无 且无需指定参数类型<br><br>4.冒号 括号后必须加冒号 然后在下一行开始需要缩进书写函数体代码<br><br>5.函数注释 描述函数的功能 参数介绍 非必要建议加上 增加代码的可读性<br><br>6.函数体代码 整个函数功能的核心代码<br><br>7.return 函数的返回值 可有可无<br></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="python"># 1.无参函数def index():  print(123)# 2.有参函数def index(x,y):  print(123)# 3.空函数def index():    pass</code></pre><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>函数定义的另一种方法是用 lambda 表达式，它定义了一个 <strong>匿名函数</strong>。lambda 的一般形式是关键字 lambda 后面跟一个或多个参数，紧跟一个冒号，后面是一个表达式。作为表达式，lambda 返回一个值。lambda 用来编写简单的函数，而def 用来处理更强大任务的函数。</p><pre><code class="python">#把lambda定义的匿名函数赋给函数gg = lambda x,y,z : x+y+zprint（g(1,4,5)）&gt;&gt;&gt; 10</code></pre><h2 id="函数的调用与返回值"><a href="#函数的调用与返回值" class="headerlink" title="函数的调用与返回值"></a>函数的调用与返回值</h2><ol><li>函数没有return关键字的时候 默认返回的都是None</li><li>return 后面什么都不写 返回的还是None</li><li>return 后面写内容 写什么就返回什么<br><br></li><li>return 返回多个元素 会自动组成元组的形式返回</li><li>函数体代码一旦遇到 return 会立刻结束</li><li>return 可以返回多个任意类型的元素</li></ol><pre><code class="python">def index():    a = 123    b = &quot;456&quot;    c = [7,8,9]    d = (10,11,12)    return a,b,c,dprint(index())&gt;&gt;&gt; (123, &#39;456&#39;, [7, 8, 9], (10, 11, 11))</code></pre><ol start="7"><li>return 返回值的解压赋值</li></ol><pre><code class="python">aa,bb,cc,dd = index()print(aa,bb,cc,dd)&gt;&gt;&gt; 123 456 [7, 8, 9] (10, 11, 12)</code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><ul><li>参数在函数定义的圆括号内指定，用逗号分割</li><li>函数定义时的参数称为形参，这些参数就像变量一样</li><li>当我们调用函数的时候，函数中的参数值称为实参</li><li>函数形参取得的值是你调用函数时提供的实参</li></ul><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><blockquote><p>位置参数是按照顺序定义的参数。</p></blockquote><p>定义阶段按照从左到右的顺序依次定义形参，叫位置形参，但凡是按照这种形式定义的形参都必须在调用的时候被传值</p><pre><code class="python">def index(x,y):   print(x,y)index(111,222)&quot;&quot;&quot;会按照位置顺序依次给形参赋值x = 111y = 222&quot;&quot;&quot;&gt;&gt;&gt; 111 222</code></pre><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>为了避免位置参数严格的位置要求，调用参数时可以指定对应形式参数的名字，这是关键字参数，它甚至可以采用与函数定义时不同的顺序。</p><pre><code class="python">def index(x,y):   print(x,y)index(y=1,x=2)  # 指名道姓的传&gt;&gt;&gt; 2 1</code></pre><h3 id="位置参数和关键字参数混合："><a href="#位置参数和关键字参数混合：" class="headerlink" title="位置参数和关键字参数混合："></a>位置参数和关键字参数混合：</h3><p>如果同时出现两种参数形式， 首先应该写的是位置参数，然后是关键字参数</p><pre><code class="python">def index(x1,y1,x2,y2):   print(x1,y1,x2,y2)index(111,222,y2=333,x2=444)# 这一步 x2 = 44 ,y2 = 333 覆盖了原先的顺序赋值&gt;&gt;&gt; 111 222 444 333</code></pre><p><strong>下面程序出错：</strong></p><pre><code class="python">def index(x1,y1,x2,y2):   print(x1,y1,x2,y2)index(111,222,y2=333,444)# 这一步 x2 = 44 ,y2 = 333 覆盖了原先的顺序赋值&gt;&gt;&gt; File &quot;&lt;input&gt;&quot;, line 1 SyntaxError: positional argument follows keyword argument</code></pre><h3 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h3><p>当调用方没有提供对应形式参数的值时，你可以指定默认形式参数值。如果你供 实参， 在调用时会代替默认值</p><pre><code class="python">def register(name, sex=&#39;male&#39;):    print(name, sex)register(&#39;EmptinessBoy&#39;)  # 用默认的参数register(&#39;XiaoHong&#39;, &#39;female&#39;)  # 传递参数覆盖默认参数&gt;&gt;&gt; EmptinessBoy maleXiaoHong female</code></pre><p><strong>默认参数值在函数对象被创建时计算：</strong></p><pre><code class="python">def init(arg, result=[]):    result.append(arg)    print(result)init(&quot;a&quot;)init(&quot;b&quot;)init(&quot;c&quot;)init(1, [2])# 因为函数对象只创建一次，所以后两次用的形参 result 值没有被改变&gt;&gt;&gt; [&#39;a&#39;][&#39;a&#39;, &#39;b&#39;][&#39;a&#39;, &#39;b&#39;, &#39;c&#39;][2, 1]</code></pre><h3 id="数量可变参数"><a href="#数量可变参数" class="headerlink" title="数量可变参数"></a>数量可变参数</h3><p><strong>参数值的元组 <code>*</code></strong></p><p>当函数参数数目不确定时 星号将一组可变数量的位置参数集合成参数值的元组 <code>*</code> 号会接受多余的位置参数 组织成元组的形式赋值给 <code>*</code> 号后面的变量名</p><p><strong>收集参数到字典 ```</strong>```**</p><p><code>**</code> 号会接受多余的关键字参数 组织成字典的形式赋值给 <code>**</code> 号后面的变量名</p><pre><code class="python">def index(x, y, *a, **k):    print(a, end=&quot; &quot;)    print(k)index(111, 222)index(111, 222, 333, 444)  # a = (333, 444)index(111, 222, n=1, m=2, o=3)  # k = {&#39;n&#39;: 1, &#39;m&#39;: 2, &#39;o&#39;: 3}index(111, 222, 333, 444, n=1, m=2, o=3)  # a = (333, 444)  # k = {&#39;n&#39;: 1, &#39;m&#39;: 2, &#39;o&#39;: 3}&gt;&gt;&gt; () {}(333, 444) {}() {&#39;n&#39;: 1, &#39;m&#39;: 2, &#39;o&#39;: 3}(333, 444) {&#39;n&#39;: 1, &#39;m&#39;: 2, &#39;o&#39;: 3}</code></pre><p>函数在定义阶段 针对可变长的形参 推荐按照以下命名方式:</p><pre><code class="python">def index(*args,**kwargs):    pass</code></pre><h3 id="实参拆包"><a href="#实参拆包" class="headerlink" title="实参拆包"></a>实参拆包</h3><p><strong>在实参中的作用：</strong></p><p><code>*</code> 号会将列表打散成位置参数的形式 <code>**</code> 号会将字典打散成关键字参数的形式</p><pre><code class="python">l = [1,2,3,4,5,6,7,8]index(*l)# 或者index(*[1,2,3,4,5,6,7,8])# 等价于 index(1,2,3,4,5,6,7,8)k = {&#39;username&#39;:&#39;jason&#39;,&#39;password&#39;:&#39;123&#39;}index(**k)# 或者index(**{&#39;username&#39;:&#39;jason&#39;,&#39;password&#39;:&#39;123&#39;})# 等价于 index(username=&#39;jason&#39;,password=&#39;123&#39;)</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>可变对象和不可变对象当参数：(可变对象和不可变对象当参数，效果可能是不同的）</p><blockquote><p>当实参是不可变对象时，形参值改变 会影响实参！</p><p>当实参是可变对象时，形参值改变可能会影响实参！</p></blockquote><h2 id="名称空间与作用域"><a href="#名称空间与作用域" class="headerlink" title="名称空间与作用域"></a>名称空间与作用域</h2><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ol><li><p>变量可被访问范围称为变量的作用域，也称为变量命名空间或变量名字空间。 Python 程序用命名空间区分不同空间的相同名字。</p></li><li><p>Python 解释器启动时建立一个全局命名空间，全局变量就放在这个空间,还建立内置命名空间 (built-in namespace)，记录所有标准常量名、标准函数名等。在全局命名空间中定义的变量是全局变量。</p></li><li><p>每一个函数定义自己的命名空间，函数内部定义的变量是局部变量。如果在一个函数中定义一个变量 x，在另外一个函数中也定义 x 变量，因为是在不同的命名空间，所以两者指代的是不同的变量。可以通过多种方式获取其他命名空间的变量。</p></li></ol><blockquote><p>内置名称空间：</p><p>伴随着 python 解释器的启动(创建)，结束(销毁)，因为是第一个被加载的名称空间，该名称空间中存放了很多提前给你写好的名字，比如内置函数/方法 max min len</p></blockquote><blockquote><p>全局名称空间：</p><p>伴随着 py 文件的执行(创建),结束(销毁)，是第二个被加载的名称空间，文件执行过程中产生的名字会存放于该名称空间内</p></blockquote><pre><code class="python">import datetime  # 模块名name = &#39;jason&#39;  # 变量名if name == &#39;jason&#39;:    x = 1  # 变量名def index():  # 函数名    passclass MyClass:  # 类名    pass</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="对象的查找顺序"><a href="#对象的查找顺序" class="headerlink" title="对象的查找顺序"></a>对象的查找顺序</h4><p><strong>局部名称空间 &gt;&gt;&gt; 全局名称空间 &gt;&gt;&gt; 内置名称空间</strong></p><ul><li><p>在局部名称空间</p><ol><li>先在局部名称空间中找</li><li>再去全局名称空间中找</li><li>再去内置名称空间中找</li></ol></li><li><p>在全局名称空间</p><ol><li>现在全局名称空间中找</li><li>内置名称空间中找</li></ol></li></ul><pre><code class="python">x = 100def index():    x = 300    print(x)  # 300    print(locals())  # 查看局部作用域中的名字index()print(x)  # 100print(globals())  # 查看全局作用域中的名字&gt;&gt;&gt; 300{&#39;x&#39;: 300}100{&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001F7E6F40940&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;__file__&#39;: &#39;G:/NextCloud/Documents/代码操练/Python/01/eg6.py&#39;, &#39;__cached__&#39;: None, &#39;x&#39;: 100, &#39;index&#39;: &lt;function index at 0x000001F7E6F251F0&gt;}</code></pre><h3 id="通过关键字互相访问"><a href="#通过关键字互相访问" class="headerlink" title="通过关键字互相访问"></a>通过关键字互相访问</h3><h4 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h4><p>如希望在函数中使用全局变量，而不是创建局部变量，需要用 global 关键字声明</p><pre><code class="python">x = 100def index():    # 修改全局的x    global x    x = 300    print(x)  # 300&gt;&gt;&gt; 300</code></pre><h4 id="nonlocal-关键字"><a href="#nonlocal-关键字" class="headerlink" title="nonlocal 关键字"></a>nonlocal 关键字</h4><p>python 支持函数的嵌套，在嵌套的函数内查找名字时， 会优先查找自己局部作用域的名字然后由内而外一层层查找外部嵌套函数定义的作用域，没有找到则去找全局</p><p>nonlocal 声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。</p><pre><code class="python">def outer():    x = 1    def inner():        nonlocal x        x = 2        # 在inner的局部修改outer的局部        print(&#39;inner&#39;,x)  # inner 2    inner()    print(&#39;outer&#39;,x)  # outer 2outer()&gt;&gt;&gt; inner 2outer 2</code></pre><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><h4 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted 函数"></a>sorted 函数</h4><p>sorted 函数对字符串，列表，元组，字典等对象进行排序操作。</p><p>.sort 是应用在 list 上的方法，sorted 可以对更多的数据类<br>型进行排序操作。</p><blockquote><p>即便都是对列表操作，list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 返回的是一个新的 list，而不是在原来的基础上进行的操作。</p></blockquote><p>sorted (iterable, key, reverse)</p><table><thead><tr><th>参数</th><th>内容</th></tr></thead><tbody><tr><td>iterable</td><td>– 序列，如字符串，列表，元组等。</td></tr><tr><td>key</td><td>– 函数，缺省为空</td></tr><tr><td>reverse</td><td>– 排序规则</td></tr><tr><td>reverse</td><td>= True 降序 ， reverse = False 升序（默认）。</td></tr></tbody></table><p><strong>例子（多元列表排序）：</strong></p><p><a href="https://up.media.everdo.cn/image/7r5n" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/07/08/python-sorted.jpg" alt="python-sorted.jpg"></a></p><pre><code class="python">students = [(&#39;江幸&#39;, 89, 15), (&#39; 方鹏&#39;, 80, 14), (&#39;陈可&#39;, 85, 14)]# 第二个分量是成绩，第三个分量是年龄print(sorted(students, key=lambda s: s[2]))  # 按年龄从小到大排序# [(&#39; 方鹏&#39;, 80, 14), (&#39;陈可&#39;, 85, 14), (&#39;江幸&#39;,89, 15)]print(sorted(students, key=lambda s: s[1], reverse=True))  # 按成绩从大到小降序# [(&#39;江幸&#39;, 89, 15), (&#39;陈可&#39;, 85, 14), (&#39; 方鹏&#39;,80, 14)]&gt;&gt;&gt; [(&#39; 方鹏&#39;, 80, 14), (&#39;陈可&#39;, 85, 14), (&#39;江幸&#39;, 89, 15)][(&#39;江幸&#39;, 89, 15), (&#39;陈可&#39;, 85, 14), (&#39; 方鹏&#39;, 80, 14)]</code></pre><h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><ul><li>map 会根据提供的函数对指定序列做映射。</li><li>map 函数语法：map(function, iterable, …)</li><li>第一个参数 function 是对参数序列中的每一个元素调用 function 函数，iterable 是序列，</li><li>返回值的新列表或迭代器，每个元素是调用 function 函数的返回值</li></ul><h4 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h4><ul><li>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表或迭代器 。</li><li>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</li><li>zip 语法：zip([iterable, …])</li></ul><p>参数说明：iterable,… –两个或多个序列返回值：返回元组列表</p><p><strong>例子：</strong></p><pre><code class="python">a = [1, 2, 3]b = [4, 5, 6]c = [4, 5, 6, 7, 8]print(list(zip(a, b)))# [(1, 4), (2, 5), (3, 6)]print(list(zip(a, c)))  # 元素个数与最短的列表一致# [(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt;[(1, 4), (2, 5), (3, 6)][(1, 4), (2, 5), (3, 6)]</code></pre><h4 id="eval-和-exec函数"><a href="#eval-和-exec函数" class="headerlink" title="eval 和 exec函数"></a>eval 和 exec函数</h4><p>Python 是一种动态语言，它包含很多含义。Python 变量类型，操作的合法性检查都在动态运行中检查；运算的代码需要到运行时才能动态确定；程序结构也可以动态变化，容许动态加载新模块等。这两个函数就体现了这个特点。</p><ul><li>eval 是计算表达式,返回表达式的值。</li><li>exec 可运行Python的程序,返回程序运行结果。</li></ul><pre><code class="python">x, y = 3, 7eval(&#39;x+3*y-4&#39;)# 20exec(&#39;print(&quot;hello world&quot;)&#39;)# Hello world&gt;&gt;&gt; hello world</code></pre><h4 id="all-和-any-函数"><a href="#all-和-any-函数" class="headerlink" title="all 和 any 函数"></a>all 和 any 函数</h4><p>all() 和 any() 函数将可迭代的对象作为参数 。</p><p>all 函数参数都是 True 时 ，才返回 True 否则返回 False<br>any 函数参数只要有一个为 True ，就返回 True, 参数全部是 False 时，返回 False.</p><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>函数名可以被当作“数据”来处理，具体的可以分为以下四个应用：（函数名加括号执行优先级最高）</p><h3 id="四种函数对象特性"><a href="#四种函数对象特性" class="headerlink" title="四种函数对象特性"></a>四种函数对象特性</h3><h4 id="函数名被引用"><a href="#函数名被引用" class="headerlink" title="函数名被引用"></a>函数名被引用</h4><p>让一个变量等于函数名后，这个变量对应的地址和函数对应的地址一致，可以直接调用新定义的变量加括号来执行函数体内容</p><pre><code class="python">def index():    print(&#39;from index&#39;)print(index)  # &lt;function index at 0x000001B260AE51F0&gt;x = indexprint(x)  # &lt;function index at 0x000001B260AE51F0&gt;# 运行 xx()  # from index&gt;&gt;&gt; &lt;function index at 0x00000289BDDA51F0&gt;&lt;function index at 0x00000289BDDA51F0&gt;from index</code></pre><h4 id="函数名作为容器类型的元素"><a href="#函数名作为容器类型的元素" class="headerlink" title="函数名作为容器类型的元素"></a>函数名作为容器类型的元素</h4><p>可以将函数名存放到列表，元组，字典，集合等数据容器中并进行调用</p><pre><code class="python">def index():    print(&#39;from index&#39;)d = {&#39;username&#39;:&#39;apple&#39;,&#39;func&#39;:index}print(d)  # {&#39;username&#39;: &#39;jason&#39;, &#39;func&#39;: &lt;function index at 0x0000025C266251F0&gt;}d.get(&#39;func&#39;)()  # from indexd[&#39;func&#39;]()&gt;&gt;&gt; {&#39;username&#39;: &#39;apple&#39;, &#39;func&#39;: &lt;function index at 0x0000017B4EFD51F0&gt;}from indexfrom index</code></pre><h4 id="函数名还当作函数的参数"><a href="#函数名还当作函数的参数" class="headerlink" title="函数名还当作函数的参数"></a>函数名还当作函数的参数</h4><pre><code class="python">def index():    print(&#39;from index&#39;)def foo(a,b):    print(a)    b()foo(1,index)&gt;&gt;&gt; 1from index</code></pre><h4 id="函数名当作函数的返回值"><a href="#函数名当作函数的返回值" class="headerlink" title="函数名当作函数的返回值"></a>函数名当作函数的返回值</h4><pre><code class="python">def index():    print(&#39;from index&#39;)def foo():    print(&#39;from foo&#39;)    return indexres = foo()res()&gt;&gt;&gt; from foofrom index</code></pre><h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><p>根据上述函数对象的特性，我们可以用来组装闭包函数。那么闭包函数的定义如下：</p><ol><li>必须是定义在函数内部的函数</li><li>内部函数必须使用了外部函数名称空间/作用域的名字</li></ol><pre><code class="python">def index():    name = &#39;emptinessboy&#39;    def inner():  # 闭包函数        print(name)</code></pre><p>闭包函数的出现给我们提供了另外一种给函数体传参的方式</p><pre><code class="python">#闭包函数，其中 exponent 称为自由变量def nth_power(exponent):    def exponent_of(base):        return base ** exponent    return exponent_of # 返回值是 exponent_of 函数square = nth_power(2) # 计算一个数的平方cube = nth_power(3) # 计算一个数的立方print(square(2))  # 计算 2 的平方print(cube(2)) # 计算 2 的立方</code></pre><p>在python中，函数也是一种对象（万物皆对象！）</p><ul><li>函数可以赋值给一个变量</li><li>函数可以定义在另一个函数内部</li></ul><p><strong>这也意味着一个函数可以返回另一个函数</strong></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote><p>这里结合上课老师讲的，并参考了一篇文章：<a href="https://www.jianshu.com/p/fd746acbdf1e" target="_blank" rel="noopener">https://www.jianshu.com/p/fd746acbdf1e</a></p></blockquote><p>装饰器在不改变被装饰对象 (函数…) 原来的调用方式和内部原代码的情况下给该对象 (函数…) 添加新的功能</p><pre><code class="python"># 知识点import time  # 操作时间的模块# 1.获取1970 到执行代码的那一刻所经历的秒数  时间戳print(time.time())  # 1593501513.9230678# 2.让程序原地阻塞time.sleep(2)  # 让程序阻塞2秒之后再运行</code></pre><h4 id="装饰器推导流程"><a href="#装饰器推导流程" class="headerlink" title="装饰器推导流程"></a>装饰器推导流程</h4><h5 id="A-封装成函数："><a href="#A-封装成函数：" class="headerlink" title="A 封装成函数："></a>A 封装成函数：</h5><p>此方法把目标函数作为参数传入父函数，改变了原函数的调用方式，不符合装饰器定义。</p><pre><code class="python">def get_time(func):    start_time = time.time()    func()    end_time = time.time()    print(&#39;耗时:%s&#39;%(end_time-start_time))get_time(home)get_time(index)</code></pre><p>测试代码：</p><pre><code class="python">def home():    for i in range(10):        time.sleep(1)        print(i,end=&quot; &quot;)    print(&quot;\n%d from home&quot; %(i))a = get_time(home)print(a)&gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9 9 from home耗时:10.111440420150757None #可以看到 a 是空</code></pre><h5 id="B-利用闭包函数给函数传参-装饰器雏形："><a href="#B-利用闭包函数给函数传参-装饰器雏形：" class="headerlink" title="B 利用闭包函数给函数传参 装饰器雏形："></a>B 利用闭包函数给函数传参 <strong><em>装饰器雏形</em></strong>：</h5><pre><code class="python">def outer(func):  # 传入参数为函数    def get_time():        start_time = time.time()        func()  # 执行传入的函数体        end_time = time.time()        print(&#39;耗时:%s&#39;%(end_time-start_time))    return get_time</code></pre><p>测试代码：</p><pre><code class="python">def home():    for i in range(10):        time.sleep(1)        print(i,end=&quot; &quot;)    print(&quot;\n%d from home&quot; %(i))home = outer(home)  # 普通的变量名 home = outer(真正的函数名home)home()  # 现在的 home 已经不是原来的 home 了，变为包装后的，加入了计时的新函数&gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9 9 from home耗时:10.079336404800415</code></pre><p>这一句代码中，将 home 函数作为变量传入 outer 装饰器中，然后 home 方法在 outer 中的函数 get_time() 函数实现，同时包装新的计算时间的功能，将新的函数 get_time() 作为变量返回 ，所以 home 现在已经变成了由 outer 装饰的 get_time() 新方法。</p><h5 id="C-装饰的函数有参数（可变长参数）"><a href="#C-装饰的函数有参数（可变长参数）" class="headerlink" title="C 装饰的函数有参数（可变长参数）"></a>C 装饰的函数有参数（可变长参数）</h5><pre><code class="python">def outer(func):  # 外层函数用来返回内层函数    def get_time(*args, **kwargs):        start_time = time.time()        func(*args, **kwargs)  # 接收参数        end_time = time.time()        print(&#39;耗时:%s&#39; % (end_time - start_time))    return get_time</code></pre><p>测试代码：</p><pre><code class="python">def home(k):    for i in range(k):        time.sleep(1)        print(i,end=&quot; &quot;)    print(&quot;\n%d from home&quot; %(i))home(10)print()home = outer(home) # 普通的变量名home = outer(真正的函数名home)home(10) # 已经不是原来的 home 了，此处已经被装饰&gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9 # 被装饰前原函数运行效果9 from home0 1 2 3 4 5 6 7 8 9 # 被装饰后效果9 from home耗时:10.067564487457275</code></pre><p>所以，装饰器装饰函数的时候，将函数作为变量传入装饰器内部，实际调用的是装饰器内部的函数（添加新功能之后的函数）</p><h3 id="装饰器语法糖"><a href="#装饰器语法糖" class="headerlink" title="装饰器语法糖"></a>装饰器语法糖</h3><p>Python 中装饰器语法并不用每次都用赋值语句。<br>在函数定义的时候就加上 <strong>@+装饰器名字</strong> 即可</p><blockquote><p>这里，我们直接注释上面一个例子的运行代码，使用语法糖重写后运行，可以看到效果是一样的。</p></blockquote><pre><code class="python"># def home(k):#     for i in range(k):#         time.sleep(1)#         print(i,end=&quot; &quot;)#     print(&quot;\n%d from home&quot; %(i))## home(10)# print()## home = outer(home) # 普通的变量名home = outer(真正的函数名home)# home(10) # 已经不是原来的 home 了，此处已经被装饰# @outer 相当于执行 home = outer(home) 会将紧挨着语法糖下面的函数名自动当作第一个参数传递给@后面的函数调用执行@outerdef home(k):    for i in range(k):        time.sleep(1)        print(i,end=&quot; &quot;)    print(&quot;\n%d from home&quot; %(i))home(10)&gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9 9 from home耗时:10.110907077789307</code></pre><h3 id="多层装饰器-装饰器顺序"><a href="#多层装饰器-装饰器顺序" class="headerlink" title="多层装饰器 装饰器顺序"></a>多层装饰器 <strong><em>装饰器顺序</em></strong></h3><p>比如我们有两个装饰器：</p><pre><code class="python">@decorator_one@decorator_twodef hello()    pass</code></pre><p>这句代码实际上类似于：</p><pre><code class="python">hello = decorator_one(decorator_two(hello))</code></pre><p>语法糖在装饰的时候 如果有多个装饰器，那么顺序是 <strong>从下往上</strong> 的。两个装饰器是一层层地往外装饰的。</p><h4 id="补充例子"><a href="#补充例子" class="headerlink" title="补充例子"></a>补充例子</h4><pre><code class="python"># 带参数的装饰器def login_auth(db):    def outer(func):        def inner(*args,**kwargs):            if db == &#39;MySQL&#39;:                res = func(*args,**kwargs)            elif db == &#39;Oracle&#39;:                res = func(*args,**kwargs)            elif db == &#39;postgresql&#39;:                res = func(*args,**kwargs)            else:                res = func(*args,**kwargs)            return res        return inner    return outer# 下面的例子中：# 先执行login_auth(&#39;MySQL&#39;)  # 2.再执行语法糖句式 @outer@login_auth(&#39;MySQL&#39;)def index():    pass</code></pre><h3 id="装饰器模版"><a href="#装饰器模版" class="headerlink" title="装饰器模版"></a>装饰器模版</h3><h4 id="无参装饰器"><a href="#无参装饰器" class="headerlink" title="无参装饰器"></a>无参装饰器</h4><pre><code class="python">def outer(func):  def inner(*args,**kwargs):    print(&#39;执行被装饰对象之前你可以做的操作&#39;)    res = func(*args,**kwargs)    print(&#39;执行被装饰对象之后你可以做的操作&#39;)    return res     return inner</code></pre><h4 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a>有参装饰器</h4><pre><code class="python">def login_auth(*args,**kwargs):    def outer(func):      def inner(*args,**kwargs):        print(&#39;执行被装饰对象之前你可以做的操作&#39;)        res = func(*args,**kwargs)        print(&#39;执行被装饰对象之后你可以做的操作&#39;)        return res         return inner     return outer</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="import-模块名"><a href="#import-模块名" class="headerlink" title="import 模块名"></a>import 模块名</h3><p>模块名是另外一个 Python 文件的文件名,不包含扩展名,模块是可以运行的程序，“import 模块名” 就是执行文件名为模块名的程序</p><h3 id="from-…-import"><a href="#from-…-import" class="headerlink" title="from … import"></a>from … import</h3><p>from 模块名 import *</p><blockquote><p>这种方法引入模块中的所有函数，调用的时候不需要再加模块名</p></blockquote><p>from 模块名 import 函数名</p><blockquote><p>这种方法引入模块中的单个函数，调用的时候也不需要再加模块名</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习笔记03（数据/流程）下</title>
      <link href="/2020/06/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%EF%BC%88%E6%95%B0%E6%8D%AE-%E6%B5%81%E7%A8%8B%EF%BC%89%E4%B8%8B%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2020/06/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%EF%BC%88%E6%95%B0%E6%8D%AE-%E6%B5%81%E7%A8%8B%EF%BC%89%E4%B8%8B%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 [] list"></a>列表 [] list</h3><p>列表内部可以存储多个元素，元素与元素之间逗号隔开，元素可以是任意数据类型</p><pre><code class="python">name_list = [111,11.11,&#39;jason&#39;,[12,3,4,5,6]]name_list = [&#39;jason&#39;, &#39;egon&#39;, &#39;tank&#39;, &#39;sean&#39;, &#39;oscar&#39;]print(name_list[2])  # 索引取值  索引0开始</code></pre><a id="more"></a><h4 id="list-函数"><a href="#list-函数" class="headerlink" title="list() 函数"></a>list() 函数</h4><p>可以使用这个函数把字符串转换为列表</p><h4 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h4><p>可以借助工具：<a href="http://www.pythontutor.com/" target="_blank" rel="noopener">http://www.pythontutor.com/</a></p><p>图中，t2 相当于是指向了 t1 的内存地址，因此操作 t2 的时候，t1 的值被改变了</p><p><a href="https://up.media.everdo.cn/image/7Rc4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-pointer.png" alt="list-pointer.png"></a></p><p><strong>正确拷贝列表：</strong></p><p>可以用切片的方式拷贝一个列表</p><p><a href="https://up.media.everdo.cn/image/7jZM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-cpoy.png" alt="list-cpoy.png"></a></p><p>也可以用 cpoy 类的 cpoy 和 deepcopy 方法</p><p><a href="https://up.media.everdo.cn/image/72RY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-copy.png" alt="list-copy.png"></a></p><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>可以用子序列的方法直接修改列表内值</p><p><a href="https://up.media.everdo.cn/image/7FWa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-modify.png" alt="list-modify.png"></a></p><p>也可以使用同样的方法进行插入</p><p><a href="https://up.media.everdo.cn/image/73Ss" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-append.png" alt="list-append.png"></a></p><p>删除也雷同：</p><p><a href="https://up.media.everdo.cn/image/7DP3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/list-del.png" alt="list-del.png"></a></p><p>当然也可以用 del 命令来删除：</p><pre><code class="python">del t[2:4]</code></pre><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><p>append() 用于追加<strong>一个</strong>列表项：</p><pre><code class="python">&gt;&gt;&gt; t = [1,2,3]&gt;&gt;&gt; t[1, 2, 3]&gt;&gt;&gt; t.append(4)&gt;&gt;&gt; t[1, 2, 3, 4]&gt;&gt;&gt;</code></pre><p>extend() 用于列表后面加一个列表，和 “+” 用法一致</p><blockquote><p>如果使用 append/extend 追加一个列表，那么会形成子列表（二维列表）</p></blockquote><pre><code class="python">&gt;&gt;&gt; t[1, 2, 3, 4]&gt;&gt;&gt; t.append([6,7,8])&gt;&gt;&gt; t[1, 2, 3, 4, [6, 7, 8]]</code></pre><p>insert(&lt;在元素编号前面&gt;,&lt;增加的值&gt;)</p><p>remove(值) 删除对应值的元素</p><p>pop() 出栈，删除并返回指定元素，默认为最后一个</p><p>reverse() 反转列表</p><p>index(‘查找的值’) 查找单个元素第一次在列表出现的位置</p><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><p>推荐的把输入以空格分割的字符串变成数字列表：</p><pre><code class="python"># 法一l = list(map(int,input().split()))# 法二l = input().split(&quot; &quot;)l = [int(l[i]) for i in range(len(l))]</code></pre><h3 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 () tuple"></a>元组 () tuple</h3><p>元组与列表相似 也是可以存储多个任意类型的元素不同之处在于元组的<strong>元素不能被修改</strong>（和字符串一样），即元祖相当于不可变的列表</p><blockquote><p>元组用于记录多个固定不允许修改的值 单纯的用于查看</p></blockquote><h4 id="定义一个元组"><a href="#定义一个元组" class="headerlink" title="定义一个元组"></a>定义一个元组</h4><p>可以直接定义：</p><pre><code class="python"># 定义一个元组&gt;&gt;&gt; p = 3,4&gt;&gt;&gt; p(3, 4)&gt;&gt;&gt;</code></pre><p>标准的是使用圆括号：</p><pre><code class="python">&gt;&gt;&gt; countries = (&#39;中国&#39;,&#39;日本&#39;,&#39;美国&#39;)&gt;&gt;&gt; print(type(countries))&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt;</code></pre><p>只有一个元素时，需要在括号后面加逗号 “,” 否则括号会被忽略。</p><pre><code class="python">names = (&#39;jason&#39;)print(type(names))  # &lt;class &#39;str&#39;&gt;# 元组里面如果只有一个元素 不加逗号的情况下元素是什么类型就是什么类型names = (&#39;jason&#39;,)print(type(names))  # &lt;class &#39;tuple&#39;&gt;</code></pre><blockquote><p>我们在使用可以存储多个数据的数据类型的时候,哪怕只有一个元素 也要习惯性的把逗号加上</p></blockquote><p><code>tuple(&lt;list&gt;)</code> 函数可以把一个列表变成元组</p><h3 id="字典类型-dict"><a href="#字典类型-dict" class="headerlink" title="字典类型 {} dict"></a>字典类型 {} dict</h3><p>字典类型是用 key:value 的形式存储数据 其中 key 就是对 value 的描述性信息 <strong>（字典中的数据是无序的）</strong></p><ul><li>key 一般情况下都是字符串 但是只要key是不可变数据类型都可以</li><li>value 可以是任意数据类型</li></ul><h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><p>用花括号 {} 来表示，每个元素用冒号分隔 键和数据。<strong><em>可以用 {} 或者 dict() 来创建空字典。</em></strong></p><pre><code class="python">### 法一person_info = {&#39;name&#39;:&#39;jason&#39;,&#39;age&#39;:18,&#39;hobby&#39;:[&#39;read&#39;,&#39;DBJ&#39;]}### 法二fac = dict((&quot;math&quot;,&quot;0001&quot;), (&quot;python&quot;,&quot;0002&quot;), (&quot;c&quot;,&quot;0003&quot;)) ### 法三fac = dict(math=&quot;0001&quot;, python=&quot;0002&quot;, c=&quot;00003&quot;)</code></pre><h4 id="运算符操作字典"><a href="#运算符操作字典" class="headerlink" title="[] 运算符操作字典"></a>[] 运算符操作字典</h4><blockquote><p>此方法容易抛出异常</p></blockquote><p><strong>访问值：</strong></p><pre><code class="python">person_info[&#39;name&#39;]</code></pre><p><strong>修改/增加值：</strong></p><pre><code class="python">person_info[&#39;name&#39;] = &quot;emptinessboy&quot;</code></pre><p><strong>删除值：</strong></p><pre><code class="python">del(person_info[&#39;name&#39;])</code></pre><p><strong>遍历字典：</strong></p><p>法1：</p><pre><code class="python">for 键 in 字典:    print(字典[键])</code></pre><pre><code class="python">for a in person_info:    print(person_info[a])</code></pre><p>法2：items() 方法</p><pre><code class="python">for key,value in score.items:    print(key + &#39;:&#39; + str (value))</code></pre><h4 id="函数操作字典"><a href="#函数操作字典" class="headerlink" title="函数操作字典"></a>函数操作字典</h4><p><strong>字典大小：</strong> 用函数 len() 得到字典的条目的数量。</p><p><strong>判断存在：</strong> 用 in 和 not in 运算符检测一个<strong>键</strong>是否在字典中存在。</p><p><strong>完全相同：</strong> 用 == 和 !== 比较 2 个字典是否完全相同（键和值都相同）</p><p><strong>字典方法：</strong></p><table><thead><tr><th>函数</th><th>返回值和说明</th></tr></thead><tbody><tr><td>keys()</td><td>返回由全部的键组成的一个序列</td></tr><tr><td>values()</td><td>返回由全部的值组成的一个序列</td></tr><tr><td>items()</td><td>返回一个序列，其中的每一项是一个元组，每个元组由键和它对应的值组成</td></tr><tr><td>clear()</td><td>删除所有条目</td></tr><tr><td>get(key)</td><td>返回这个键所对应的值</td></tr><tr><td>pop(key)</td><td>返回这个键所对应的值，同时删除这个条目</td></tr></tbody></table><blockquote><p>函数 get() 和运算符 [] 不同之处，在于如果键 key 在字典中不存在，则 get(key) 返回 None 值，而运算符 [] 会抛出 KeyError 异常。</p><p>函数 keys()、values() 和 items() 都是返回一个序列。由于字典中键不重复，所以 keys 和 items 的返回结果可以转换成元组；而 values 返回值由于可能存在重复值，应该转换为列表。</p></blockquote><p>栗子 eg:</p><pre><code class="python">score = {&#39;张三&#39;:78, &#39;李四&#39;:92, &#39;王五&#39;:92}v = list(score.values())print(v)&gt;&gt;&gt; [78, 92, 92]</code></pre><p>get(键，默认值) 函数返回指定键的值，如果值不在字典中，则返回默认值。</p><pre><code class="python">countchar[c] = countchar.get(c,0) + 1</code></pre><h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h3><p>集合是一个无序的容器，使用集合只在下面两种情况下使用</p><ol><li>去重</li><li>关系运算（交叉并集）</li></ol><pre><code class="python"># 直接定义集合se = {1,2,3,4,5,6,7}# 定义空集合se = set()</code></pre><p>set() 函数可以把序列变成集合</p><p><strong>常用方法：</strong></p><table><thead><tr><th>函数</th><th>示例</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>len()</td><td>len(s)</td><td>5</td><td>返回集合中元素的数量</td></tr><tr><td>min()</td><td>min(s)</td><td>2</td><td>返回集合中最小的元素</td></tr><tr><td>max()</td><td>max(s)</td><td>11</td><td>返回集合中最大的元素</td></tr><tr><td>sum()</td><td>sum(s)</td><td>27</td><td>将集合中所有的元素累加起来</td></tr><tr><td>add()</td><td>s.add(13)</td><td>{2,3,5,7,11,13}</td><td>将一个元素加入集合中</td></tr><tr><td>remove()</td><td>s.remove(3)</td><td>{2,5,7,11}</td><td>从集合中删除一个元素，如果这个元素在集合中不存在，则<strong>抛出KeyError异常</strong></td></tr></tbody></table><p>运算符 in 和 not in 用于判断某个元素是否在集合中</p><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><p>如果集合 s1 中的元素，同样都在集合 s2 中，则称 s1 为 s2 的子集，s2 为 s1 的超集。</p><ul><li>使用 s1.issubset(s2) 来判断s1是否为s2的子集。</li><li>使用 s2.issuperset(s1) 来判断s1是否为s2的超集。</li></ul><p>使用关系运算符 == 和 != 判断2个集合是否包含完全相同的元素。</p><p>使用关系运算符 &lt; , &lt;= , &gt; , &gt;= ：</p><ul><li>如果 s1 是 s2 的真子集，则s1&lt;s2是True</li><li>如果 s1 是 s2 的子集，则s1&lt;=s2是True</li><li>如果 s1 是 s2 的真超集，则s1&gt;s2是True</li><li>如果 s1 是 s2 的超集，则s1&gt;=s2是True</li></ul><blockquote><p>s1是s2的真子集的意思是s1是s2的子集，但是s2中至少有一个s1中不存在的元素； s1是s2的真超集的意思是s1是s2的超集，但是s1中至少有一个s2中不存在的元素。</p></blockquote><h4 id="交差并集"><a href="#交差并集" class="headerlink" title="交差并集"></a>交差并集</h4><blockquote><p>假设2个集合：s1 = {2,3,5,7,11},s2 = {2,3,4,5,6,7}，</p></blockquote><table><thead><tr><th>运算</th><th>函数</th><th>运算符</th><th>示例</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>并集</td><td>union()</td><td>|</td><td>s1.union(s2)</td><td>{2,3,4,5,6,7,11}</td><td>结果是包含两个集合中所有元素的新集合</td></tr><tr><td>交集</td><td>intersection()</td><td>&amp;</td><td>s1 &amp; s2</td><td>{2,3,5,7}</td><td>交集是只包含两个集合中都有的元素的新集合</td></tr><tr><td>差集</td><td>difference()</td><td>-</td><td>s1 - s2</td><td>{11}</td><td>s1-s2的结果是出现在s1但不出现在s2的元素的新集合</td></tr><tr><td>对称差</td><td>symmertric_difference()</td><td>^</td><td>s1 ^ s2</td><td>{4,6,11}</td><td>结果是一个除了共同元素之外的所有元素</td></tr></tbody></table><h4 id="去重后顺序"><a href="#去重后顺序" class="headerlink" title="去重后顺序"></a>去重后顺序</h4><p>若要使去重后的元素顺序跟之前一样，如：</p><pre><code class="python">a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;d&#39;,&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]b = list(set(a))# 使B按照A的顺序排序b.sort(key = a.index)</code></pre><p>输出结果</p><pre><code class="python">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><blockquote><p><strong>b.sort(key = a.index)</strong></p><p>这句代码让sort()方法按照a列表中索引顺序进行排列</p></blockquote><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><pre><code class="python">if 逻辑表达式:    语句块1else:    语句块2</code></pre><p>例如：</p><pre><code class="python">x = int(input())if x % 2 == 0:    print(&quot;是一个偶数&quot;)else:    print(&quot;是一个奇数&quot;)</code></pre><h3 id="连续分支"><a href="#连续分支" class="headerlink" title="连续分支"></a>连续分支</h3><pre><code class="python">if 逻辑表达式:    语句块1elif:    语句块2elif:    语句块3else:    语句块4</code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="FOR-循环"><a href="#FOR-循环" class="headerlink" title="FOR 循环"></a>FOR 循环</h3><p>基本语法：</p><pre><code class="python">for variable in 列表:    语句块</code></pre><p>例如：（遍历列表）</p><pre><code class="python">for i in [1, 3, 5, 7, 9]:    print(i,end=&quot; &quot;)</code></pre><p>运行结果：</p><p><a href="https://up.media.everdo.cn/image/7BAi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-forlist.png" alt="python-forlist.png"></a></p><h4 id="range-函数"><a href="#range-函数" class="headerlink" title="range 函数"></a>range 函数</h4><p>产生一个自然数序列</p><pre><code class="python">range(start，stop，step)</code></pre><p>start:计数从start开始。默认是从0开始。</p><blockquote><p>例如 range（5）等价于range（0，5）</p></blockquote><p>stop: 计数到stop结束，但不包括 stop。</p><blockquote><p>例如：list(range（0，5）)是[0, 1, 2, 3, 4]没有5</p></blockquote><p>step：步长，默认为1。</p><blockquote><p>例如：range（0，5）等价于range(0, 5, 1)</p></blockquote><p>产生列表：</p><pre><code class="python">&gt;&gt;&gt; range(1,10)range(1, 10)&gt;&gt;&gt; list(range(1,10))[1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;</code></pre><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。它可以将循环和条件判断结合，从而避免语法冗长的代码，同时提高程序性能。</p><p>基本格式：<br>[ expression <strong>for</strong> item <strong>in</strong> iterable ]</p><p>例如：</p><pre><code class="python"># 交错序列 1-2/3+3/5-4/7+5/9-6/11&gt;&gt;&gt; n = 6&gt;&gt;&gt; l = [num / (num * 2 - 1) if num % 2 != 0 else num / (num * 2 - 1) * (-1) for num in range(1, n + 1)]&gt;&gt;&gt; l[1.0, -0.6666666666666666, 0.6, -0.5714285714285714, 0.5555555555555556, -0.5454545454545454]# 交错序列 0, -1, 2, -3, 4, -5&gt;&gt;&gt; l = [i if i%2==0 else i*(-1) for i in range(6)]&gt;&gt;&gt; l[0, -1, 2, -3, 4, -5]# 偶数&gt;&gt;&gt; l = [i if i%2==0 else i*(-1) for i in range(6) if i% 2 == 0]&gt;&gt;&gt; l[0, 2, 4]&gt;&gt;&gt; l = [i for i in range(6) if i% 2 == 0]&gt;&gt;&gt; l[0, 2, 4]&gt;&gt;&gt;# 叠数&gt;&gt;&gt; l = [int(&#39;6&#39; * i) for i in range(1,8+1)]&gt;&gt;&gt; l[6, 66, 666, 6666, 66666, 666666, 6666666, 66666666]&gt;&gt;&gt;</code></pre><h3 id="WHILE-循环"><a href="#WHILE-循环" class="headerlink" title="WHILE 循环"></a>WHILE 循环</h3><p>语法结构：</p><pre><code class="python">while 条件:  while 子代码1  while 子代码2  while 子代码3</code></pre><blockquote><p>如果条件为True 那么就依次执行while的子代码执行完毕之后再次回去判断条件是否为True如果还是继续执行 直到条件为False为止停止循环</p></blockquote><h4 id="全局标志位"><a href="#全局标志位" class="headerlink" title="全局标志位"></a>全局标志位</h4><p>如果嵌套了很多层 如何做到一次性结束所有的循环层？</p><ul><li>方式1 有几个 while 就写几个 break</li><li>方式2 利用全局标志位</li></ul><pre><code class="python">flag = Truewhile flag:    while 语句块</code></pre><h3 id="高级循环控制"><a href="#高级循环控制" class="headerlink" title="高级循环控制"></a>高级循环控制</h3><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break / continue"></a>break / continue</h4><blockquote><p>break # 结束本层循环(结束掉离break最近的上面的那一个while)</p><p>continue # 结束本次循环直接开始下一次循环</p></blockquote><h4 id="while-for-else"><a href="#while-for-else" class="headerlink" title="while/for + else"></a>while/for + else</h4><p>如果循环被正常结束，则执行 else 语句块：</p><pre><code class="python">count = 1while count &lt; 6:    循环内语句块else:  # 当while没有被人为故意打断的情况下 才会走else    语句块</code></pre><pre><code class="python">for i in range(10):    循环内语句块else:  # 当for正常结束的情况下 才会走else    语句块</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在程序运行过程中如果发生异常，Python 会输出错误消息和关于错误发生处的信息，然后终止程序。</p><p>除了直接将异常进行抛出，比较合理的方法是捕获并处理异常</p><blockquote><p>可使用 try except 语句实现异常处理。</p></blockquote><p>例如：</p><pre><code>short_list = [1,2]try:    short_list[6]except:    print(&#39;产生了下标越界的异常&#39;)</code></pre><p>当 try 中的语句抛出异常时，就会执行 except 下的语句块</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><pre><code class="python">try:    语句块1except 异常类型1:    语句块2except 异常类型2:    语句块3…except 异常类型N:    语句块N+1except:    语句块N+2else:    语句块N+3finally:    语句块N+4</code></pre><p>当没有捕获任何异常的时候，所有 except 下语句都不会执行，但是 else 下的内容会被执行。而不论如何 finally 的语句一定会执行。</p><p>except 不指定异常类型，则匹配所有异常</p><h3 id="常见的标准异常"><a href="#常见的标准异常" class="headerlink" title="常见的标准异常"></a>常见的标准异常</h3><table><thead><tr><th>异常名称</th><th>描述</th></tr></thead><tbody><tr><td>SystemExit</td><td>解释器请求退出</td></tr><tr><td>FloatingPointError</td><td>浮点计算错误</td></tr><tr><td>OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td>ZeroDivisionError</td><td>除（或取模）零（所有数据类型）</td></tr><tr><td>KeyboardInterrupt</td><td>用户中断执行，通常是输入 ^C</td></tr><tr><td>ImportError</td><td>导入模块对象失败</td></tr><tr><td>IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td>RuntimeError</td><td>一般的运行时错误</td></tr><tr><td>AttributeError</td><td>对象没有这个属性</td></tr><tr><td>IOError</td><td>输入输出操作失败</td></tr><tr><td>OSError</td><td>操作系统错误</td></tr><tr><td>KeyError</td><td>映射中没有这个键</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr></tbody></table><h3 id="高级异常操作"><a href="#高级异常操作" class="headerlink" title="高级异常操作"></a>高级异常操作</h3><p>有时需要除了异常类型以外其他的异常细节，可以使用下面的格式获取整个异常对象：</p><pre><code class="python">except Exception as name</code></pre><p>例如：</p><pre><code>short_list = [1, 2,3]while True:    value = input(&#39;Position [q to quit]? &#39;)    if value == &#39;q&#39;:        break    try:        position = int (        print( short_list [    except IndexError as err:        print(&#39;Bad index:&#39;, position)    except Exception as other:        print(&#39;Something else broke:&#39;, other)</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/7VeG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/26/python-exception.png" alt="python-exception.png"></a></p><blockquote><p>前面讨论了异常处理，但是其中讲到的所有异常都是在 Python 或者它的标准库中提前定义好的。根据自己的目的可以使用任意的异常类型，同时也可以自己定义异常类型。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习笔记02（数据/流程）上</title>
      <link href="/2020/06/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%EF%BC%88%E6%95%B0%E6%8D%AE-%E6%B5%81%E7%A8%8B%EF%BC%89%E4%B8%8A/"/>
      <url>/2020/06/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%EF%BC%88%E6%95%B0%E6%8D%AE-%E6%B5%81%E7%A8%8B%EF%BC%89%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数（int）"><a href="#整数（int）" class="headerlink" title="整数（int）"></a>整数（int）</h3><ul><li>与数学中整数概念一致</li><li>整数可正可负</li><li>默认情况下，整数采用十进制。其它进制需要</li><li>增加相应的引导符号</li></ul><table><thead><tr><th>进制</th><th>符号</th><th>示例</th><th>十进制</th></tr></thead><tbody><tr><td>二进制 ：</td><td>0b或0B</td><td>0b10</td><td>2</td></tr><tr><td>八进制：</td><td>0o或0O</td><td>0o10</td><td>8</td></tr><tr><td>十六进制：</td><td>0x 或0X</td><td>0x10</td><td>16</td></tr></tbody></table><a id="more"></a><h3 id="浮点数（float）"><a href="#浮点数（float）" class="headerlink" title="浮点数（float）"></a>浮点数（float）</h3><ul><li>与数学中的实数概念一致</li><li>取值范围与精度都有限制</li></ul><p><strong>表示方式：</strong></p><p>小数：1.23，3.14，-9.01<br>科学计数法：1.23x109 1.23e9</p><p>精度问题：浮点数运算存在不确定尾数，有误差！（可以用Round函数消除尾数）</p><p><a href="https://up.media.everdo.cn/image/7HSB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-float.png" alt="python-float.png"></a></p><p><a href="https://up.media.everdo.cn/image/7PJt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-float-round.png" alt="python-float-round.png"></a></p><h3 id="复数（complex）"><a href="#复数（complex）" class="headerlink" title="复数（complex）"></a>复数（complex）</h3><ul><li>与数学概念一致</li><li>实部和虚部构成 （虚部使用 j 表示）</li><li>real 方法取实部，imag 方法取虚部</li></ul><p><a href="https://up.media.everdo.cn/image/7Iex" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-complex.png" alt="python-complex.png"></a></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="关系运算符同-JAVA"><a href="#关系运算符同-JAVA" class="headerlink" title="关系运算符同 JAVA"></a>关系运算符同 JAVA</h3><p>等于== ， 不等于!= ， 大于&gt; ， 大于等于&gt;= ， 小于&lt; ， 小于等于&lt;=</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>与或非（and or not）</p><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>这里用一个示例说明：</p><pre><code class="python"># 直接赋值&gt;&gt;&gt; a=8&gt;&gt;&gt; b=4&gt;&gt;&gt; print(a,b)8 4# 交换变量值&gt;&gt;&gt; a,b=b,a&gt;&gt;&gt; print(a,b)4 8#多个赋值&gt;&gt;&gt; i,j=[1,2]&gt;&gt;&gt; print(i,j)1 2&gt;&gt;&gt; i,*j=[1,2,3]&gt;&gt;&gt; print(i,j)1 [2, 3]&gt;&gt;&gt; i,j=[1,2,3]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: too many values to unpack (expected 2)&gt;&gt;&gt;</code></pre><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>加减乘除与数学中一致</p><blockquote><p>浮点数除法 / （100/5 = 20.0）</p><p>整数除法 // （100//5 = 20）<strong>向左取整</strong></p><p>取模 % （9%4 = 1）</p><p>幂 ** （2**3 为2的的三次方）</p></blockquote><p><a href="https://up.media.everdo.cn/image/7hMI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-domath.png" alt="python-domath.png"></a></p><h3 id="math-函数"><a href="#math-函数" class="headerlink" title="math 函数"></a>math 函数</h3><table><thead><tr><th>函数或常数</th><th>功能</th></tr></thead><tbody><tr><td>e</td><td>自然常数</td></tr><tr><td>pi</td><td>圆周率</td></tr><tr><td>log(x[,base])</td><td>返回以base为底的对数，缺省为e</td></tr><tr><td>pow(x,y)</td><td>返回x的y次方</td></tr><tr><td>sqrt(x)</td><td>返回x的平方根</td></tr><tr><td>fabs(x)</td><td>返回x的绝对值</td></tr><tr><td>round(x[,n])</td><td>返回浮点数x的四舍五入值，n代表舍入到小数点后的位数</td></tr><tr><td>divmod(x,y)</td><td>返回x和y的商和余数</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>表示形式：（三引号表示多行文本）</p><pre><code class="python">单引号：&#39;abc&#39;双引号：&quot;hello&quot;三引号：&#39;&#39;&#39;helloworld &#39;&#39;&#39;</code></pre><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>反斜杠符号</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\ooo</td><td>最多三位 八进制，例如：\12代表换行</td></tr><tr><td>\xyy</td><td>十六进制数，yy代表的字符，例如：\x0a代表换行</td></tr></tbody></table><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote><p>“+” 表示连接字符串<br>“*” 表示复制字符串</p></blockquote><p><a href="https://up.media.everdo.cn/image/7naX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/24/python-string-math.png" alt="python-string-math.png"></a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code class="python">&gt;&gt;&gt; s = &quot;emptinessboy&quot;&gt;&gt;&gt; s[0]&#39;e&#39;&gt;&gt;&gt; s[-1]&#39;y&#39;&gt;&gt;&gt; s[0:3]&#39;emp&#39;&gt;&gt;&gt;[::-1]可以用来反转序列</code></pre><p>例子：提取温度符号C前面的数字</p><blockquote><p>用户输入 26C 则返回 26 ，用户输入 8C 则返回 8</p></blockquote><pre><code class="python">&gt;&gt;&gt; s = &quot;26C&quot;&gt;&gt;&gt; s[0:-1]&#39;26&#39;&gt;&gt;&gt; s = &quot;8C&quot;&gt;&gt;&gt; s[:-1]&#39;8&#39;&gt;&gt;&gt;</code></pre><p>“:” 的前后可以省略，前面省略则为从头开始，后面省略则为到最后一个</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法 %"></a>传统方法 %</h4><p>类似 Java，略有不同</p><blockquote><p><strong>(</strong> “%.2f” % (参数1, 参数2, ……) <strong>)</strong></p></blockquote><h4 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h4><blockquote><p><strong>语法：</strong></p><p>模板字符串.format(参数1,参数2 ……)</p></blockquote><p>format() 方法的基本使用:</p><table><thead><tr><th>模板</th><th>方法</th></tr></thead><tbody><tr><td>:</td><td>引导符号</td></tr><tr><td>&lt;填充&gt;</td><td>用于填充的单个字符</td></tr><tr><td>&lt;对齐&gt;</td><td>&lt;左对齐 &gt;右对齐 ＾居中对齐</td></tr><tr><td>&lt;宽度&gt;</td><td>槽的设定输出宽度</td></tr><tr><td>,</td><td>数字的千位分隔符适用于整数和浮点数</td></tr><tr><td>&lt;.精度&gt;</td><td>浮点数小数部分的精度或字符串的最大输出长度</td></tr><tr><td>&lt;类型&gt;</td><td>整数类型 b, c, d, o, x, X 浮点数类型 e, E, f, %</td></tr></tbody></table><pre><code class="python"># 使用模板字符串&gt;&gt;&gt; s = &quot;{} is {} years old&quot;&gt;&gt;&gt; s.format(&quot;Emptinessboy&quot;,20)&#39;Emptinessboy is 20 years old&#39;# 使用名称&gt;&gt;&gt; s = &quot;{name} is {age} years old&quot;&gt;&gt;&gt; s.format(name=&quot;Emptinessboy&quot;, age=20)&#39;Emptinessboy is 20 years old&#39;# 控制精度&gt;&gt;&gt; a ,b = 6, 6.66&gt;&gt;&gt; s = &quot;a={:2d},b={:.1f}&quot;&gt;&gt;&gt; s.format(a,b)&#39;a= 6,b=6.7&#39;&gt;&gt;&gt; s = &quot;a={:&lt;5d},b={:&lt;5.1f}&quot;&gt;&gt;&gt; s.format(a,b)&#39;a=6    ,b=6.7  &#39;</code></pre><h3 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h3><p>str.find() 方法检测字符串中是否包含指定子字符串 ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。</p><p>语法：</p><pre><code class="python">str.find(&quot;要查找的子字符串&quot;, beg=0, end=len(string))</code></pre><p>str.strip() 方法可以去除字符串中的空格<br>str.upper() str.lower() 方法可以改变大小写</p><p><strong>is类函数可以判断是否为某种类型：</strong></p><p>isdigit() 判断是不是数字</p><blockquote><p>如果要判断中文数字或者罗马数字 则需要使用isnumeric</p></blockquote><pre><code class="python">res = &#39;Jason 666 heiheihei&#39;res.islower() # False  判断字符串是否是全小写的res.isupper() # False  判断字符串是否是全大写的res.istitle() # False  判断字符串英文单词是否都是首字母大写的</code></pre><h4 id="列表合成字符串-join"><a href="#列表合成字符串-join" class="headerlink" title="列表合成字符串 join()"></a>列表合成字符串 join()</h4><p><em>前提是列表内本身就是字符串</em></p><pre><code>&gt;&gt;&gt; t = [&quot;hi&quot;,&quot;/&quot;,&quot;emptinessboy&quot;]&gt;&gt;&gt; &#39; &#39;.join(t)&#39;hi / emptinessboy&#39;</code></pre><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>bool()</td><td>根据传入的参数的逻辑值创建一个新的布尔值</td></tr><tr><td>int()</td><td>根据传入的参数创建一个新的整数</td></tr><tr><td>float()</td><td>根据传入的参数创建一个新的浮点数</td></tr><tr><td>complex()</td><td>根据传入参数创建一个新的复数</td></tr><tr><td>str()</td><td>创建一个字符串</td></tr><tr><td>ord()</td><td>返回Unicode字符对应的整数</td></tr><tr><td>chr()</td><td>返回整数所对应的Unicode字符</td></tr><tr><td>bin()</td><td>将整数转换成2进制字符串</td></tr><tr><td>oct()</td><td>将整数转化成8进制数字符串</td></tr><tr><td>hex()</td><td>将整数转换成16进制字符串</td></tr><tr><td>list()</td><td>根据传入的参数创建一个新的列表</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code class="python">&gt;&gt;&gt; int(&quot;1a&quot;,16)26&gt;&gt;&gt; int(&quot;10&quot;,8)8&gt;&gt;&gt; int(&quot;  10 &quot;)10&gt;&gt;&gt; int(10)10&gt;&gt;&gt;</code></pre><h3 id="随机函数库-random"><a href="#随机函数库-random" class="headerlink" title="随机函数库 random"></a>随机函数库 random</h3><blockquote><p>要使用random库，先要用 “import random” 语句引入 random 库。</p></blockquote><pre><code class="python">import random</code></pre><p><strong>random 库的常用函数</strong></p><table><thead><tr><th>函数名</th><th>含义</th><th>示列</th></tr></thead><tbody><tr><td>random.random()</td><td>返回一个介于左闭右开[0.0, 1.0)区间的浮点数</td><td>random.random()</td></tr><tr><td>random.uniform(a, b)</td><td>返回一个介于【a，b】的浮点数。</td><td>random.uniform(1,10)</td></tr><tr><td>random.randint(a,b）</td><td>返回【a,b】的一个随机整整。</td><td>random.randint(15,30）</td></tr><tr><td>random.randrange([start], stop, [step])</td><td>从指定范围内，获取一个随机数</td><td>random.randrange(10, 30, 2)</td></tr><tr><td>random.choice(sequence)</td><td>从序列中获取一个随机元素</td><td>random.choice([3,78,43,7]）</td></tr><tr><td>random.shuffle(x)</td><td>用于将一个列表中的元素打乱,即将列表内的元素随机排列</td><td>random.shuffle(l) , l是序列</td></tr><tr><td>random.sample(sequence, k)</td><td>从指定序列中随机获取长度为k的序列并随机排列</td><td>random.sample([1,4,5,89,7],3)</td></tr><tr><td>random.seed(n)</td><td>对随机数生成器进行初始化的函数，n代表随机种子。参数为空时，随机种子为系统时间</td><td>random.seed(2)</td></tr></tbody></table><h3 id="序列操作函数"><a href="#序列操作函数" class="headerlink" title="序列操作函数"></a>序列操作函数</h3><p>max() 可以从一个序列中返回序列中的最大值<br>min() 可以从一个序列中返回序列中的最小值<br>len(<list>) 可以求序列长度</list></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO和网络（下</title>
      <link href="/2020/06/Java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%8B/"/>
      <url>/2020/06/Java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="过滤器流"><a href="#过滤器流" class="headerlink" title="过滤器流"></a>过滤器流</h2><p>通常情况下，为了提高数据的处理速度，或是能对诸如 int、double 之类的数据直接进行操作，会联合使用被称之为过滤器（Filter）类的流，以提高流的处理效率。</p><blockquote><p>过滤器流的不能单独使用，必须与相应的节点流一起使用，才能实现数据流的读写功能。</p></blockquote><p>上一篇文章中和大家提到了 BufferedInuputStream 类和 BufferedOutputStream 就是两个常用的带缓冲的过滤器流</p><h3 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h3><p>有时需要处理的数据不一定是字节数据。如读写 int型、float型、double型 的数据时，一次需要读写几个字节，需要专门的数据输入输出流来处理。</p><p><strong>DateInuputStream类 和 DateOutputStream类 能够直接读写 Java 基本类型的数据 和 Unicode 编码格式的字符串。</strong></p><table><thead><tr><th>DataInputStream 类的读方法</th><th>DataOutputStream 类的写方法</th></tr></thead><tbody><tr><td>int read(byte[] b)</td><td>void write(byte[] b, int off, int len)</td></tr><tr><td>int read(byte[] b, int off, int len)</td><td>void write(int b)</td></tr><tr><td>boolean readBoolean()</td><td>void writeBoolean(boolean v)</td></tr><tr><td>byte readByte()</td><td>void writeByte(int v)</td></tr><tr><td>char readChar()</td><td>void writeBytes(String s)</td></tr><tr><td>double readDouble()</td><td>void writeChar(int v)</td></tr><tr><td>float readFloat()</td><td>void writeChars(String s)</td></tr><tr><td>void readFully(byte[] b)</td><td>void writeDouble(double v)</td></tr><tr><td>void readFully(byte[] b, int off, int len)</td><td>void writeFloat(float v)</td></tr><tr><td>int readInt()</td><td>void writeInt(int v)</td></tr><tr><td>long readLong()</td><td>void writeLong(long v)</td></tr><tr><td>short readShort()</td><td>void writeShort(int v)</td></tr><tr><td>String readUTF()</td><td>void writeUTF(String str)</td></tr></tbody></table><p><strong>写入 DEMO：</strong></p><pre><code class="java">import java.io.*;public class DataInputOutput {    public static void main(String[] args) {        File f = new File(&quot;src/test-a.txt&quot;);        try {            OutputStream op = new FileOutputStream(f);            DataOutputStream dp = new DataOutputStream(op);            int a = 666;            String b = &quot;emptinessboy&quot;;            boolean c = true;            dp.writeInt(a);            dp.writeUTF(b);            dp.writeBoolean(c);            dp.close();            op.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>运行后，程序输出了 test-a.txt。因为是字节流，所以显示乱码。</p><p><a href="https://up.media.everdo.cn/image/nOCy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/dataopstream.png" alt="dataopstream.png"></a></p><p><strong>读取 DEMO：</strong></p><pre><code class="java">import java.io.*;public class DataInPutTest {    public static void main(String[] args) {        File f = new File(&quot;src/test-a.txt&quot;);        try {            InputStream in = new FileInputStream(f);            BufferedInputStream bi = new BufferedInputStream(in);            DataInputStream di = new DataInputStream(bi);            boolean flag = true;  //避免系统认为while下面的代码不可达            while (flag){                System.out.println(di.readInt());                System.out.println(di.readUTF());                System.out.println(di.readBoolean());            }            di.close(); //关闭流            bi.close();            in.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            System.out.println(&quot;文件结束&quot;);            //e.printStackTrace();        }    }}</code></pre><p>运行效果（可以看到所有的文件信息【基本数据类型】都被输出出来了）：</p><p><a href="https://up.media.everdo.cn/image/nZJd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/dataipstream.png" alt="dataipstream.png"></a></p><h2 id="对象I-O"><a href="#对象I-O" class="headerlink" title="对象I/O"></a>对象I/O</h2><p>如果要对除了基本数据类型以外的内容进行 IO 操作，JAVA也是支持的。</p><p>Java 提供了一个 Serializable 的接口，只要类实现了该接口，就可以使用 <strong>ObjectInputStream类</strong> 和 <strong>ObjectOutputStream类</strong> 对该类的对象进行 I/O 处理了。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>这是一个简单的圆类：</p><pre><code class="java">package 学校课程527实验;import java.io.*;public class circleClass {    double x1,y1,x2,y2;    public circleClass(double x1,double y1,double x2,double y2) {        this.x1=x1;        this.x2=x2;        this.y1=y1;        this.x2=y2;    }    public double getArea(){        double r = Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));        return Math.PI*r*r;    }}</code></pre><p>我们给这个类实现 Serializable 接口：</p><pre><code class="java">public class circleClass implements Serializable { …… }</code></pre><p>创建对象并写入对象到文件：</p><pre><code class="java">class TestCircle{    public static void main(String[] args) {        //初始化两个对象        circleClass a = new circleClass(0,0,8.5,9);        System.out.printf(&quot;圆1的面积为：%.2f\n&quot;,a.getArea());        circleClass b = new circleClass(2,3.5,9,6);        System.out.printf(&quot;圆2的面积为：%.2f\n&quot;,b.getArea());        //将对象写入文件        File f = new File(&quot;src/test-c.dat&quot;);        try {            FileOutputStream fo = new FileOutputStream(f);            ObjectOutputStream op = new ObjectOutputStream(fo);            op.writeObject(a);            op.writeObject(b);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>再写一个类来读取刚才写入的对象：</p><pre><code class="java">import java.io.*;import 学校课程527实验.*;public class ReadCircle {    public static void main(String[] args) {        File f = new File(&quot;src/test-c.dat&quot;);        try {            FileInputStream fi = new FileInputStream(f);            ObjectInputStream oi = new ObjectInputStream(fi);            circleClass a = (circleClass) oi.readObject();            circleClass b = (circleClass) oi.readObject();            System.out.printf(&quot;圆1的面积为：%.2f\n&quot;,a.getArea());            System.out.printf(&quot;圆2的面积为：%.2f\n&quot;,b.getArea());        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>先运行 TestCircle 来创建对象并写入文件：</p><p><a href="https://up.media.everdo.cn/image/nKaD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/RunObjectOutPutBuffer.png" alt="RunObjectOutPutBuffer.png"></a></p><p>可以看到输出的 test-c.dat 里面已经存入了对象（字节形式存储，因此 IDE 打开乱码）。接下来我们使用下面这段程序读取刚才的对象。</p><pre><code class="java">import java.io.*;import 学校课程527实验.*;public class ReadCircle {    public static void main(String[] args) {        File f = new File(&quot;src/test-c.dat&quot;);        try {            FileInputStream fi = new FileInputStream(f);            ObjectInputStream oi = new ObjectInputStream(fi);            //读取两个对象，并转化为circleClass            //因为.readObject()方法默认返回Object所以要转换            circleClass a = (circleClass) oi.readObject();            circleClass b = (circleClass) oi.readObject();            System.out.printf(&quot;圆1的面积为：%.2f\n&quot;,a.getArea());            System.out.printf(&quot;圆2的面积为：%.2f\n&quot;,b.getArea());        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p><a href="https://up.media.everdo.cn/image/n83L" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/RunObjectInPutBuffer.png" alt="RunObjectInPutBuffer.png"></a></p><p>可以看到，对象已经成功被读取，对象的方法也都可以正常操作！</p><h2 id="随机文件操作"><a href="#随机文件操作" class="headerlink" title="随机文件操作"></a>随机文件操作</h2><p>RandomAccessFile 类直接继承自 Object 类，可以从文件的任何位置开始进行读或者写操作。</p><p>RandomAccessFile 类同时实现了 DataInput 接口和 DataOutput 接口，可以对常用数据类型直接操作。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code class="java">RandomAccessFile(String name, String mode)</code></pre><p>其中 mode 是访问模式。</p><h3 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h3><blockquote><p>四种模式：R RW RWD RWS</p></blockquote><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>以只读的方式打开文本，也就意味着不能用write来操作文件</td></tr><tr><td>rw</td><td>读操作和写操作都是允许的</td></tr><tr><td>rws</td><td>每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</td></tr><tr><td>rwd</td><td>每当进行写操作，同步的刷新到磁盘，刷新内容</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><a href="https://up.media.everdo.cn/image/n5dl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/randomAccessFile.png" alt="randomAccessFile.png"></a></p><p><strong>1、seek：</strong> 指定文件的光标位置，通俗点说就是指定你的光标位置然后下次读文件数据的时候从该位置读取。</p><p><strong>2、getFilePointer：</strong> 我们注意到这是一个 long 类型的返回值，字面意思就是返回当前的文件光标位置。这样方便我们后面读取插入。</p><p>=====================</p><p><strong>3、length：</strong> 文件的长度，返回long类型。注意它并不会受光标的影响。只会反应客观的文本长度。</p><p>=====================</p><p><strong>4、read()、read(byte[] b)、read(byte[] b,int off,int len) ：</strong> 这些方法跟 readstream 中的方法一样，例如最后一个：定义缓冲数组，从数组的 off 偏移量位置开始写，读取转换为数组数据达到 len 个字节。总之这是一个读文件内容的标准操作 api。</p><p><strong>5、readDouble() readFloat() readBoolean() readInt() readLong() readShort() readByte() readChar()：</strong> 这些方法都是去read每一个字符。比如readLong就是要求你的文本内容必须有八个字符，不然会报错。</p><p>伴随着也就是 <strong>writeDouble() writeFloat() writeBoolean() writeInt() writeLong() writeShort() writeByte() writeChar()</strong></p><p><strong>6、readFully(byte[] b)：</strong> 这个方法的作用就是将文本中的内容填满这个缓冲区b。如果缓冲b不能被填满，那么读取流的过程将被阻塞，如果发现是流的结尾，那么会抛出异常。这个过程就比较像“凑齐一车人在发车，不然不走”。</p><p>=====================</p><p><strong>7、getChannel：</strong> 它返回的就是 nio 通信中的 file 的唯一 channel</p><p>=====================</p><p><strong>8、skipBytes(int n)：</strong> 跳过n字节的位置，相对于当前的 point。</p><h3 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="DEMO"></a>DEMO</h3><p><strong>追加日志：</strong></p><pre><code class="java">import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFiletest1 {    public static void main(String[] args) {        File f = new File(&quot;src/test.log&quot;);        try {            RandomAccessFile rf = new RandomAccessFile(f, &quot;rws&quot;);            //获取文件长度并定位到文件结尾            rf.seek(rf.length());            //输入十个日期信息            for (int i=0;i&lt;10;i++) {                rf.writeBytes(new java.util.Date() + &quot;\r\n&quot;);            }            rf.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>连续两次运行程序后，可以看到，第二次的时候，程序在第一次书写的末尾继续书写日志文件。</p><p><a href="https://up.media.everdo.cn/image/nG10" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/RandomAccessFile.png" alt="RandomAccessFile.png"></a></p><h2 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h2><p>套接字（Socket）是Java支持网络通信的一种对象，程序间在网络上进行通信和程序对文件的操作是十分类似的。</p><blockquote><p>SeverSock 是用来监听，等待建立连接的。一旦建立连接，就会生成一个 Socket 对象进行实际的数据传输</p></blockquote><h3 id="JAVA-socket模型"><a href="#JAVA-socket模型" class="headerlink" title="JAVA socket模型"></a>JAVA socket模型</h3><p><a href="https://up.media.everdo.cn/image/naEc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/Java-socket.png" alt="Java-socket.png"></a></p><h3 id="简单服务器客户机-DEMO"><a href="#简单服务器客户机-DEMO" class="headerlink" title="简单服务器客户机 DEMO"></a>简单服务器客户机 DEMO</h3><p>这段程序用来实现从服务器不断发文字到客户机，然后客户端读取并显示文字：</p><p><strong>服务器端程序：</strong></p><pre><code class="java">import java.io.DataOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class SimpleServer {    public static void main(String[] args) {        try {            //先使用ServerSocket监听端口            ServerSocket ss = new ServerSocket(6666);            //接受连接并获得Socket            Socket s = ss.accept();            OutputStream op = s.getOutputStream();            DataOutputStream dp = new DataOutputStream(op);            System.out.println(&quot;连接已建立，请输入发给客户端的消息（输入 quit 退出）：&quot;);            //基本输入输出流            Scanner sc = new Scanner(System.in);            String str;            while (!(str = sc.nextLine()).equals(&quot;quit&quot;)){                dp.writeUTF(str);            }            //关闭流            sc.close();            dp.close();            op.close();            s.close();            ss.close();            System.out.println(&quot;连接已经关闭&quot;);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>客户端程序：</strong></p><pre><code class="java">import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class SimpleClient {    public static void main(String[] args) {        try {            //建立一个连接到服务器的socket（IP地址+端口）            Socket s = new Socket(&quot;127.0.0.1&quot;, 6666);            InputStream is = s.getInputStream();            DataInputStream di = new DataInputStream(is);            System.out.println(&quot;连接已建立，正在接收服务端的消息：&quot;);            boolean flag = true;            while (flag)                System.out.println(di.readUTF());            //关闭流            di.close();            is.close();            s.close();            System.out.println(&quot;连接已经关闭&quot;);        } catch (IOException e) {            System.out.println(&quot;连接已经中断&quot;);            //e.printStackTrace();        }    }}</code></pre><p><strong>运行效果（服务器端）：</strong></p><p><a href="https://up.media.everdo.cn/image/ngZ2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/SimpleServerdemo.png" alt="SimpleServerdemo.png"></a></p><p><strong>运行效果（客户端）：</strong></p><p><a href="https://up.media.everdo.cn/image/nuBZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/SimpleClientdemo.png" alt="SimpleClientdemo.png"></a></p><h3 id="简单文件传输-DEMO"><a href="#简单文件传输-DEMO" class="headerlink" title="简单文件传输 DEMO"></a>简单文件传输 DEMO</h3><blockquote><p>将客户机某文件传到服务器</p></blockquote><p><strong>服务器端程序：</strong></p><pre><code class="java">import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class FileUploadServer {    public static void main(String[] args) {        ServerSocket ss = null;        Socket s;        int temp = 0;  //记录文件长度        byte[] b = new byte[1024];  //字节流缓冲区        InputStream fi; //输入流        BufferedInputStream bi; //输入缓冲流        FileOutputStream fo;  //文件输出流        BufferedOutputStream bo;  //输出缓冲流        try {            ss = new ServerSocket(8888);  //尝试监听端口        } catch (IOException e) {            e.printStackTrace();        }        while (true){   //服务端程序始终运行            try {                s = ss.accept();  //如有连接则建立连接并拿到 socket                System.out.println(&quot;已经建立连接&quot;);                fi = s.getInputStream();  //从socket拿到字节流                bi = new BufferedInputStream(fi);  //输入缓冲流初始化                File file;  //创建文件对象                fo = new FileOutputStream(&quot;src/file.txt&quot;);                bo = new BufferedOutputStream(fo);  //输出缓冲流初始化                try {                    //如果有连接且文件没有读取完毕则进行循环                    while (s.isConnected()&amp;&amp;(temp = bi.read(b))!=-1){                        //输出缓冲流写入                        bo.write(b,0,temp);                    }                } catch (Exception e) {                    e.printStackTrace();                }                //按顺序关闭流                bo.close();                fo.close();                bi.close();                fi.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>客户端程序：</strong></p><pre><code class="java">import java.io.*;import java.net.Socket;public class FileUploadClient {    public static void main(String[] args) {        //创建文件对象        File f = new File(&quot;src/test-d.txt&quot;);        try {            //尝试建立连接            Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);            OutputStream so = s.getOutputStream();  //从socket拿到输出字节流            BufferedOutputStream bo = new BufferedOutputStream(so);  //输出缓冲流初始化            FileInputStream fin = new FileInputStream(f);  //文件输入流初始化            BufferedInputStream bi = new BufferedInputStream(fin);  //输入缓冲流初始化            byte[] b = new byte[1024];  //字节流缓冲区            int temp;  //记录当前读取的长度            while ((temp = bi.read(b))!= -1){                //当文件还没读完，就执行循环                bo.write(b,0,temp); //写入输出缓冲流            }            //按序关闭流            bo.close();            so.close();            bi.close();            fin.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>做完这一切，在 src 目录下创建 test-d.txt，然后启动服务端程序。最后运行客户端程序。</p><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/74Wk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/06/02/fileuploadsuccess.png" alt="fileuploadsuccess.png"></a></p><p>可以看到，服务端成功接收了文件并保存为 src/file.txt。😁😉</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO处理（上</title>
      <link href="/2020/05/Java-IO%E5%A4%84%E7%90%86/"/>
      <url>/2020/05/Java-IO%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>在 Java 中，将通过不同输入输出设备（键盘、内存、显示器、网络等）之间的数据传输抽象表述为“流”，程序允许通过流的方式与输入输出设备进行数据传输。Java 中的“流”都位于 java.io 包中，称为 IO （输入输出）流。</p><p>IO 流有很多种，按照操作数据的不同，可以分为字节流和字符流，按照数据传输方向的不同又可分为输入流和输出流，程序从输入流中读取数据，向输出流中写入数据。</p><h2 id="两类流（字节-字符）"><a href="#两类流（字节-字符）" class="headerlink" title="两类流（字节 / 字符）"></a>两类流（字节 / 字符）</h2><p><strong>JAVA.IO 包定义了两类流：</strong></p><ul><li>字节流 (JDK1.0)：InputStream、OutputStream</li><li>字符流 (JDK1.1)：Reader、Writer</li></ul><p><a href="https://up.media.everdo.cn/image/nnmS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/IO-stream.png" alt="IO-stream.png"></a></p><blockquote><p>如果要进行输入，输出操作一般都会按照如下的步骤进行（以文件操作为例）：</p><ol><li>通过 File 类定义一个要操作文件的路径 (不是文件就没有这一步)；</li><li>通过字节流或则字符流的子类对象为父类对象实例化；</li><li>进行数据的读（写入），写（输出）操作；</li><li>数据流属于资源操作，资源操作必须关闭；</li></ol></blockquote><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>在计算机中，无论是文本、图片、音频还是视频，所有文件都是以二进制（字节） 形式存在的， IO 流中针对字节的输入输出提供了—系列的流，统称为字节流。字节流是程序中最常用的流，根据数据的传输方向可将其分为 字节输入流 InputStream 和 字节输出流 OutputStream。</p><p>字节输入流 InputStream 和 字节输出流 OutputStream 它们是字节流的顶级父类，所有的字节输入流都继承自 InputStream, 所有的字节输出流都继承自 Output Stream。</p><h4 id="InputStream-常用方法"><a href="#InputStream-常用方法" class="headerlink" title="InputStream 常用方法"></a>InputStream 常用方法</h4><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流读取—个 8 位的字节，把它转换为 0-255 之间的整数，并返回这—整数.</td></tr><tr><td>int read(byte[] b)</td><td>从输入流读取若干字节，把它们保存到参数 b 指定的字节数组中，返回的整数表示读取字节的数目</td></tr><tr><td>int read(byte[] b,int off, int len)</td><td>从输入流读取若干字节，把它们保存到参数 b 指定的字节数组中， off 指定字节数组开始保存数据的起始下标， len 表示读取的字节数目</td></tr><tr><td>void close()</td><td>关闭此输入流并释放与该流关联的所有系统资源</td></tr></tbody></table><p>其中，第 1 个 read() 方法是从输入流中逐个读入字节，而第 2 个和第 3 个 read() 方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。</p><h4 id="OutputStream-常用方法"><a href="#OutputStream-常用方法" class="headerlink" title="OutputStream 常用方法"></a>OutputStream 常用方法</h4><table><thead><tr><th>方法名称</th><th>方法描述</th></tr></thead><tbody><tr><td>void write(int b)</td><td>向输出流写入一个字节</td></tr><tr><td>void write(byte[] b)</td><td>把参数 b 指定的字节数组的所有字节写到输出流</td></tr><tr><td>void write(byte[] b,int off,int len)</td><td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入输出流</td></tr><tr><td>void flush()</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr><tr><td>void close()</td><td>关闭此输出流并释放与此流相关的所有系统资源</td></tr></tbody></table><p>后两个方法是将若干个字节以字节数组的形式一次性写入，从而提高写数据的效率。 flush() 方法用来将当前输出流缓冲区（通常是字节数组）中的数据强制写入目标设备，此过程称为刷新。close() 方法是用来关闭流并释放与当前 IO 流相关的系统资源。</p><h4 id="子类继承关系"><a href="#子类继承关系" class="headerlink" title="子类继承关系"></a>子类继承关系</h4><p>InputStream 和 OutputStream 这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类是抽象类，不能被实例化。因此，针对不同的功能， lnputStream 和 OutputStream 提供了不同的子类：</p><blockquote><p>lnputStream 和OutputStream 的子类有很多是大致对应的</p></blockquote><p><strong>InputStream：</strong></p><p><a href="https://up.media.everdo.cn/image/n7OQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/inputstream.png" alt="inputstream.png"></a></p><p><strong>OutputStream：</strong></p><p><a href="https://up.media.everdo.cn/image/nR7J" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/outputstream.png" alt="outputstream.png"></a></p><h3 id="字节流读写文件"><a href="#字节流读写文件" class="headerlink" title="字节流读写文件"></a>字节流读写文件</h3><h4 id="FilelnputStream"><a href="#FilelnputStream" class="headerlink" title="FilelnputStream"></a>FilelnputStream</h4><p>FileInputStream 是 InputStream 的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。</p><p><strong>DEMO：</strong></p><p>在 src 目录下 创建 test1.txt，并输入内容。</p><p><a href="https://up.media.everdo.cn/image/njqy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/test1.txt.png" alt="test1.txt.png"></a></p><pre><code class="java">import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileIOStream {    public static void main(String[] args) {        File file;        try {            FileInputStream fin = new FileInputStream(&quot;src/test1.txt&quot;);            int r = 0;            while (r !=-1){                r = fin.read();                System.out.println(r);            }        } catch (FileNotFoundException e) {            System.out.println(&quot;找不到文件&quot;);            e.printStackTrace();        } catch (IOException e){            System.out.println(&quot;IO错误&quot;);            e.printStackTrace();        }    }}</code></pre><p><strong>运行后输出如下：</strong></p><p><a href="https://up.media.everdo.cn/image/noXd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/FileIOstream1.png" alt="FileIOstream1.png"></a></p><p>这段代码中 FileInputStream，在 while 循环中，每次从文件 test1.txt 中读取一字节（1B）也就是<strong>8比特</strong>的数据。然后打印出来。</p><p>因为是直接读取的字节，所以 abc 就以 ASCII 码的方式输出了，分别为 97 98 99。其中txt中另起一行的操作，在 Windows 下存为回车符’\r’换行符’\n’，分别输出为 13 和 10。接着 123 输出为 49 50 51。读取完毕后，字节流会返回 -1，这时退出循环。</p><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>FileOutputStream 是 OutputStream 的子类，它是操作文件的字节输出流，专门用于把数据写入文件。</p><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileIOoutStream {    public static void main(String[] args) {        File file;        try {            FileOutputStream fout = new FileOutputStream(&quot;src/test2.txt&quot;);            String s = &quot;Hi EmptinessBoy!&quot;;            try {                fout.write(s.getBytes());                fout.close();            } catch (IOException e) {                e.printStackTrace();            }        } catch (FileNotFoundException e) {            System.out.println(&quot;文件找不到&quot;);            e.printStackTrace();        }    }}</code></pre><p><strong>运行后输出如下：</strong></p><p>src 目录下自动生成了 text2.txt,并成功写入了预设字符串的内容。</p><p><a href="https://up.media.everdo.cn/image/nF4l" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/26/test2.txt.png" alt="test2.txt.png"></a></p><h4 id="DEMO-文件拷贝"><a href="#DEMO-文件拷贝" class="headerlink" title="DEMO 文件拷贝"></a>DEMO 文件拷贝</h4><p><strong>代码：</strong></p><pre><code class="java">import java.io.*;public class FileIOStreamCopyFile {    public static void main(String[] args) {        try {            FileInputStream fin = new FileInputStream(&quot;src/logo.png&quot;);            FileOutputStream fout = new FileOutputStream(&quot;src/logo-cpoy.png&quot;);            byte[] b = fin.readAllBytes();            fout.write(b);            fin.close();            fout.close();        } catch (FileNotFoundException e) {            e.printStackTrace();            System.out.println(&quot;文件打开异常&quot;);        } catch (IOException e) {            e.printStackTrace();            System.out.println(&quot;IO异常&quot;);        }    }}</code></pre><p>运行后的结果就是把当前 src 下面的 logo.png 拷贝了一份，并命名为 logo-copy.png。经过测试，这个新图片是可以打开的。</p><p><strong>注意：</strong></p><p>Files.readAllBytes(Path) 方法把整个文件读入内存，此方法返回一个字节数组，还可以把结果传递给String的构造器，以便创建字符串输出。</p><blockquote><p>要注意，此方法不适合读取很大的文件，因为可能存在内存空间不足的问题。</p></blockquote><h4 id="文件拷贝缓冲区效果"><a href="#文件拷贝缓冲区效果" class="headerlink" title="文件拷贝缓冲区效果"></a>文件拷贝缓冲区效果</h4><p>因此要拷贝大文件，还是多次分段读入写入比较合适（实现缓冲区效果）：</p><pre><code class="java">import java.io.*;public class FileIOStreamCopyFile {    public static void main(String[] args) {        try {            FileInputStream fin = new FileInputStream(&quot;src/logo.png&quot;);            FileOutputStream fout = new FileOutputStream(&quot;src/logo-cpoy.png&quot;);            int len;            byte[] buffer = new byte[4096];            while ((len = fin.read(buffer)) &gt; 0) {                fout.write(buffer, 0, len);            }        } catch (FileNotFoundException e) {            e.printStackTrace();            System.out.println(&quot;文件打开异常&quot;);        } catch (IOException e) {            e.printStackTrace();            System.out.println(&quot;IO异常&quot;);        }    }}</code></pre><p>在拷贝过程中，通过 while 循环将字节逐个进行拷贝。每循环—次，就通过 FileInputStream 的 read() 方法读取小于4096字节的数据，并通过 FileOutputStream 的 write() 方法将该字节写入指定文件，循环往复，直到 len 的值为 -1 表示读取到了文件的末尾，结束循环，完成文件的拷贝。</p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>在 IO 包中提供两个带缓冲的字节流，分别是 BufferedInputStream 和 BufferedOutputStream,它们的构造方法中分别接收 InputStream 和 OutputStream 类型的参数作为对象，在读写数据时提供缓冲功能。</p><blockquote><p>源设备 – 字节流 – 字节缓冲流 – 应用程序</p></blockquote><p><strong>DEMO：(使用刚才的文件拷贝案例)</strong></p><pre><code class="java">import java.io.*;public class BufferIOStreamCopyFile2 {    public static void main(String[] args) throws Exception {        TimeClock t = new TimeClock();        //创建一个带缓冲区的输入流        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;src/logo.png&quot;));        //创建一个带缓冲区的输出流        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;src/logologo.png&quot;));        int len;        while ((len = bis.read()) != -1) {            bos.write(len);        }        bis.close();        bos.close();        t.end();    }}</code></pre><blockquote><p>BufferedInputStream 和 BufferedOutputStream 两个缓冲流对象内部都定义了一个大小为 8192 的字节数组。当调用 read() 或者 write() 方法读写数据时，首先将读写的数据存入定义好的字节数组，然后将字节数组的数据一次性读写到文件中。这种方式与之前的 <code>byte[] b = byte[4096]</code> 这样的字节流的缓冲区类似，都对数据进行了缓冲，从而有效地提高了数据的读写效率。</p></blockquote><p>这里，本质还是一个字节一个字节的把字节读取，然后存到 len 中，然后再把 len 拷贝到 outputstream，和之前不一样的是，这里会在把数据存到 len 的过程中，进行内部的缓存。这时，再一个一个读取 len 的时候，就会比直接从外部磁盘读取要快。这个和之前使用数组实现的缓冲区 byte[] b 实现的不一样。</p><h4 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h4><p>当然，手动开辟的缓冲数组可以和 Buffered(In/Out)putSteream 结合在一起使用：</p><pre><code class="java">import java.io.*;public class BufferIOStreamCopyFile1 {    public static void main(String[] args) {        try {            BufferedInputStream bin = new BufferedInputStream(new FileInputStream(&quot;src/logo.png&quot;));            BufferedOutputStream bout =  new BufferedOutputStream(new FileOutputStream(&quot;src/logo-copy-buffered.png&quot;));            byte[] buffer = new byte[4096];            int len;            while ((len = bin.read(buffer))!=-1){                bout.write(buffer,0,len);            }            bin.close();            bout.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>前面已经讲解过 InputStream 类和 OutputStream 类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用字符流会更加方便。</p><p>大体方法和之前字节流类似</p><h4 id="子类继承关系-1"><a href="#子类继承关系-1" class="headerlink" title="子类继承关系"></a>子类继承关系</h4><p>Reader</p><p><a href="https://up.media.everdo.cn/image/n3b0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/ReaderClass.png" alt="ReaderClass.png"></a></p><p>Writer</p><p><a href="https://up.media.everdo.cn/image/nA0D" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/WriterClass.png" alt="WriterClass.png"></a></p><h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><p>之前我们使用字节流操作文件用到的是 FileInputStream 和 FileOutputStream。而要使用字符流，只需要改用 FileReader 和 FileWriter。</p><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><blockquote><p>使用字符输入流 FileReader, 通过此流可以从关联的文件中读取—个或—组字符。</p></blockquote><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReaderTest {    public static void main(String[] args) {        try {            FileReader fr = new FileReader(&quot;src/test5.txt&quot;);            int c;            while((c=fr.read())!=-1){                System.out.print((char)c);            }            fr.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行后输出如下：</strong></p><p><a href="https://up.media.everdo.cn/image/nDLL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/FileReader.png" alt="FileReader.png"></a></p><blockquote><p>注意：字符输入流的 read() 方法返回的是 int 类型的值，如果想获得字符就需要进行强制类型转换。</p></blockquote><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>要向文件中写入字符就需要使用 File Writer 类，该类是 Writer 的一个子类</p><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.File;import java.io.FileWriter;import java.io.IOException;public class FileWriterTest {    public static void main(String[] args) {        File file;        try {            FileWriter fr = new FileWriter(&quot;src/test6.txt&quot;);            String s = &quot;Hi Emptinessboy!\n&quot;;            fr.write(s);            fr.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nYFc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/FileWriter.png" alt="FileWriter.png"></a></p><p>File Writer 同 FileOutputStream 一样，如果指定的文件不存在， 就会先创建文件，再写入数据，如果文件存在，则会首先清空文件中的内容，再进行写入。如果想在文件末尾追加数据，同样需要调用重载的构造方法，</p><p>修改之前代码的 FileWriter：</p><pre><code class="java">FileWriter fr = new FileWriter(&quot;src/test6.txt&quot;, true) ;</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nb92" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/FileWriterAppend.png" alt="FileWriterAppend.png"></a></p><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符流同样提供了带缓冲区的包装流，分别是 BufferedReader 和 BufferedWriter 。</p><blockquote><p>需要注意的是，在 BufferedReader 中有一个重要的方法 readline()，该方法用于一次读取—行文本。</p></blockquote><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.*;public class BufferedRWCpoyFile {    public static void main(String[] args) {        try {            BufferedReader br = new BufferedReader(new FileReader(&quot;src/test7.txt&quot;));            BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;src/test8.txt&quot;));            String s;            while (true){                s = br.readLine();                if(s==null)                    break;                bw.write(s);                bw.newLine();            }            bw.close();            br.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/ndOZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/BufferedRWCopyFilepng.png" alt="BufferedRWCopyFilepng.png"></a></p><p>上述案例使用了输入输出流缓冲区对象，并通过 while 循环实现了文本文件的拷贝。在拷贝过程中， 每次循环都使用 readline() 方法读取文件的—行，然后通过 write() 方法写入目标文件。其中， readline() 方法会逐个读取字符， 当读到回车符 ‘\r’ 或换行符 ‘\n’ 时会将读到的字符作为一行的内容返回。</p><blockquote><p>需要注意的是，由于字符缓冲流内部使用了缓冲区，在循环中调用 BufferedWriter 的 write() 方法写入字符时， 这些字符首先会被写入缓冲区， 当缓冲区写满时或调用close() 方法时，缓冲区中的字符才会被写入目标文件。</p><p><strong>因此在循环结束时一定要调用close() 方法，否则极有可能会导致部分存在缓冲区中的数据没有被写入目标文件。</strong>i</p></blockquote><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>前面提到 IO 流可分为字节流和字符流，有时字节流和字符流之间也需要进行转换。在 JDK 中提供了两个类可以将字节流转换为字符流，它们分别是 InputStreamReader 和<br>OutputStreamWriter。</p><ul><li><p>InputStreamReader 是 Reader 的子类，它可以将一个字节输入流转换成字符输入流，方便直接读取字符。（读取字节流，最终读入字符流）</p></li><li><p>OutputStreamWriter 是 Writer 的子类，它可以将—个字节输出流转换成字符输出流，方便直接写入字符。（输入字符流，最终输出字节流）</p></li></ul><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><a href="https://up.media.everdo.cn/image/ni7k" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/27/IOStreamReader.png" alt="IOStreamReader.png"></a></p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>准备 test9.txt ，里面随便写入两行话：</p><p><a href="https://up.media.everdo.cn/image/nrxB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/test9.txt.png" alt="test9.txt.png"></a></p><pre><code class="java">import java.io.*;public class IOStreamRW {    public static void main(String[] args) {        try {            FileInputStream fin = new FileInputStream(&quot;src/test9.txt&quot;);            InputStreamReader ir = new InputStreamReader(fin); //转换为字符流            BufferedReader br = new BufferedReader(ir); //缓冲            FileOutputStream fout = new FileOutputStream(&quot;src/test10.txt&quot;); //写入字节流            OutputStreamWriter or = new OutputStreamWriter(fout); //转换为字符流            BufferedWriter bw = new BufferedWriter(or); //缓冲            String s;            while ((s=br.readLine())!=null){                bw.write(s);                bw.newLine();            }            bw.close();            br.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nQXt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/test10.txt.png" alt="test10.txt.png"></a></p><blockquote><p>字节流和字符流之间的转换，将字节流转换为字符流，从而实现直接对字符的读写。<strong>需要注意的是，在使用转换流时，只能针对操作文本文件的字节流进行转换</strong>，如果字节流操作的是一张图片，此时转换为字符流就会造成数据丢失。</p></blockquote><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>File 类封装了一个路径，并提供了一系列的方法用于操作该路径所指向的文件。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>构造方法：</strong></p><table><thead><tr><th>方法声明</th><th>功能描述r</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过指定的一个字符串类型的文件路径来创建一个新的 File 对象</td></tr><tr><td>File(String parent,String child)</td><td>根据指定的—个字符串类型的父路径和—个字符串类型的子路径（包括文件名称）创建—个 File 对象</td></tr><tr><td>File(File parent,String child)</td><td>根据指定的 File 类的父路径和字符串类型的子路径（包括文件名称）创建一个 File 对象</td></tr></tbody></table><p>如果程序只处理—个目录或文件，并且知道该目录或文件的路径，使用第一个构造方法较方便。如果程序处理的是—个公共目录中的若干子目录或文件，那么使用第 2 个或者第 3 个构造方法会更方便。</p><p><strong>使用方法：</strong></p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>boolean exists()</td><td>判断 File 对象对应的文件或目录是否存在，若存在则返回 ture, 否则返回 false</td></tr><tr><td>boolean delete()</td><td>删除 File 对象对应的文件或目录，若成功删除则返回 true, 否则返回 false</td></tr><tr><td>boolean createNewFile()</td><td>当 File 对象对应的文件不存在时，该方法将新建—个此 File 对象所指定的新文件，若创建成功则返回 true, 否则返回 false</td></tr><tr><td>String getName()</td><td>返回File 对象表示的文件或文件夹的名称</td></tr><tr><td>String getPath()</td><td>返回File 对象对应的路径</td></tr><tr><td>String getAbsolutePath()</td><td>返回FIIe 对象对应的绝对路径（在 UNIX/Linux 等系统上，如果路径是以正斜线／开始的，则这个路径是绝对路径；在 Windows 等系统上，如果路径是从盘符开始的，则这个路径是绝对路径）</td></tr><tr><td>String getParent()</td><td>返回 File 对象对应目录的父目录（即返回的目录不包含最后一级子目录）</td></tr><tr><td>boolean canRead()</td><td>判断 File 对象对应的文件或目录是否可读，若可读则返回 true, 反之返回 false</td></tr><tr><td>boolean canWrite()</td><td>判断 File 对象对应的文件或目录是否可写，若可写则返回 true , 反之返回 false</td></tr><tr><td>boolean is File()</td><td>判断 File 对象对应的是否是文件（不是目录），若是文件则返回 true, 反之返回 false</td></tr><tr><td>boolean isDirectory()</td><td>判断 File 对象对应的是否是目录（不是文件）， 若是目录则返回 true , 反之返回 false</td></tr><tr><td>boolean isAbsolute()</td><td>判断 File 对象对应的文件或目录是否是绝对路径</td></tr><tr><td>long lastModfied()</td><td>返回 1970 年 1 月1 日 0 时 0 分 0 秒到文件最后修改时间的毫秒值</td></tr><tr><td>long length()</td><td>返回文件内容的长度</td></tr><tr><td>String[] List()</td><td>列出指定目录的全部内容，只是列出名称</td></tr><tr><td>File[] listFiles()</td><td>返回一个包含了 File 对象所有子文件和子目录的 File 数组</td></tr></tbody></table><h4 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="DEMO"></a>DEMO</h4><pre><code class="java">import java.io.File;public class FileClass {    public static void main(String[] args) {        File f = new File(&quot;src/test11.txt&quot;);        //获取文件名        System.out.println(&quot;文件名称：&quot;+f.getName());        //获取相对路径        System.out.println(&quot;相对路径：&quot;+f.getPath());        //获取绝对路径        System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath());        //获取父路径        System.out.println(&quot;父路径：&quot;+f.getParent());        //获取最后修改时间        System.out.println(&quot;最后修改时间：&quot;+f.lastModified());        //得到文件大小        System.out.println(&quot;文件大小为：&quot;+f.length()+&quot;Bytes&quot;);        //判断文件是否可读        System.out.println(f.canRead()?&quot;可读&quot;:&quot;不可读&quot;);        //判断是否可写        System.out.println(f.canWrite()?&quot;可写&quot;:&quot;不可写&quot;);        //判断是不是文件        System.out.println(f.isFile()?&quot;是文件&quot;:&quot;不是文件&quot;);        //判断是不是目录        System.out.println(f.isDirectory()?&quot;是目录&quot;:&quot;不是目录&quot;);        //判断是不是绝对路径        System.out.println(f.isAbsolute()?&quot;是绝对路径&quot;:&quot;不是绝对路径&quot;);        //是否成功删除文件        System.out.println(&quot;删除成功？&quot;+f.delete());    }}</code></pre><p><strong>运行效果：</strong></p><p>未创建目标文件 test11.txt 时：</p><p><a href="https://up.media.everdo.cn/image/nxHx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/FileClass.png" alt="FileClass.png"></a></p><p>已存在目标文件 test11.txt 时：</p><p><a href="https://up.media.everdo.cn/image/nWdI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/FileClass1.png" alt="FileClass1.png"></a></p><h3 id="遍历目录下的文件"><a href="#遍历目录下的文件" class="headerlink" title="遍历目录下的文件"></a>遍历目录下的文件</h3><p>File 方法中有—个list() 方法，该方法用于遍历某个指定目录下的所有文件的名称：</p><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.File;public class ListFile {    public static void main(String[] args) {        File f = new File(&quot;src/自学IO操作&quot;);        String[] file = f.list();        int i=0;        for(String s:file){            if(i%4==0)                System.out.println();            System.out.print(s+&quot; &quot;);            i++;        }        System.out.println();    }}</code></pre><p><strong>运行后输出如下：</strong></p><p><a href="https://up.media.everdo.cn/image/n60X" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/FileList.png" alt="FileList.png"></a></p><p>有时程序只是需要得到指定类型的文件，如获取指定目录下所有的 “java” 文件。针对这种需求，File 类中提供了一个重载的 list(FilenameFilter filter) 方法，该方法接收—个 FilenameFilter 类型的参数。</p><h4 id="过滤后缀名"><a href="#过滤后缀名" class="headerlink" title="过滤后缀名"></a>过滤后缀名</h4><p>FilenameFilter 是一个接口，被称作文件过滤器，当中定义了一个抽象方法 accept(File dir,String name)。在调用 list() 方法时，需要实现文件过滤器 FilenameFilter, 并在 accept() 方法中做出判断，从而获得指定类型的文件。</p><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.File;import java.io.FilenameFilter;public class ListFileFilter {    public static void main(String[] args) {        File f = new File(&quot;src&quot;);        FileFilter ff = new FileFilter();        if(f.exists()){            String[] s = f.list(ff);  //传入接口            int i=0;            for(String temp:s){                if(i%4==0)                    System.out.println();                System.out.print(temp+&quot; &quot;);                i++;            }            System.out.println();        }    }}class FileFilter implements FilenameFilter{ //实现接口方法    @Override    public boolean accept(File dir, String name) {        if(dir.exists()&amp;&amp;name.endsWith(&quot;.png&quot;))            return true;  //png结尾的返回true        return false;    }}</code></pre><p><a href="https://up.media.everdo.cn/image/nN8i" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/FileFilter.png" alt="FileFilter.png"></a></p><p>在接口 FilenameFilter 的 accept() 方法中， 对当前正在遍历的 dir 对象进行了判断，只有当 dir 对象代表文件，并且扩展名为 “.png” 时，才返回 true。在调用 File 对象的 list() 方法时， 将 filter 过滤器对象传入，就得到了包含所有 “.png” 文件名字的字符串数组</p><h4 id="遍历目录树（原创代码）"><a href="#遍历目录树（原创代码）" class="headerlink" title="遍历目录树（原创代码）"></a>遍历目录树（原创代码）</h4><p>在—个目录下，除了文件，还有子目录，如果想得到所有子目录下的 File 类型对象，list() 方法显然不能满足要求，这时需要使用 File 类提供的另一个方法 listFiles()</p><pre><code class="java">import java.io.File;public class ListFilesTest {    public static void main(String[] args) {        File f = new File(&quot;src&quot;);        ListFileTree tree = new ListFileTree();        tree.listTree(f);    }}</code></pre><p><strong>实现的类代码：</strong></p><pre><code class="java">//自个写了给列出文件树类class ListFileTree{    int i=0;    void listTree(File f){        File[] fl = f.listFiles();        for(File temp:fl){  //遍历文件序列            for(int j=0;j&lt;i;j++)                System.out.print(&quot;\t&quot;);  //打印缩进空格            if(temp.isDirectory()){                System.out.println(&quot;&gt;&gt; &quot;+temp.getName()); //是文件夹的话，就加两个箭头区分                i++;  //统计文件夹层级                listTree(temp); //递归列出子目录            }            else                System.out.println(temp.getName());        }        i=0;  //一个父文件夹列完后，将层级清零    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nm34" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/ListFileTree.png" alt="ListFileTree.png"></a></p><p><strong>资源管理器的文件结构：</strong></p><p><a href="https://up.media.everdo.cn/image/n99M" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/ListFileTree1.png" alt="ListFileTree1.png"></a></p><p>可以看到，打印出来的树和系统资源管理器显示的完全一致！</p><h3 id="删除文件及目录"><a href="#删除文件及目录" class="headerlink" title="删除文件及目录"></a>删除文件及目录</h3><p>可以使用 File 类的 delete() 方法删除文件。</p><p>(基本的删除用法)[#DEMO-1]，会返回一个 boolean 值来反馈是否成功删除文件。但是对于文件夹（目录），无法使用简单的 delete 来一次性删除，必须一个个将文件夹内文件删除后，才能删除文件夹。</p><p><strong>DEMO：</strong></p><pre><code class="java">import java.io.File;public class DeleteFolder {    public static void main(String[] args) {        File f = new File(&quot;src/rubbish&quot;);        System.out.println(deleteDir(f));;    }    //递归删除函数    static boolean deleteDir(File f){        if(f.exists()){            File[] fl =f.listFiles();            for(File temp:fl){                if(temp.isDirectory())                    deleteDir(temp);                else                    temp.delete();            }            return f.delete();        }        else            return false;    }}</code></pre><p><strong>运行前目录：</strong></p><p><a href="https://up.media.everdo.cn/image/nEUY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/rubbishFile.png" alt="rubbishFile.png"></a></p><p><strong>运行后效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nf7a" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/28/deleteRubbishFile.png" alt="deleteRubbishFile.png"></a></p><p>可以看到文件被删除，并且返回了 true。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程学习</title>
      <link href="/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>每个运行的程序都是一个进程，在一个进程中还可以有多个执行单元同时运行。这些执行单元可以看作程序执行的—条条线索，被称为线程。操作系统中的每—个进程中都至少存在—个线程。例如当一个 Java 程序启动时，就会产生—个进程，该进程中会默认创建一个线程，在这个线程上会运行 main() 方法中的代码。</p></blockquote><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>在 Java 中提供了两种多线程实现方式， —种是继承 java.lang 包下的 Thread 类，覆写 Thread 类的 run() 方法，在 run() 方法中实现运行在线程上的代码；另一种是实现 java.lang.Runnable 接口，同样是在 run() 方法中实现运行在线程上的代码。</p><h3 id="直接继承-Thread"><a href="#直接继承-Thread" class="headerlink" title="直接继承 Thread"></a>直接继承 Thread</h3><p>JDK 中提供了—个线程类Thread , 通过继承 Thread 类，并重写 Thread 类中的 run() 方法便可实现多线程。在 Thread 类中，提供了一个 start() 方法，用千启动新线程。线程启动后，虚拟机会自动调用 run() 方法，如果子类重写了，该方法便会执行子类中的方法。</p><pre><code class="java">public class TwoThread {    public static void main(String[] args) {        new PrintThread1(&quot;线程A&quot;).start();        new PrintThread1(&quot;线程B&quot;).start();    }}class PrintThread1 extends Thread{    public PrintThread1(String name) {        super(name);    }    @Override    public void run() {;        for (int i=0;i&lt;1000;i++){            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);            try {                sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hOYX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/TwoThread.png" alt="TwoThread.png"></a></p><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>继承Thread 类实现了多线程，但是这种方式有—定的局限性。因为Java中只支持单继承，一个类一旦继承了某个父类就无法再继承Thread 类，例如学生类Student 继<br>承了Person 类，就无法通过继承Thread 类创建线程。</p><p>为了克服这种弊端， Thread 类提供了另外一个构造方法 Thread(Runnable target) ，其中，Runnable 是一个接口， 它只有—个 run() 方法。当通过 Thread(Runnable target)）构造方法创建线程对象时，只需为该方法传递—个实现了 Runnable 接口的实例对象，这样创建的线程将调用实现了 Runnable 接口的类中的 run() 方法作为运行代码，而不需要调用 Thread 类中的 run() 方法</p><h4 id="法A：创建多个线程对象"><a href="#法A：创建多个线程对象" class="headerlink" title="法A：创建多个线程对象"></a>法A：创建多个线程对象</h4><pre><code class="java">import static java.lang.Thread.sleep;public class ThreadRunnable {    public static void main(String[] args) {        PrintThread2 xc1 = new PrintThread2(&quot;线程a&quot;);        PrintThread2 xc2 = new PrintThread2(&quot;线程b&quot;);        PrintThread2 xc3 = new PrintThread2(&quot;线程c&quot;);        new Thread(xc1).start();        new Thread(xc2).start();        new Thread(xc3).start();    }}class PrintThread2 implements Runnable{    String name;    public PrintThread2(String name) {        this.name=name;    }    @Override    public void run() {        for (int i=0;i&lt;1000;i++){            System.out.println(this.name+&quot; 第&quot;+i+&quot;次&quot;);            try {                sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hUzi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThread.png" alt="RunnableThread.png"></a></p><h4 id="法B：仅创建一个线程的对象（推荐）"><a href="#法B：仅创建一个线程的对象（推荐）" class="headerlink" title="法B：仅创建一个线程的对象（推荐）"></a>法B：仅创建一个线程的对象（推荐）</h4><p>这种方法，相比刚才的，可以在多个线程中同时使用线程对象 PrintThread3 中的某个变量。</p><pre><code class="java">import static java.lang.Thread.currentThread;import static java.lang.Thread.sleep;public class ThreadRunnablePlus {    public static void main(String[] args) {        PrintThread3 xc= new PrintThread3();        //构造方法Thread(Runnable target, String name)在创建线程对象的同时指定线程的名称，        new Thread(xc,&quot;线程1&quot;).start();        new Thread(xc,&quot;线程2&quot;).start();        new Thread(xc,&quot;线程3&quot;).start();    }}class PrintThread3 implements Runnable{    int n=0;    @Override    public void run() {        for (int i=0;i&lt;1000;i++){            //打印当前线程名和次数            n++;            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);            try {                sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hKmY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-nolock.png" alt="RunnableThreadPlus-nolock.png"></a></p><p>细心的童鞋，可能在这里就发现问题了，貌似总数统计出现的顺序有问题？yep，这个问题且听下面 线程同步 的小节分解。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程去访问同一个资源时，也会引发一些安全问题。例如下面的代码段，我们把循环终止的条件改为 总次数n 小于等于10：</p><pre><code class="java">public class ThreadRunnablePlus {    public static void main(String[] args) {        PrintThread3 xc= new PrintThread3();        new Thread(xc,&quot;线程1&quot;).start();        new Thread(xc,&quot;线程2&quot;).start();        new Thread(xc,&quot;线程3&quot;).start();    }}class PrintThread3 implements Runnable{    int n=0;    @Override    public void run() {        int i=0;        for (;n&lt;=10;n++){            //打印当前线程名和次数            i++;            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hLwa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-nonelock0.png" alt="RunnableThreadPlus-nonelock0.png"></a></p><p>按理说，在 n 为 10 的时候，应该结束所有线程。但事实上，在这之后，还有语句输出</p><p>像现在碰到的计数错误的情况就是因为多个线程同时访问对象中的变量 n 导致的。为了解决这样的问题，需要 <strong><em>实现多线程的同步</em></strong> ，即限制某个资源在同一时刻只能被一个线程访问。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>线程安全问题其实就是由多个线程同时处理共享资源所导致的。要想解决线程安全问题，必须得保证用于处理共享资源的代码在任何时刻只能有—个线程访问。</p><p>比如刚才例子中的这一段：</p><pre><code class="java">for (;n&lt;=10;n++){    //打印当前线程名和次数    i++;    System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);}</code></pre><h4 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h4><p>Java 中提供了同步机制。当多个线程使用同—个共享资源时，可以将处理共享资源的代码放在一个使用 synchronized 关键字来修饰的代码块中，这个代码块被称作同步代码块，</p><pre><code class="java">Object lock= new Object(); //定义任意一个对象，用作同步代码块的锁synchronized (lock) {    //操作共享资源代码块}</code></pre><h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><p>我们将刚才出现异常的代码做出如下改进，将循环套上同步锁 synchronized：</p><pre><code class="java">class PrintThread3 implements Runnable{    int n=0;    @Override    public void run() {        int i=0;        synchronized (this){            for (;n&lt;=10;n++){                //打印当前线程名和次数                i++;                System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);            }        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hans" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-locked.png" alt="RunnableThreadPlus-locked.png"></a></p><p>可以看到，后面的计数都完全正常了，可是线程2和3却没有运行。</p><p>这是因为因为整个循环体的代码块都被线程1阻塞了，等线程2和3得到同步锁的时候，n的值已经为11了，无法再次进入循环了。</p><p>因此，这里的<strong>同步锁应当放在循环体内</strong>，同时将 for 循环改为 while 循环可以很好的解决问题：</p><pre><code class="java">class PrintThread3 implements Runnable{    int n=1;    @Override    public void run() {        int i=0;        while (true){            i++;            synchronized (this){                if(n&lt;=10){                    //打印当前线程名和次数                    System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);                    n++;                }else                    break;            }            //为了演示，防止运行过快，加了这段延时代码            try {                sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}s</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hgq3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-locksuccess.png" alt="RunnableThreadPlus-locksuccess.png"></a></p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>除了同步代码块，在方法前面同样可以使用 synchronized 关键字来修饰，被修饰的方法为同步方法， 它能实现与同步代码块相同的功能，具体语法格式如下。</p><pre><code class="java">synchronized 返回值类型 方法名([参数1 ,^ ]) {    //方法体}</code></pre><p>被 synchronized 修饰的方法在某—时刻只允许一个线程访问，访问该方法的其他线程都会<br>发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。</p><h4 id="实现案例-1"><a href="#实现案例-1" class="headerlink" title="实现案例"></a>实现案例</h4><p>这里我们将同一个案例改为使用方法同步来实现：</p><pre><code class="java">class PrintThread3 implements Runnable{    int n=1;    boolean fin = true;    @Override    public void run() {        int i=0;        while (fin){            i++;            doNum(i);            //减慢运行速度便于观察            try {                sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    //方法锁    synchronized void doNum(int i){        if(n&lt;=10){            //打印当前线程名和次数            System.out.println(currentThread().getName()+&quot; 第&quot;+i+&quot;次，一共第&quot;+n+&quot;次&quot;);            n++;        }else            fin=false;    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/hlTG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/RunnableThreadPlus-methodlock.png" alt="RunnableThreadPlus-methodlock.png"></a></p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程都需要对方所占用的锁，但是都无法释放自己所拥有的锁，于是这两个线程都处于挂起状态，从而造成了死锁。</p><pre><code class="java">public class SyncDie implements Runnable{    static Object a = new Object();    static Object b = new Object();    boolean flag;    @Override    public void run() {        if(flag){            while (true){                synchronized (a) {                    System.out.println(&quot;a1&quot;);                    synchronized (b) {                        System.out.println(&quot;b1&quot;);                    }                }            }        }        else{            while (true){                synchronized (b) {                    System.out.println(&quot;b2&quot;);                    synchronized (a) {                        System.out.println(&quot;a2&quot;);                    }                }            }        }    }    public SyncDie(boolean flag) {        this.flag = flag;    }    public static void main(String[] args) {        SyncDie s1 = new SyncDie(true);        SyncDie s2 = new SyncDie(false);        new Thread(a).start();        new Thread(b).start();    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/n449" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/synchronize-die.png" alt="synchronize-die.png"></a></p><p>可以看到，两个线程一直在运行并没有退出，因为线程 s1 先锁定了 a，线程 s2 锁定了 b；然后 s1 要获取 b 才能继续运行并释放 a，但是 s2 只有等 s1 释放 a 了，才能继续运行然后释放 b……</p><p>听起来很绕，没错，这就像套娃。（拒绝套娃，从不写死锁开始。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在 Java 中，任何对象都有生命周期，线程也不例外，它也有自己的生命周期。当 Thread<br>对象创建完成时，线程的生命周期便开始了。当 run() 方法中代码正常执行完毕或者线程抛出一个未捕获的异常 (Exception) 或者错误 (Error) 时，线程的生命周期便会结束。</p><h3 id="几个阶段"><a href="#几个阶段" class="headerlink" title="几个阶段"></a>几个阶段</h3><p>线程整个生命周期可以分为 5 个阶段，分别是新建状态 (New)、就绪状态 (Runnable)、运行状态 (Running)、阻塞状态 (Blocked) 和死亡状态 (Terminated) ，线程的不同状态表明了线程当前正在进行的活动。在程序中，通过—些操作，可以使线程在不同状态之间转换，</p><p><a href="https://up.media.everdo.cn/image/nHbj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadLifeTime.png" alt="ThreadLifeTime.png"></a></p><h4 id="新建状态-New"><a href="#新建状态-New" class="headerlink" title="新建状态(New)"></a>新建状态(New)</h4><p>创建—个线程对象后，该线程对象就处千新建状态，此时它不能运行，和其他Java 对象一<br>样，仅仅由Java 虚拟机为其分配了内存，没有表现出任何线程的动态特征。</p><h4 id="就绪状态-Runnable"><a href="#就绪状态-Runnable" class="headerlink" title="就绪状态(Runnable)"></a>就绪状态(Runnable)</h4><p>当线程对象调用了 start() 方法后，该线程就进入就绪状态。处于就绪状态的线程位于线程队列中，此时它只是具备了运行的条件，能否获得 CPU 的使用权并开始运行，还需要等待系统的调度。</p><h4 id="运行状态-Running"><a href="#运行状态-Running" class="headerlink" title="运行状态(Running)"></a>运行状态(Running)</h4><p>如果处于就绪状态的线程获得了 CPU 的使用权，并开始执行 run() 方法中的线程执行体，则该线程处于运行状态。</p><h4 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a>阻塞状态(Blocked)</h4><p>—个正在执行的线程在某些特殊情况下，如被人为挂起或执行耗时的输入／输出操作时，会<br>让出CPU 的使用权并暂时中止自己的执行，进入阻塞状态。线程进入阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p><blockquote><p>获取某个对象的同步锁；调用了一个阻塞式的 IO 方法；调用了某个对象的 wait() 方法【需要使用 notify() 方法唤醒该线程】；程调用了 Thread 的 sleep(long miles) 方法；调用了另—个线程的 join() 方法【需要等待被插入的线程执行完毕】</p><p><strong>这些都会导致当前线程被阻塞</strong></p></blockquote><h4 id="死亡状态-Terminated"><a href="#死亡状态-Terminated" class="headerlink" title="死亡状态(Terminated)"></a>死亡状态(Terminated)</h4><p>当线程调用 stop() 方法【stop已弃用】或 run() 方法正常执行完毕后，或者线程抛出一个未捕获的异常 (Exception)、错误(Error)，<strong>线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。</strong>（就是废了）</p><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>在计算机中，线程调度有两种模型，分别是分时调度模型和抢占式调度模型。</p><blockquote><p><strong>分时调度模型：</strong> 让所有的线程轮流获得CPU 的使用权，并且平均分配每个线程占用的CPU 的时间片。</p><p><strong>抢占式调度模型 (JAVA)：</strong> 让可运行池中优先级高的线程优先占用 CPU, 而对于优先级相同的线程，随机选择—个线程使其占用 CPU, 当它失去了 CPU 的使用权后，再随机选择其他线程获取 CPU使用权。</p></blockquote><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><table><thead><tr><th>Thread 类的静态常量</th><th>功能描述</th></tr></thead><tbody><tr><td>static int MAX_ PRIORITY</td><td>表示线程的最高优先级，值为10</td></tr><tr><td>static int MIN_PRIORITY</td><td>表示线程的最低优先级， 值为1</td></tr><tr><td>static int NORM_PRIORITY</td><td>表示线程的晋通优先级， 值为5</td></tr></tbody></table><p>可以通过Thread 类的 setPriority(int newPriority) 方法对其进行设置，该方法中的参数 newPriority 接收的是 1~10 之间的整数或者 Thread 类的 3 个静态常量。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {    public static void main(String[] args) {        Thread a = new PrintThread1(&quot;线程A&quot;);        Thread b = new PrintThread1(&quot;线程B&quot;);        a.setPriority(Thread.MIN_PRIORITY);        b.setPriority(Thread.MAX_PRIORITY);        a.start();        b.start();    }}class PrintThread1 extends Thread{    public PrintThread1(String name) {        super(name);    }    @Override    public void run() {        for (int i=0;i&lt;10;i++){            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nJzO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadsetPriority.png" alt="ThreadsetPriority.png"></a></p><p>可以看到，在设置了优先级后，线程B比线程A更早运行。当然这并不代表A只能等B运行完了才能运行。只是开始时间B会早于A，很有可能A会在B阻塞时启动。</p><blockquote><p>注意：不同的操作系统对优先级的支持是不—样的， 不会与 Java 中线程优先级——对应。因此，在设计多线程应用程序时，其功能的实现一定不能依赖于线程的优先级，而只能把线程优先级作为一种提高程序效率的手段。</p></blockquote><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>如果希望人为地控制线程，使正在执行的线程暂停，将 CPU 让给别的线程，这时可以使用静态方法 sleep(long millis)，该方法可以让当前正在执行的线程暂停一段时间，进入休眠等待状态。</p><p>Sleep(long millis) 方法声明会抛出 Interrupted Exception 异常，因此在调用该方法时应该捕获异常，或者声明抛出该异常。</p><p><strong>调用格式如下：</strong></p><pre><code class="java">try {    sleep(1000);} catch (InterruptedException e) {    e.printStackTrace();}</code></pre><blockquote><p>需要注意的是， sleep() 是静态方法，只能控制当前正在运行的线程休眠，而不能控制其他线程休眠。当休眠时间结束后，线程就会返回到就绪状态，而不是立即开始运行。</p></blockquote><h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p>所谓的线程让步是指正在执行的线程，在某些情况下将 CPU 资源让给其他线程执行。</p><p>线程让步可以通过 yield() 方法来实现，该方法和 sleep() 方法有点相似，都可以让当前正在运行的线程暂停，区别在于 yield() 方法不会阻塞该线程，它只是将线程转换成就绪状态，让系统的调度器重新调度一次。当某个线程调用 yield() 方法之后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {    public static void main(String[] args) {        Thread a = new PrintThread1(&quot;线程A&quot;);        Thread b = new PrintThread1(&quot;线程B&quot;);        b.start();  //线程b先启动        a.start();    }}class PrintThread1 extends Thread{    public PrintThread1(String name) {        super(name);    }    @Override    public void run() {        //super.run();        for (int i=0;i&lt;10;i++){            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);            if(this.getName().equals(&quot;线程B&quot;)){                System.out.println(&quot;线程B让步&quot;);                this.yield();            }        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nPL6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/Thread-yield.png" alt="Thread-yield.png"></a></p><p>可以看到每次让步后，线程A就会排在前面执行。多次让步最后线程A率先运行完成。</p><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>在 Thread 类中也提供了一个 join() 方法来实现这个“功能” 。当在某个线程中调用其他线程的 join() 方法时，调用的线程将被阻塞，直到被 join() 方法加入的线程执行完成后它才会继续运行。</p><p><strong>样例：</strong></p><pre><code class="java">public class TwoThread {    public static void main(String[] args) {        Thread a = new PrintThread1(&quot;线程A&quot;);        a.start();        for (int i=0;i&lt;10;i++){            System.out.println(&quot;Main方法 第&quot;+i+&quot;次&quot;);            if(i==3) {                try {                    System.out.println(&quot;a插队进来了&quot;);                    a.join();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}class PrintThread1 extends Thread{    public PrintThread1(String name) {        super(name);    }    @Override    public void run() {        //super.run();        for (int i=0;i&lt;5;i++){            System.out.println(this.getName()+&quot; 第&quot;+i+&quot;次&quot;);        }    }}</code></pre><p><strong>运行效果：</strong></p><p><a href="https://up.media.everdo.cn/image/nhFn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/25/ThreadJoin.png" alt="ThreadJoin.png"></a></p><p>可以看到，线程A插队进来后，Main方法必须等线程A执行完毕才能继续执行。</p><h2 id="线程协作关系"><a href="#线程协作关系" class="headerlink" title="线程协作关系"></a>线程协作关系</h2><p>当多个线程为完成同一任务而分工协作时，它们彼此之间有联系，知道其他线程的存在，而且受其他线程执行的影响，这些线程间存在协作关系。</p><p>协作线程之间相互等待以协调进度的过程被称为线程同步。两个以上线程基于某个条件来协调它们的活动。一个线程的执行依赖于另一个协作线程的消息或信号，当线程没有得到来自于另一个线程的消息或信号时需等待，直到消息或信号到达才被唤醒。</p><h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h3><pre><code class="java">//线程同步:wait()  //挂起一个线程notify()    //唤醒线程notifyAll() //唤醒全部线程</code></pre><p><strong>wait()方法：</strong> 该方法用来使得当前线程进入等待状态，直到接到通知或者被中断打断为止。在调用wait()方法之前，线程必须要获得该对象的对象级锁；<strong><em>换句话说就是该方法只能在同步方法或者同步块中调用，如果没有持有合适的锁的话，线程将会抛出异常 IllegalArgumentException。</em></strong> 调用wait()方法之后，当前线程则释放锁。</p><p><strong>notify()方法：</strong> 该方法用来唤醒处于等待状态获取对象锁的其他线程。如果有多个线程则线程规划器任意选出一个线程进行唤醒，使其去竞争获取对象锁，但线程并不会马上就释放该对象锁，wait() 所在的线程也不能马上获取该对象锁，要程序退出同步块或者同步方法之后，当前线程才会释放锁，wait() 所在的线程才可以获取该对象锁。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>wait() 方法是释放锁的；notify() 方法不释放锁，必须等到所在线程把代码执行完。</p></li><li><p>由于 notify() 唤醒了一个随机线程，因此它可用于实现线程执行类似任务的互斥锁定，但在大多数情况下，实现 notifyAll() 会更可行。</p></li><li><p>建议使用 <strong>while循环</strong> 搭配一个公用的 boolean flag 食用更香！</p></li></ul><h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><h3 id="为什么弃用-stop-和-suspend"><a href="#为什么弃用-stop-和-suspend" class="headerlink" title="为什么弃用 stop 和 suspend"></a>为什么弃用 stop 和 suspend</h3><p>初始的 java 版本中定义了一个 stop 方法来终止一个线程还定义了一个 suspend 方法来阻塞一个线程，直到另一个线程调用 resume 方法。这两个方法在 Java SE 1.2 之后就被弃用了，因为这两种方法都不安全。</p><blockquote><p>stop 方法天生就不安全，因为它在终止一个线程时会强制中断线程的执行，不管 run 方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象。这一现象会被其它因为请求锁而阻塞的线程看到，使他们继续向下执行。这就会造成数据的不一致。</p><p>suspend 被弃用的原因是因为它会造成死锁。suspend 方法和 stop 方法不一样，它不会破换对象和强制释放锁，相反它会一直保持对锁的占有，一直到其他的线程调用 resume 方法，它才能继续向下执行。</p></blockquote><h3 id="正确的终止一个线程"><a href="#正确的终止一个线程" class="headerlink" title="正确的终止一个线程"></a>正确的终止一个线程</h3><p>可以采用设置一个条件变量的方式，run 方法中的 while 循环会不断的检测 flag 的值，在想要结束线程的地方将 flag 的值设置为 false 就可以啦！</p><blockquote><p>注意这里要将 flag 设置成 volitale 的，因为 volitale 可以保证数据的有效性，如果不设置话，可能会造成子线程多执行一次的错误</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>网络资料：</strong></p><p>volatile 的作用就是把放在线程栈上的变量立刻同步到主内存中，这里涉及到 Java 内存模型的知识。</p><blockquote><p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p></blockquote><p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><p>多个线程间变量的同步都是先同步到主内存中，然后主内存再同步到其他线程的变量副本上，但无法保证同步是立刻执行的，加 volatile 之后会立刻同步。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原来偷跑云服务器流量的罪魁祸首是TA！</title>
      <link href="/2020/05/%E5%8E%9F%E6%9D%A5%E5%81%B7%E8%B7%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E9%87%8F%E7%9A%84%E7%BD%AA%E9%AD%81%E7%A5%B8%E9%A6%96%E6%98%AFTA%EF%BC%81/"/>
      <url>/2020/05/%E5%8E%9F%E6%9D%A5%E5%81%B7%E8%B7%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E9%87%8F%E7%9A%84%E7%BD%AA%E9%AD%81%E7%A5%B8%E9%A6%96%E6%98%AFTA%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>（坑爹阿里云，偷跑血汗钱/dog</p><p>事情大概是这样的，每个月末都是我日常续费云服务器的日子。因为机子包年比较便宜，包年后只有带宽和CPU占用是按量付费，因此每个月一般只要往里面充值那么几块钱的流量费就差不多了。</p><p>但直到我昨天打开计费面板的时候，眼睁睁看到了我40G的流量包居然一周多一点的时间就被消耗殆尽了！！然后开始疯狂扣我的账户余额。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>看到这一幕的我显然是慌乱，照这样一个月跑下数百G的流量肯定不是问题。照这么来说，说不定哪一天我家的房子就归马云了（滑稽</p><p>赶紧打开服务器，使用 nload 看下当前的流量收发情况。</p><p><a href="https://up.media.everdo.cn/image/hfu0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/nloadtraffic.png" alt="nloadtraffic.png"></a></p><p>因为是一天前刚重启过云服务器，因此1.8GB的流量即一天产生的数据量（通过后台的统计报表可以看到，始终有进程以30多KB每秒的速率在上传数据。</p><h3 id="分析进程"><a href="#分析进程" class="headerlink" title="分析进程"></a>分析进程</h3><p>那么既然有异常流量的产生，那么就应该定位下，究竟是哪个进程导致了这些流量的产生。或许是某项服务，或许是不小心感染了木马。</p><p>统计进程流量这里使用的工具是：nethogs</p><blockquote><p>NetHogs是一个开源的命令行工具（类似于Linux的top命令），用来按进程或程序实时统计网络带宽使用率。</p><p>NetHogs是一个小型的net top工具，不像大多数工具那样拖慢每个协议或者是每个子网的速度而是按照进程进行带宽分组。NetHogs不需要依赖载入某个特殊的内核模块。如果发生了网络阻塞你可以启动NetHogs立即看到哪个PID造成的这种状况。这样就很容易找出哪个程序跑飞了然后突然占用你的带宽。</p></blockquote><p>安装方法：</p><pre><code class="bash">yum install libpcap libpcap-devel install epel-release -yyum install nethogs -y</code></pre><p>安装完成后，输入 nethogs 命令就可以直接运行了</p><p><a href="https://up.media.everdo.cn/image/hzYD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/nethogs.png" alt="nethogs.png"></a></p><p>一些交互式命令：</p><pre><code>m : 修改单位r : 按流量排序s : 按发送流量排序q : 退出命令提示符</code></pre><p>通过上图观察，可以看出当前占用带宽最高的进程是 nginx。</p><p>那么也就基本排除了中木马或者其他乱七八糟的问题了。但是 nginx 作为 webserver 持续的匀速产生流量显然是不正常的。</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>按照正常的思路到这一步为止基本就需要调出 nginx 的日志。看看究竟哪些网站在产生流量。事实上我也这么做了，可是日志上并没有找到任何持续产生流量的网站。</p><p>那么事情就变得更加诡异了。只要是 nginx 产生的 http 或者 https 访问，都会留下日志。那么究竟是何种情况可以在不留下日志的情况下，让 nginx 持续产生上行流星呢？（已经排除 nginx rtmp 推流和 TCP 反向代理的可能</p><p>继续观察，这时 nethogs 为我显示出了更为详细的通信信息</p><p><a href="https://up.media.everdo.cn/image/h1Kc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/nloadtraffic1.png" alt="nloadtraffic1.png"></a></p><p>copy了目标对象的IP地址，网上查了下，属于机房的ip，随手往阿里云cdn工具中一查。尼玛！这居然是阿里云cdn的节点！！</p><p><a href="https://up.media.everdo.cn/image/hv22" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/aliyunshitcdn.png" alt="aliyunshitcdn.png"></a></p><p>那么问题就更蹊跷了，为何我服务器的 nginx 的443端口会和阿里云的 cdn 节点那么亲密，而且不留下任何 http 的日志呢？</p><p><strong>为了捉住这背后的元凶，不得不对 nginx 进程进行抓包分析。</strong></p><p>抓包使用的工具是 tcpdump。安装过程非常简单：</p><pre><code class="bash">yum - y install tcpdump</code></pre><p><a href="https://up.media.everdo.cn/image/h0sL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/install-tcpdump.png" alt="install-tcpdump.png"></a></p><blockquote><p>tcpdump是一个用于截取网络分组，并输出分组内容的工具。凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具</p><p>tcpdump 支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息</p></blockquote><p>基本参数方法：</p><pre><code>抓包选项：-c：指定要抓取的包数量。-i interface：指定tcpdump需要监听的接口。默认会抓取第一个网络接口-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-P：指定要抓取的包是流入还是流出的包。可以给定的值为&quot;in&quot;、&quot;out&quot;和&quot;inout&quot;，默认为&quot;inout&quot;。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。</code></pre><p>安装完成了，试一波看看（</p><p>非常愉快的输入命令 tcpdump tcp port 443</p><p><a href="https://up.media.everdo.cn/image/hykZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/tcpdump443.png" alt="tcpdump443.png"></a></p><p>屏幕上瞬间输出了一大堆 tcp 的通信细节。具体到每个 ack - seq -fin。可是本宝宝看着满屏滚动的信息瞬间傻掉了好不好。（对不起，是我太菜。</p><h3 id="本地分析"><a href="#本地分析" class="headerlink" title="本地分析"></a>本地分析</h3><p>为了拯救像我那么笨的帅哥（dog，我决定想办法把抓包信息保存起来，下载回电脑慢慢分析。</p><p>想要把抓包信息存到文件的方法也很简单，只要在后面加上参数 -w 然后跟路径和文件名即可</p><pre><code class="bash">tcpdump tcp port 443 -w ./target.cap</code></pre><p>这波操作猛如虎，赶紧把生成的 cap 文件下载到电脑，使用 wireshark 进行数据分析。</p><p><a href="https://up.media.everdo.cn/image/hTwk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/zhuabaofenxi1.png" alt="zhuabaofenxi1.png"></a></p><p><a href="https://up.media.everdo.cn/image/hCnB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/zhuabaofenxi2.png" alt="zhuabaofenxi2.png"></a></p><p>通过分析可以看到，我那不听话的服务器和阿里云的 cdn 之间发生的 py 关系就是：</p><p>阿里云cdn节点始终不停的再向我服务器发送不带 host 的 https 连接（因为我的服务器对于空 host 会自动导向到 <a href="http://www.everdo.cn" target="_blank" rel="noopener">www.everdo.cn</a> ）。而一旦 https 握手请求建立完毕，就立刻断开当前连接，不再继续向往的服务器发送请求</p><blockquote><p>就好比，阿里云 cdn 节点就像隔壁小王，是不是来家里勾引一波我家的 nginx，nginx 刚有反应，就又不理人家了。而这背后还要我这个主子来承担产生的大量流量费（你说坏不坏，哼😕</p></blockquote><p>掌握了证据后，就赶紧联系来波阿里云客服，求证一波，这到底是咋回事。/dog</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>在客服长达数小时的请您稍等后，终于定位到了，原来是我在使用 阿里云cdn 的时候，设置了一主一备的两个ip，这就会触发 cdn 调度系统进行健康检查。</p><p>又一波操作后，我把cdn后端的备用源站ip删除了。经过几小时的观察，果然一切正常了。</p><p><a href="https://up.media.everdo.cn/image/hSQt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/trafficfix.png" alt="trafficfix.png"></a></p><p>鉴于我早在一年多前就开始使用 阿里云cdn 了，一直是使用一主一备的设置，从来没有出现这类问题。只能怀疑是阿里云产品进行升级导致的问题，当然这一点客服当然是不会承认的啦。</p><p>就这样，被阿里云白嫖了两个月百元多的流量费（哭</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维,服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真香！PowerShell就应该这么帅嘛！（以及 WindowsTerminal 使用</title>
      <link href="/2020/05/%E7%9C%9F%E9%A6%99%EF%BC%81PowerShell%E5%B0%B1%E5%BA%94%E8%AF%A5%E8%BF%99%E4%B9%88%E5%B8%85%E5%98%9B%EF%BC%81/"/>
      <url>/2020/05/%E7%9C%9F%E9%A6%99%EF%BC%81PowerShell%E5%B0%B1%E5%BA%94%E8%AF%A5%E8%BF%99%E4%B9%88%E5%B8%85%E5%98%9B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>开学第三周了，两个字描述自己的生活（颓废）。</p></blockquote><p>学校封闭式管理无法出门，寝室里熙熙攘攘凌晨一二点才睡。然而这一切都阻挡不了我是条咸鱼的事实。</p><p>无聊的刷着电脑的时候，突然对 Windows 自带的 PowerShell 心生歹念（dog</p><p>为什么这蓝底白字的命令行就这么丑呢？（根本配不上我帅气的颜值【yeah！】</p><p><a href="https://up.media.everdo.cn/image/h7rx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/ugly-powershell.jpg" alt="ugly-powershell.jpg"></a></p><p>那么，让他变帅的时刻就到了！！！</p><h2 id="改变颜色！"><a href="#改变颜色！" class="headerlink" title="改变颜色！"></a>改变颜色！</h2><p>肤色当然是最影响观感的啦！长得白谁不喜欢（dog</p><p>改变 PowerShell 的颜色不仅可以通过系统自带的属性进行设置。还可以使用颜色工具包，设置主题色。</p><blockquote><p>微软官方提供了一个更换 PowerShell 配色的小工具：ColorTool.exe，我们可以利用它来更换 PowerShell 的主题颜色。ColorTool 支持 iTerm 主题（以 .itermcolors 结尾的主题文件）。</p></blockquote><p>下载地址：<a href="https://github.com/microsoft/terminal/tree/main/src/tools/ColorTool" target="_blank" rel="noopener">ColorTool</a></p><p>将下载的文件解压，移动到 C:\Windows</p><p><a href="https://up.media.everdo.cn/image/hByI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/move-colortools.jpg" alt="move-colortools.jpg"></a></p><p>到这里，我们可以使用 ColorTools 命令为 PowerShell 导入主题配色</p><pre><code class="powershell">#显示现有的主题包ColorTool -s#应用当前主题ColorTool OneHalfDark.itermcolors#设置默认配色方案ColorTool -d OneHalfDark.itermcolors</code></pre><p><a href="https://up.media.everdo.cn/image/hRlX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/colortools.jpg" alt="colortools.jpg"></a></p><p>这里我选则使用 OneHalfDark 暗黑色配色文件，emm果然好看多了呢！</p><blockquote><p>ColorTool 直接支持 iTerm 主题配置文件，因此我们可以在 <a href="https://iterm2colorschemes.com/" target="_blank" rel="noopener">iterm2colorschemes</a> 这个网站找到我们想要的主题背景进行配置，方法和上面介绍的一样：在 PowerShell 中定位至你希望更换的主题文件，使用命令 colortool &lt;主题名称&gt;.itermcolors 进行配置即可。同时，如果你对上面的主题都不满意，你也可以直接在这个网站：<a href="https://terminal.sexy/" target="_blank" rel="noopener">terminal.sexy</a> 自行配置自己想要的主题，并通过同样的方式进行应用。</p></blockquote><h2 id="更换字体"><a href="#更换字体" class="headerlink" title="更换字体"></a>更换字体</h2><p>肤色变好看只是变帅的第一步，那么现在到了发型的环节啦！！这一步，我们要为 PowerShell 安装自定义的字体：</p><p>PowerShell 默认的字体的新宋体，不用说，真的一点也不好看。更换字体的过程，理论上可以更换任何我们想要的字体。不过为了下一步能和我们的主题模块更好的兼容，这里推荐安装 powerline 字体</p><p>Powerline 字体在 GitHub 开源，我们可以在这里： <a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">powerline/fonts</a> 下载支持相关字符的字体。</p><blockquote><p>这里我使用的是 <a href="https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete.ttf" target="_blank" rel="noopener">Meslo LG M Regular Nerd Font</a></p></blockquote><p>同样的 <a href="https://github.com/be5invis/Sarasa-Gothic" target="_blank" rel="noopener">更纱黑体</a> 也是一款很棒的 powerline 字体，不过因为某些原因，在我的电脑显示不正常</p><h3 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h3><p>下载了字体的 ttf 以后，只要右键安装就可以了！</p><p><a href="https://up.media.everdo.cn/image/hoVi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/install-font.jpg" alt="install-font.jpg"></a></p><p>安装完不要忘记在设置中启用哦！</p><p><a href="https://up.media.everdo.cn/image/h2s4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/hxf-powershellfont.png" alt="hxf-powershellfont.png"></a></p><p>如果和我一样遇到在设置选项中找不到字体的，可以看这里（修改注册表！）</p><pre><code>修改下列注册表值：计算机\HKEY_CURRENT_USER\Console\%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe</code></pre><p>将 CodePage 的十六进制数值改为 1b5 或者 fde9（UTF8） 即可</p><p><a href="https://up.media.everdo.cn/image/hdrG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/eidt-regedittable.png" alt="eidt-regedittable.png"></a></p><p>现在就可以在字体设置列表看到本来不被兼容的字体啦，换上后，果然好看多了呢！</p><p><a href="https://up.media.everdo.cn/image/hFGM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/hxf-powershellfont82243b1a91387686.png" alt="hxf-powershellfont82243b1a91387686.png"></a></p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>人靠衣装佛靠金装，好看的小哥哥当然还得配好看的衣服，也就是这一步要安装的皮肤啦（滑稽</p><p>我们通过在 PowerShell 中执行下面的命令安装配置 oh-my-posh。</p><p>安装 posh-git 和 oh-my-posh 这两个模块，其中 posh-git 是 oh-my-posh 的依赖：</p><pre><code class="powershell">Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser</code></pre><p><a href="https://up.media.everdo.cn/image/hAoY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/install-onmyosh.png" alt="install-onmyosh.png"></a></p><p>安装过程如果遇到上述提示，不需要多考虑，直接选 Y 即可。如果遇到下述提示，不需要多考虑，直接选 A 即可。</p><p><a href="https://up.media.everdo.cn/image/hDNa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/install-onmyosh2.png" alt="install-onmyosh2.png"></a></p><p>现在，我们通过命令试一下能否正常切换到 ohmyposh 主题：</p><h2 id="oh-my-posh-2-0-版本"><a href="#oh-my-posh-2-0-版本" class="headerlink" title="oh-my-posh 2.0 版本"></a>oh-my-posh 2.0 版本</h2><pre><code class="powershell">chcp 65001Import-Module posh-gitImport-Module oh-my-poshSet-Theme Paradox</code></pre><h2 id="oh-my-posh-3-0版本"><a href="#oh-my-posh-3-0版本" class="headerlink" title="oh-my-posh 3.0版本"></a>oh-my-posh 3.0版本</h2><pre><code class="powershell">chcp 65001Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradox# Chocolatey profile$ChocolateyProfile = &quot;$env:ChocolateyInstall\helpers\chocolateyProfile.psm1&quot;if (Test-Path($ChocolateyProfile)) {  Import-Module &quot;$ChocolateyProfile&quot;}</code></pre><p><a href="https://up.media.everdo.cn/image/hVts" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/hxf-powershellsettheme.png" alt="hxf-powershellsettheme.png"></a></p><p>可以看到，主题已经生效啦！！</p><p>但是这样设置的主题只能在当前 powershell 会话中生效，为了使之全局生效，我们需要修改用户自定义配置文件</p><pre><code class="powershell">#用记事本打开配置文件notepad $PROFILE</code></pre><p>这里要做的，就是把上面的那些代码统统复制过来就好啦！</p><p><a href="https://up.media.everdo.cn/image/hbh3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/install-onmyoshuserprofile.png" alt="install-onmyoshuserprofile.png"></a></p><h2 id="使用-PowerShell-7"><a href="#使用-PowerShell-7" class="headerlink" title="使用 PowerShell 7"></a>使用 PowerShell 7</h2><p>微软官方在 GitHub 提供了 Powershell7 的下载。只要下载 msi 安装包，就可以很轻松的安装程序啦！</p><p><a href="https://github.com/PowerShell/PowerShell/releases" target="_blank" rel="noopener">https://github.com/PowerShell/PowerShell/releases</a></p><p><a href="https://up.media.everdo.cn/image/hiuj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/download-powerhell.png" alt="download-powerhell.png"></a></p><p>安装不用多说，一路 Next。全新安装的 PowerShell7 会继承原先旧 PowerShell 的配色方案，但不会继承主题。</p><p>恢复的方法只要重新走一遍上面的过程就好啦！</p><p>最后看一下效果：</p><p><a href="https://up.media.everdo.cn/image/hQVO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/powershell7.png" alt="powershell7.png"></a></p><h2 id="使用-WindowsTerminal"><a href="#使用-WindowsTerminal" class="headerlink" title="使用 WindowsTerminal"></a>使用 WindowsTerminal</h2><p>帅气的男孩子当然还得有点小肌肉才能撩到小姐姐哇（xiaogege），WindowsTermiinal 就像是一个多功能的瑞士军刀，能把多种命令行工具集合在一起，让本来单调的 powershell 在其加持下更加强大。</p><p>Terminal 的安装非常简单，只要在应用商店下载安装即可：</p><p><a href="https://up.media.everdo.cn/image/hey9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/installwindowsterminal.png" alt="installwindowsterminal.png"></a></p><p>刚刚安装完的 Terminal 打开后，会使用最原始的配色和字体，就像下面一样，会导致我们的自定义主题不正常显示。这里我们修改 Terminal 的配置文件。</p><p><a href="https://up.media.everdo.cn/image/hqs6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/terminalerr.png" alt="terminalerr.png"></a></p><p>（点击菜单栏的设置图标，系统会自动使用 VScode 打开一个配置的 json</p><p><a href="https://up.media.everdo.cn/image/hxKn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/terminalsettings.png" alt="terminalsettings.png"></a></p><p>这里可以先不管那么多，用我这里给大家的代码直接怼进去：</p><pre><code class="json">&quot;profiles&quot;:    {        &quot;defaults&quot;:        {            // Put settings here that you want to apply to all profiles.        },        &quot;list&quot;:        [            {                &quot;guid&quot;: &quot;{574e775e-4f2a-5b96-ac1e-a2962a402336}&quot;,                &quot;hidden&quot;: false,                &quot;name&quot;: &quot;Work PowerShell&quot;,                &quot;colorScheme&quot; : &quot;One Half Dark&quot;,                &quot;fontFace&quot; : &quot;等距更纱黑体 SC&quot;,                &quot;fontSize&quot; : 11,                &quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;            },            {                // Make changes here to the powershell.exe profile.                &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,                &quot;name&quot;: &quot;Windows PowerShell&quot;,                &quot;colorScheme&quot; : &quot;One Half Dark&quot;,                &quot;fontFace&quot; : &quot;等距更纱黑体 SC&quot;,                &quot;fontSize&quot; : 11,                &quot;commandline&quot;: &quot;powershell.exe&quot;,                &quot;hidden&quot;: false            },            {                // Make changes here to the cmd.exe profile.                &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;,                &quot;name&quot;: &quot;命令提示符&quot;,                &quot;colorScheme&quot; : &quot;One Half Dark&quot;,                &quot;fontFace&quot; : &quot;等距更纱黑体 SC&quot;,                &quot;fontSize&quot; : 11,                &quot;commandline&quot;: &quot;cmd.exe&quot;,                &quot;hidden&quot;: false            },            {                &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;,                &quot;hidden&quot;: false,                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;            }        ]    },……</code></pre><p>至此，我们在 Terminal 内可以同时使用经过美化的 Powershell5 和 Powershell7，还可以在快速调出 CMD 命令提示符。</p><p><a href="https://up.media.everdo.cn/image/h6oS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/terminalpowershell.png" alt="terminalpowershell.png"></a></p><h3 id="在-Terminal-下使用-Git"><a href="#在-Terminal-下使用-Git" class="headerlink" title="在 Terminal 下使用 Git"></a>在 Terminal 下使用 Git</h3><p>到目前为止，Terminal 包含了两个版本的 PowerShell 以及老式的 CMD，已经比较强大了。但是我们仍然可以为他集成 Git 功能。</p><p>集成 Git 的首要条件就是电脑中预先安装了 Git。这里因为我电脑中已经有 Git，故不再演示。</p><p>启用 Git 只需要把下述代码添加到 Terminal 设置的配置文件中。</p><pre><code class="json">{    // GIT    //&quot;acrylicOpacity&quot; : 0.75,    &quot;closeOnExit&quot; : true,    &quot;colorScheme&quot; : &quot;One Half Dark&quot;,    &quot;commandline&quot; : &quot;D:\\Git\\bin\\bash.exe&quot;, // 改为 bash.exe，在环境变量里面配置了它之前的路径，用绝对路径也应该是可以的    //&quot;cursorColor&quot; : &quot;#FFFFFF&quot;,    &quot;cursorShape&quot; : &quot;bar&quot;,    &quot;fontFace&quot; : &quot;等距更纱黑体 SC&quot;,    //&quot;fontFace&quot; : &quot;Consolas&quot;,    &quot;fontSize&quot; : 11,    &quot;guid&quot; : &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6109}&quot;, // 改一下 guid，此处我将最后一位改为9    &quot;historySize&quot; : 9001,    &quot;icon&quot; : &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git\\gwindows_logo.png&quot;, // git-bash的logo地址    &quot;name&quot; : &quot;Git&quot;, // 改个名字    &quot;padding&quot; : &quot;5, 0, 0, 0&quot;,    &quot;snapOnInput&quot; : true,    &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;    //&quot;useAcrylic&quot; : true},</code></pre><p>然后，因为 Terminal 默认不集成图标，我们需要导入外部的 Git 图标到我们刚才配置文件中的图标路径：</p><pre><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Git\gwindows_logo.png</code></pre><p><a href="https://up.media.everdo.cn/image/hNkQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/import-git-icon.png" alt="import-git-icon.png"></a></p><p>git 的图标可以点击下面的图另存为：</p><p><a href="https://up.media.everdo.cn/image/hkwJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/gwindows_logo.png" alt="gwindows_logo.png"></a></p><p>现在我们来看下 Terminal 中能不能正常显示 Git 图标吧：</p><p><a href="https://up.media.everdo.cn/image/h9hy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/terminal-git.png" alt="terminal-git.png"></a></p><p>完美！</p><h3 id="Terminal-默认启动项"><a href="#Terminal-默认启动项" class="headerlink" title="Terminal 默认启动项"></a>Terminal 默认启动项</h3><p>细心的朋友可能会发现，照我们刚才那样设置，Terminal 新启动的时候，会默认打开旧版的 PowerShell5，那么怎样设置我们想要的呢？比如 Git，CMD等等</p><p>想要完成这一步，其实只需要修改 Terminal 配置文件中的 defaultProfile</p><pre><code>&quot;defaultProfile&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,</code></pre><p>将这一栏的 uuid 改为我们需要启动的终端的 uuid 即可。</p><p><a href="https://up.media.everdo.cn/image/hEQd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/terminal-defaultprofile.png" alt="terminal-defaultprofile.png"></a></p><blockquote><p>好啦，到此为止，一个美美而强大的终端就打造完毕啦，看着这帅气的UI，撸代码的心情也会好很多哇！</p></blockquote><p><img src="https://media.everdo.cn/tank/pic-bed/2020/05/23/hxf-powershell.png" alt="hxf-powershell"></p><blockquote><p>参考文章：<a href="https://sspai.com/post/52907" target="_blank" rel="noopener">https://sspai.com/post/52907</a></p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个简单的JAVA GUI练习</title>
      <link href="/2020/05/%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JAVA-GUI%E7%BB%83%E4%B9%A0/"/>
      <url>/2020/05/%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JAVA-GUI%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>最近在听 NEU 的 JAVA 慕课，然后有两个简单的 GUI 课后练习：</p><h2 id="菜单栏相关练习"><a href="#菜单栏相关练习" class="headerlink" title="菜单栏相关练习"></a>菜单栏相关练习</h2><blockquote><p>编写如图所示应用程序，单击选择菜单项退出后，显示下面的请选择对话框，选择是结束程序，选择否显示下面的消息对话框。</p></blockquote><p><a href="https://up.media.everdo.cn/image/Iufc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/19/a.jpg" alt="a.jpg"></a></p><p>题目要求使用菜单栏 JMenuBar 和 菜单项 JMenuItem， 很遗憾 IEDA 所提供的 SwingGUIdesigner 并没有默认提高 菜单栏 和 菜单项的选则。因此这里被迫使用了 JFormDesigner 来创建可视化界面：</p><p><a href="https://up.media.everdo.cn/image/h4G2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/19/jfd-homework1.png" alt="jfd-homework1.png"></a></p><p>这里，题目要求的两个 optionPane 也是可以先在 jFromDesinger 中先画好的。这样就可以不用手动初始化了。</p><p>至此，系统自动生成的代码如下：</p><pre><code class="java">private void initComponents() {    // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents    menuBar1 = new JMenuBar();    menuFile = new JMenu();    menuItemOpen = new JMenuItem();    menuItemExit = new JMenuItem();    menuEidt = new JMenu();    menuForm = new JMenu();    optionPaneChoose = new JOptionPane();    optionPaneNo = new JOptionPane();    //======== this ========    setTitle(&quot;EmptinessBoy\u4f5c\u4e1a&quot;);    Container contentPane = getContentPane();    contentPane.setLayout(new GridLayout(3, 4));    //======== menuBar1 ========    {        //======== menuFile ========        {            menuFile.setText(&quot;\u6587\u4ef6&quot;);            //---- menuItemOpen ----            menuItemOpen.setText(&quot;\u6253\u5f00&quot;);            menuFile.add(menuItemOpen);            //---- menuItemExit ----            menuItemExit.setText(&quot;\u9000\u51fa&quot;);            menuItemExit.addActionListener(e -&gt; menuItemExitActionPerformed(e));            menuFile.add(menuItemExit);        }        menuBar1.add(menuFile);        //======== menuEidt ========        {            menuEidt.setText(&quot;\u7f16\u8f91&quot;);        }        menuBar1.add(menuEidt);        //======== menuForm ========        {            menuForm.setText(&quot;\u7a97\u53e3&quot;);        }        menuBar1.add(menuForm);    }    setJMenuBar(menuBar1);    setSize(445, 315);    setLocationRelativeTo(getOwner());    // JFormDesigner - End of component initialization  //GEN-END:initComponents}// JFormDesigner - Variables declaration - DO NOT MODIFY  //GEN-BEGIN:variablesprivate JMenuBar menuBar1;private JMenu menuFile;private JMenuItem menuItemOpen;private JMenuItem menuItemExit;private JMenu menuEidt;private JMenu menuForm;private JOptionPane optionPaneChoose;private JOptionPane optionPaneNo;// JFormDesigner - End of variables declaration  //GEN-END:variables</code></pre><p>为了使程序完成题目要求的功能，我们需要给菜单项 JMenuItem【menuItemExit】设置监听器。</p><p>事件监听代码：</p><h3 id="optionPane-对话框写法"><a href="#optionPane-对话框写法" class="headerlink" title="optionPane 对话框写法"></a>optionPane 对话框写法</h3><pre><code class="java">private void menuItemExitActionPerformed(ActionEvent e) {    // TODO add your code here    int i = optionPaneChoose.showConfirmDialog(null,&quot;是否退出系统？&quot;,&quot;请选择&quot;, JOptionPane.YES_NO_OPTION);    if(i==0)        System.exit(0);    else{        //ConfirmDialog(null,&quot;您选择了否！&quot;,&quot;消息&quot;,JOptionPane.YES_OPTION);        optionPaneNo.showMessageDialog(null,&quot;您选择了否&quot;,&quot;消息&quot;, JOptionPane.YES_OPTION);    }}</code></pre><p>对于多选对话框，int i 的返回值就是指代了用户选中的 “是” 或 “否” 的值。一般情况下，选中是为 0.</p><blockquote><p>optionPaneNo.showMessageDialog 显示一个消息提示<br>optionPaneChoose.showConfirmDialog 显示可确认对话框</p></blockquote><h3 id="设置点击关闭窗体的默认事件"><a href="#设置点击关闭窗体的默认事件" class="headerlink" title="设置点击关闭窗体的默认事件"></a>设置点击关闭窗体的默认事件</h3><p>只要在实现 JFrame 类的构造函数中加入一条</p><pre><code class="java">setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code></pre><p>即可轻松搞定。</p><p>最后，整体运行效果：</p><p><a href="https://up.media.everdo.cn/image/hJjZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/19/jfd-homework2.png" alt="jfd-homework2.png"></a></p><h2 id="窗体相关练习"><a href="#窗体相关练习" class="headerlink" title="窗体相关练习"></a>窗体相关练习</h2><blockquote><p>窗体中显示一个图片，用鼠标可以拖动图片到任意位置。</p></blockquote><p>没错，作业只有这么简简单单一句话。然后我也天真的以为这是一道秒杀题。但是，往往是我太天真了（悲哀</p><p>头里的步骤并不难，这里使用 JFormDesigner 创建窗体。然后随便拖拽一个 JLable 用来存放图片。</p><p><a href="https://up.media.everdo.cn/image/hPNk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/20/jfd-homework3.png" alt="jfd-homework3.png"></a></p><p>下面是系统自动生成的代码（含后面加的监听器）：</p><pre><code class="java">……    private void initComponents() {        // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents        label1 = new JLabel();        textField1 = new JTextField();        //======== this ========        setMinimumSize(new Dimension(500, 500));        setTitle(&quot;EmptinessBoyMooc\u4f5c\u4e1a&quot;);        var contentPane = getContentPane();        //---- label1 ----        label1.setIcon(null);        label1.addMouseMotionListener(new MouseMotionAdapter() {            @Override            public void mouseDragged(MouseEvent e) {                label1MouseDragged(e);            }        });        label1.addMouseListener(new MouseAdapter() {            @Override            public void mousePressed(MouseEvent e) {                label1MousePressed(e);            }        });        //---- textField1 ----        textField1.setText(&quot;\u6b64\u5904\u663e\u793a\u5750\u6807&quot;);        GroupLayout contentPaneLayout = new GroupLayout(contentPane);        contentPane.setLayout(contentPaneLayout);        contentPaneLayout.setHorizontalGroup(            contentPaneLayout.createParallelGroup()                .addGroup(contentPaneLayout.createSequentialGroup()                    .addGroup(contentPaneLayout.createParallelGroup(GroupLayout.Alignment.LEADING, false)                        .addComponent(label1, GroupLayout.PREFERRED_SIZE, 100, GroupLayout.PREFERRED_SIZE)                        .addGroup(contentPaneLayout.createSequentialGroup()                            .addContainerGap()                            .addComponent(textField1)))                    .addContainerGap())        );        contentPaneLayout.setVerticalGroup(            contentPaneLayout.createParallelGroup()                .addGroup(contentPaneLayout.createSequentialGroup()                    .addComponent(label1, GroupLayout.PREFERRED_SIZE, 100, GroupLayout.PREFERRED_SIZE)                    .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, 302, Short.MAX_VALUE)                    .addComponent(textField1, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)                    .addContainerGap())        );        pack();        setLocationRelativeTo(getOwner());        // JFormDesigner - End of component initialization  //GEN-END:initComponents    }    // JFormDesigner - Variables declaration - DO NOT MODIFY  //GEN-BEGIN:variables    private JLabel label1;    private JTextField textField1;    // JFormDesigner - End of variables declaration  //GEN-END:variables}</code></pre><p>到这里，我们需要给 jlable 设置 icon，这里将设置 icon 的代码放到构造函数中：</p><h3 id="Jlabel-设置-icon-方法"><a href="#Jlabel-设置-icon-方法" class="headerlink" title="Jlabel 设置 icon 方法"></a>Jlabel 设置 icon 方法</h3><pre><code class="java">public MovePic() {    initComponents();    setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    ImageIcon i = new ImageIcon(&quot;src/logo.png&quot;);    Image pic = i.getImage().getScaledInstance(100,100,Image.SCALE_DEFAULT);    ImageIcon ico = new ImageIcon(pic);    label1.setIcon(ico);}</code></pre><p>现在是不是只要给 存放了图片的 jlable 设置 MouseDragged 鼠标拖拽监听函数呢？</p><p>最开始一脸小白的我确实是这么想的，然后写下了简单的</p><pre><code class="java">错误代码：x = e.getX();y = e.getY();textField1.setText(x+&quot;,&quot;+y);label1.setLocation(x,y);</code></pre><p>网上都说了 e.getX(); e.getY(); 不就是获取当前是鼠标位置嘛。（呵呵</p><p>然而在实际测试中发现，实际上，这两个获取到的都是以 jlable 为容器，鼠标在 jlable 中的相对位置。因此单纯这样的代码无法实现所需要的功能。</p><p>那么，一心想偷懒的我想，那么只要针对 Jlable 的父容器设置鼠标监听器来改变坐标不就完了？（理想很美好，现实确是：</p><p>因为子容器遮挡了父容器，当鼠标移动到 Jlable 上时，设置在父容器 JFrame 的监听器就失效了！！</p><p>只有鼠标移出图片的时候，才能正确获取针对窗体的坐标。</p><h3 id="终极坐标解决方案"><a href="#终极坐标解决方案" class="headerlink" title="终极坐标解决方案"></a>终极坐标解决方案</h3><p>那么只能使出大杀器了，（用我小学的算数水平，通过绝对坐标加减来获取位置了</p><p>经过查找文档，可知：</p><blockquote><p>e.getXOnScreen() e.getYOnScreen() 可以用来获取鼠标在整个屏幕的绝对位置，而 this.getX() this.getY()可以获得当前窗体在屏幕中的左上角位置。</p></blockquote><p>那么？！</p><p>只要使用 <code>x = e.getXOnScreen()-this.getX()</code> 就可以通过计算获得鼠标在窗体内部的相对位置啦！！！</p><p>但是这时候还是有些小小的瑕疵 ——鼠标拖拽后，显示的位置是以鼠标结束位置作为左上角定点的，拖拽感觉不够自然。</p><p>修复的方法很简单。既然 e.getX() 可以获取当前鼠标相对于图片（jlable）的相对位置，那么只要在我们刚才获取的 x 减去 这个内部的相对位置就完美啦！！注意这个坐标需要在刚开始按下鼠标时获取才有用，因此需要放在 MousePressed 监听器中。</p><p>最后附上代码：</p><pre><code class="java">public class MovePic extends JFrame {    int x,y,a,b;    public static void main(String[] args) {        new MovePic().setVisible(true);    }    public MovePic() {        initComponents();        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        ImageIcon i = new ImageIcon(&quot;src/logo.png&quot;);        Image pic = i.getImage().getScaledInstance(100,100,Image.SCALE_DEFAULT);        ImageIcon ico = new ImageIcon(pic);        label1.setIcon(ico);    }    private void label1MouseDragged(MouseEvent e) {        // TODO add your code here        x = e.getXOnScreen()-this.getX()-a;        y = e.getYOnScreen()-this.getY()-b-20;        textField1.setText(x+&quot;,&quot;+y);        label1.setLocation(x,y);    }    private void label1MousePressed(MouseEvent e) {        // TODO add your code here        a = e.getX();        b = e.getY();    }……</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/hItB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/20/e18f47190defc5112b413d963c2e3a72.gif" alt="e18f47190defc5112b413d963c2e3a72.gif"></a></p><p>nice！又是洗洗睡的一天（PS，最近腰疼犯了，睡觉保命要紧【滑稽】</p><h2 id="控件和监听器练习"><a href="#控件和监听器练习" class="headerlink" title="控件和监听器练习"></a>控件和监听器练习</h2><blockquote><p>题目要求：使用 Java 实现一个RGB调色板程序，点击加减按钮可以调整RGB数值并显示颜色</p></blockquote><p>由于已经比较习惯了 JFormDesigner 那么完成这个任务也靠Ta啦！</p><h3 id="设计界面"><a href="#设计界面" class="headerlink" title="设计界面"></a>设计界面</h3><p><a href="https://up.media.everdo.cn/image/hpTx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/jfd-colorpanel.png" alt="jfd-colorpanel.png"></a></p><p>这里外层的 Jframe 使用了 IntelijGridLayOut ，比起标准的 GridLayout 可以自由调整 margin，以及内部的浮动（有点像安卓里的 Gravaty</p><p>内部划分了两个 panel 用于摆放控件，下方的 panel 则用来显示实时的颜色输出</p><p>划分完成 UI ，并设置完成事件监听器后，系统就自动生成了 UI 相关的代码</p><pre><code class="java">……    private void initComponents() {        // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents        panelSetColor = new JPanel();        labelRed = new JLabel();        buttonSubRed = new JButton();        textFieldRed = new JTextField();        buttonAddRed = new JButton();        labelGreen = new JLabel();        buttonSubGreen = new JButton();        textFieldGreen = new JTextField();        buttonAddGreen = new JButton();        labelBlue = new JLabel();        buttonSubBlue = new JButton();        textFieldBlue = new JTextField();        buttonAddBlue = new JButton();        panelColor = new JPanel();        labelShowColor = new JLabel();        //======== this ========        setTitle(&quot;2018010587-\u80e1\u6653\u5e06\uff08\u8c03\u8272\u677f\uff09&quot;);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setMinimumSize(new Dimension(550, 350));        setFont(new Font(Font.DIALOG, Font.PLAIN, 16));        setBackground(Color.white);        Container contentPane = getContentPane();        contentPane.setLayout(new GridLayoutManager(4, 1, new Insets(0, 20, 20, 20), 0, 5));        //======== panelSetColor ========        {            panelSetColor.setFont(panelSetColor.getFont().deriveFont(panelSetColor.getFont().getSize() + 4f));            panelSetColor.setLayout(new GridLayoutManager(3, 4, new Insets(20, 0, 10, 0), 3, 3));            //---- labelRed ----            labelRed.setText(&quot;\u7ea2\u8272 R&quot;);            labelRed.setForeground(Color.red);            labelRed.setFont(labelRed.getFont().deriveFont(labelRed.getFont().getStyle() | Font.BOLD, labelRed.getFont().getSize() + 4f));            panelSetColor.add(labelRed, new GridConstraints(0, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubRed ----            buttonSubRed.setText(&quot;\u51cf\u5c11&quot;);            buttonSubRed.setFont(buttonSubRed.getFont().deriveFont(buttonSubRed.getFont().getSize() + 4f));            buttonSubRed.addActionListener(e -&gt; buttonSubRedActionPerformed(e));            panelSetColor.add(buttonSubRed, new GridConstraints(0, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldRed ----            textFieldRed.setText(&quot;155&quot;);            textFieldRed.setFont(textFieldRed.getFont().deriveFont(textFieldRed.getFont().getSize() + 4f));            panelSetColor.add(textFieldRed, new GridConstraints(0, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddRed ----            buttonAddRed.setText(&quot;\u589e\u52a0&quot;);            buttonAddRed.setFont(buttonAddRed.getFont().deriveFont(buttonAddRed.getFont().getSize() + 4f));            buttonAddRed.addActionListener(e -&gt; buttonAddRedActionPerformed(e));            panelSetColor.add(buttonAddRed, new GridConstraints(0, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- labelGreen ----            labelGreen.setText(&quot;\u7eff\u8272 G&quot;);            labelGreen.setForeground(new Color(0, 204, 51));            labelGreen.setFont(labelGreen.getFont().deriveFont(labelGreen.getFont().getStyle() | Font.BOLD, labelGreen.getFont().getSize() + 4f));            panelSetColor.add(labelGreen, new GridConstraints(1, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubGreen ----            buttonSubGreen.setText(&quot;\u51cf\u5c11&quot;);            buttonSubGreen.setFont(buttonSubGreen.getFont().deriveFont(buttonSubGreen.getFont().getSize() + 4f));            buttonSubGreen.addActionListener(e -&gt; buttonSubGreenActionPerformed(e));            panelSetColor.add(buttonSubGreen, new GridConstraints(1, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldGreen ----            textFieldGreen.setText(&quot;155&quot;);            textFieldGreen.setFont(textFieldGreen.getFont().deriveFont(textFieldGreen.getFont().getSize() + 4f));            panelSetColor.add(textFieldGreen, new GridConstraints(1, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddGreen ----            buttonAddGreen.setText(&quot;\u589e\u52a0&quot;);            buttonAddGreen.setFont(buttonAddGreen.getFont().deriveFont(buttonAddGreen.getFont().getSize() + 4f));            buttonAddGreen.addActionListener(e -&gt; buttonAddGreenActionPerformed(e));            panelSetColor.add(buttonAddGreen, new GridConstraints(1, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- labelBlue ----            labelBlue.setText(&quot;\u84dd\u8272 B&quot;);            labelBlue.setForeground(new Color(0, 102, 255));            labelBlue.setFont(labelBlue.getFont().deriveFont(labelBlue.getFont().getStyle() | Font.BOLD, labelBlue.getFont().getSize() + 4f));            panelSetColor.add(labelBlue, new GridConstraints(2, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubBlue ----            buttonSubBlue.setText(&quot;\u51cf\u5c11&quot;);            buttonSubBlue.setFont(buttonSubBlue.getFont().deriveFont(buttonSubBlue.getFont().getSize() + 4f));            buttonSubBlue.addActionListener(e -&gt; buttonSubBlueActionPerformed(e));            panelSetColor.add(buttonSubBlue, new GridConstraints(2, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldBlue ----            textFieldBlue.setText(&quot;155&quot;);            textFieldBlue.setFont(textFieldBlue.getFont().deriveFont(textFieldBlue.getFont().getSize() + 4f));            panelSetColor.add(textFieldBlue, new GridConstraints(2, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddBlue ----            buttonAddBlue.setText(&quot;\u589e\u52a0&quot;);            buttonAddBlue.setFont(buttonAddBlue.getFont().deriveFont(buttonAddBlue.getFont().getSize() + 4f));            buttonAddBlue.addActionListener(e -&gt; buttonAddBlueActionPerformed(e));            panelSetColor.add(buttonAddBlue, new GridConstraints(2, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));        }        contentPane.add(panelSetColor, new GridConstraints(0, 0, 1, 1,            GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        //======== panelColor ========        {            panelColor.setLayout(new GridLayoutManager(1, 1, new Insets(0, 10, 0, 10), 0, 0));            //---- labelShowColor ----            labelShowColor.setText(&quot;\u6b64\u5904\u663e\u793a\u6700\u7ec8\u989c\u8272&quot;);            panelColor.add(labelShowColor, new GridConstraints(0, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));        }        contentPane.add(panelColor, new GridConstraints(2, 0, 1, 1,            GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        pack();        setLocationRelativeTo(getOwner());        // JFormDesigner - End of component initialization  //GEN-END:initComponents    }    // JFormDesigner - Variables declaration - DO NOT MODIFY  //GEN-BEGIN:variables    private JPanel panelSetColor;    private JLabel labelRed;    private JButton buttonSubRed;    private JTextField textFieldRed;    private JButton buttonAddRed;    private JLabel labelGreen;    private JButton buttonSubGreen;    private JTextField textFieldGreen;    private JButton buttonAddGreen;    private JLabel labelBlue;    private JButton buttonSubBlue;    private JTextField textFieldBlue;    private JButton buttonAddBlue;    private JPanel panelColor;    private JLabel labelShowColor;    // JFormDesigner - End of variables declaration  //GEN-END:variables}</code></pre><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>第一步要解决的就是程序刚运行时显示的颜色。这里我给类创建了r,g,b三个整型的变量。</p><p>然后只要在构造函数中把 panel 的颜色设置成预设的 rgb 即可。这里使用了 <code>.setBackground</code> 方法来设置背景色值。</p><pre><code class="java">public class ColorPanel extends JFrame {    int r=155,g=155,b=155;    Color bgColor = new Color(r, g, b);//设置初始颜色……public ColorPanel() {    initComponents();    textFieldRed.setText(String.valueOf(r));    textFieldGreen.setText(String.valueOf(g));    textFieldBlue.setText(String.valueOf(b));    panelColor.setBackground(bgColor);}</code></pre><p>接下来就是要通过按钮的按动来改变颜色了，这里以红色减少按钮为例：</p><pre><code class="java">private void buttonSubRedActionPerformed(ActionEvent e) {    // TODO add your code here    GetNum();    if(r&gt;0&amp;&amp;r&lt;=255)        r--;    else        System.out.println(&quot;红色已到临界值&quot;);    ShowColor();}</code></pre><p>这段代码中，使用了我写的两个函数 GetNum() 和 ShowColor()。GetNum 的目的是获取两个按钮中的文本框的值，来允许程序运行的时候可以手动输入数值。而 showColor 则是因为每个按钮最后都有显示颜色的功能，这段代码可以用函数来做。</p><p>GetNum()：</p><pre><code class="java">void GetNum(){    //允许用户输入数值修改rgb    r = Integer.parseInt(textFieldRed.getText());    g = Integer.parseInt(textFieldGreen.getText());    b = Integer.parseInt(textFieldBlue.getText());}</code></pre><p>ShowColor()：</p><pre><code class="java">void ShowColor(){    textFieldRed.setText(String.valueOf(r));    textFieldGreen.setText(String.valueOf(g));    textFieldBlue.setText(String.valueOf(b));    bgColor = new Color(r,g,b);    panelColor.setBackground(bgColor);    panelColor.setBackground(bgColor);    labelShowColor.setText(&quot;当前颜色16进制为：#&quot;+Integer.toHexString(r)+Integer.toHexString(g)+Integer.toHexString(b));}</code></pre><p>最后附上运行效果：</p><p><a href="https://up.media.everdo.cn/image/hw4I" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/24/hxftiaoseban.gif" alt="hxftiaoseban.gif"></a></p><p>完整代码：</p><pre><code class="java">import java.awt.*;import java.awt.event.*;import javax.swing.*;import com.intellij.uiDesigner.core.*;/** * @author huxiaofan */public class ColorPanel extends JFrame {    int r=155,g=155,b=155;    Color bgColor = new Color(r, g, b);//设置初始颜色    public static void main(String[] args) {        new ColorPanel().setVisible(true);    }    public ColorPanel() {        initComponents();        textFieldRed.setText(String.valueOf(r));        textFieldGreen.setText(String.valueOf(g));        textFieldBlue.setText(String.valueOf(b));        panelColor.setBackground(bgColor);    }    void ShowColor(){        textFieldRed.setText(String.valueOf(r));        textFieldGreen.setText(String.valueOf(g));        textFieldBlue.setText(String.valueOf(b));        bgColor = new Color(r,g,b);        panelColor.setBackground(bgColor);        panelColor.setBackground(bgColor);        labelShowColor.setText(&quot;当前颜色16进制为：#&quot;+Integer.toHexString(r)+Integer.toHexString(g)+Integer.toHexString(b));    }    void GetNum(){        //允许用户输入数值修改rgb        r = Integer.parseInt(textFieldRed.getText());        g = Integer.parseInt(textFieldGreen.getText());        b = Integer.parseInt(textFieldBlue.getText());    }    private void buttonSubRedActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(r&gt;0&amp;&amp;r&lt;=255)            r--;        else            System.out.println(&quot;红色已到临界值&quot;);        ShowColor();    }    private void buttonAddRedActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(r&gt;=0&amp;&amp;r&lt;255)            r++;        else            System.out.println(&quot;红色已到临界值&quot;);        ShowColor();    }    private void buttonSubGreenActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(g&gt;0&amp;&amp;g&lt;=255)            g--;        else            System.out.println(&quot;绿色已到临界值&quot;);        ShowColor();    }    private void buttonAddGreenActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(g&gt;=0&amp;&amp;g&lt;255)            g++;        else            System.out.println(&quot;绿色已到临界值&quot;);        ShowColor();    }    private void buttonSubBlueActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(b&gt;0&amp;&amp;b&lt;=255)            b--;        else            System.out.println(&quot;蓝色已到临界值&quot;);        ShowColor();    }    private void buttonAddBlueActionPerformed(ActionEvent e) {        // TODO add your code here        GetNum();        if(b&gt;=0&amp;&amp;b&lt;255)            b++;        else            System.out.println(&quot;蓝色已到临界值&quot;);        ShowColor();    }    private void initComponents() {        // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents        panelSetColor = new JPanel();        labelRed = new JLabel();        buttonSubRed = new JButton();        textFieldRed = new JTextField();        buttonAddRed = new JButton();        labelGreen = new JLabel();        buttonSubGreen = new JButton();        textFieldGreen = new JTextField();        buttonAddGreen = new JButton();        labelBlue = new JLabel();        buttonSubBlue = new JButton();        textFieldBlue = new JTextField();        buttonAddBlue = new JButton();        panelColor = new JPanel();        labelShowColor = new JLabel();        //======== this ========        setTitle(&quot;2018010587-\u80e1\u6653\u5e06\uff08\u8c03\u8272\u677f\uff09&quot;);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setMinimumSize(new Dimension(550, 350));        setFont(new Font(Font.DIALOG, Font.PLAIN, 16));        setBackground(Color.white);        Container contentPane = getContentPane();        contentPane.setLayout(new GridLayoutManager(4, 1, new Insets(0, 20, 20, 20), 0, 5));        //======== panelSetColor ========        {            panelSetColor.setFont(panelSetColor.getFont().deriveFont(panelSetColor.getFont().getSize() + 4f));            panelSetColor.setLayout(new GridLayoutManager(3, 4, new Insets(20, 0, 10, 0), 3, 3));            //---- labelRed ----            labelRed.setText(&quot;\u7ea2\u8272 R&quot;);            labelRed.setForeground(Color.red);            labelRed.setFont(labelRed.getFont().deriveFont(labelRed.getFont().getStyle() | Font.BOLD, labelRed.getFont().getSize() + 4f));            panelSetColor.add(labelRed, new GridConstraints(0, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubRed ----            buttonSubRed.setText(&quot;\u51cf\u5c11&quot;);            buttonSubRed.setFont(buttonSubRed.getFont().deriveFont(buttonSubRed.getFont().getSize() + 4f));            buttonSubRed.addActionListener(e -&gt; buttonSubRedActionPerformed(e));            panelSetColor.add(buttonSubRed, new GridConstraints(0, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldRed ----            textFieldRed.setText(&quot;155&quot;);            textFieldRed.setFont(textFieldRed.getFont().deriveFont(textFieldRed.getFont().getSize() + 4f));            panelSetColor.add(textFieldRed, new GridConstraints(0, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddRed ----            buttonAddRed.setText(&quot;\u589e\u52a0&quot;);            buttonAddRed.setFont(buttonAddRed.getFont().deriveFont(buttonAddRed.getFont().getSize() + 4f));            buttonAddRed.addActionListener(e -&gt; buttonAddRedActionPerformed(e));            panelSetColor.add(buttonAddRed, new GridConstraints(0, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- labelGreen ----            labelGreen.setText(&quot;\u7eff\u8272 G&quot;);            labelGreen.setForeground(new Color(0, 204, 51));            labelGreen.setFont(labelGreen.getFont().deriveFont(labelGreen.getFont().getStyle() | Font.BOLD, labelGreen.getFont().getSize() + 4f));            panelSetColor.add(labelGreen, new GridConstraints(1, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubGreen ----            buttonSubGreen.setText(&quot;\u51cf\u5c11&quot;);            buttonSubGreen.setFont(buttonSubGreen.getFont().deriveFont(buttonSubGreen.getFont().getSize() + 4f));            buttonSubGreen.addActionListener(e -&gt; buttonSubGreenActionPerformed(e));            panelSetColor.add(buttonSubGreen, new GridConstraints(1, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldGreen ----            textFieldGreen.setText(&quot;155&quot;);            textFieldGreen.setFont(textFieldGreen.getFont().deriveFont(textFieldGreen.getFont().getSize() + 4f));            panelSetColor.add(textFieldGreen, new GridConstraints(1, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddGreen ----            buttonAddGreen.setText(&quot;\u589e\u52a0&quot;);            buttonAddGreen.setFont(buttonAddGreen.getFont().deriveFont(buttonAddGreen.getFont().getSize() + 4f));            buttonAddGreen.addActionListener(e -&gt; buttonAddGreenActionPerformed(e));            panelSetColor.add(buttonAddGreen, new GridConstraints(1, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- labelBlue ----            labelBlue.setText(&quot;\u84dd\u8272 B&quot;);            labelBlue.setForeground(new Color(0, 102, 255));            labelBlue.setFont(labelBlue.getFont().deriveFont(labelBlue.getFont().getStyle() | Font.BOLD, labelBlue.getFont().getSize() + 4f));            panelSetColor.add(labelBlue, new GridConstraints(2, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonSubBlue ----            buttonSubBlue.setText(&quot;\u51cf\u5c11&quot;);            buttonSubBlue.setFont(buttonSubBlue.getFont().deriveFont(buttonSubBlue.getFont().getSize() + 4f));            buttonSubBlue.addActionListener(e -&gt; buttonSubBlueActionPerformed(e));            panelSetColor.add(buttonSubBlue, new GridConstraints(2, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldBlue ----            textFieldBlue.setText(&quot;155&quot;);            textFieldBlue.setFont(textFieldBlue.getFont().deriveFont(textFieldBlue.getFont().getSize() + 4f));            panelSetColor.add(textFieldBlue, new GridConstraints(2, 2, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- buttonAddBlue ----            buttonAddBlue.setText(&quot;\u589e\u52a0&quot;);            buttonAddBlue.setFont(buttonAddBlue.getFont().deriveFont(buttonAddBlue.getFont().getSize() + 4f));            buttonAddBlue.addActionListener(e -&gt; buttonAddBlueActionPerformed(e));            panelSetColor.add(buttonAddBlue, new GridConstraints(2, 3, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));        }        contentPane.add(panelSetColor, new GridConstraints(0, 0, 1, 1,            GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        //======== panelColor ========        {            panelColor.setLayout(new GridLayoutManager(1, 1, new Insets(0, 10, 0, 10), 0, 0));            //---- labelShowColor ----            labelShowColor.setText(&quot;\u6b64\u5904\u663e\u793a\u6700\u7ec8\u989c\u8272&quot;);            panelColor.add(labelShowColor, new GridConstraints(0, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));        }        contentPane.add(panelColor, new GridConstraints(2, 0, 1, 1,            GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        pack();        setLocationRelativeTo(getOwner());        // JFormDesigner - End of component initialization  //GEN-END:initComponents    }    // JFormDesigner - Variables declaration - DO NOT MODIFY  //GEN-BEGIN:variables    private JPanel panelSetColor;    private JLabel labelRed;    private JButton buttonSubRed;    private JTextField textFieldRed;    private JButton buttonAddRed;    private JLabel labelGreen;    private JButton buttonSubGreen;    private JTextField textFieldGreen;    private JButton buttonAddGreen;    private JLabel labelBlue;    private JButton buttonSubBlue;    private JTextField textFieldBlue;    private JButton buttonAddBlue;    private JPanel panelColor;    private JLabel labelShowColor;    // JFormDesigner - End of variables declaration  //GEN-END:variables}</code></pre><h2 id="带IO操作的登录窗体"><a href="#带IO操作的登录窗体" class="headerlink" title="带IO操作的登录窗体"></a>带IO操作的登录窗体</h2><blockquote><p>编写一个登录窗体，输入用户名和密码，验证通过显示登录成功的消息框，否则显示用户名或密码错误的消息框。用户名和密码存放在 c 盘 java 目录下的 login.txt 中，用文本信息存储，每行一个用户名和密码，用户名和密码用 # 分隔</p></blockquote><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code class="java">import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.Arrays;import javax.swing.*;import com.intellij.uiDesigner.core.*;/** * @author huxiaofan */public class loginPanel extends JFrame {    File f = new File(&quot;login.txt&quot;); //创建一个用于读取用户名密码的文件对象    public static void main(String[] args) {        new loginPanel().setVisible(true); //显示窗体    }    public loginPanel() {        initComponents();    }    private void buttonLoginActionPerformed(ActionEvent e) {        // TODO add your code here        if(doLogin())            optionPaneok.showMessageDialog(null,&quot;恭喜你登录成功！&quot;,&quot;登录成功&quot;,JOptionPane.INFORMATION_MESSAGE); //显示成功弹窗        else            optionPanefail.showMessageDialog(null, &quot;用户名密码错误！&quot;, &quot;登录失败&quot;,JOptionPane.ERROR_MESSAGE); //显示失败弹窗    }    boolean doLogin(){  //函数登录成功返回 true        try {            BufferedReader br = new BufferedReader(new FileReader(f));  //新建字符缓冲流            String u = textFieldUserName.getText();  //获取用户输入在文本框的用户名            String p = String.valueOf(passwordFieldPass.getPassword());  //获取用户输入在密码框的密码，要把原始的字符数组用 String.valueOf() 方法转为字符串            String s;  //存放临时读取的每一行字符串            while((s = br.readLine())!=null){                String[] temp = s.split(&quot;#&quot;);  //拆分字符串                if(temp[0].equals(u)&amp;&amp;temp[1].equals(p)){                    System.out.println(&quot;登录成功&quot;);                    return true;                }            }            br.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return false;    }    private void button2ActionPerformed(ActionEvent e) {        // TODO add your code here    }……</code></pre><h3 id="UI自动生成代码"><a href="#UI自动生成代码" class="headerlink" title="UI自动生成代码"></a>UI自动生成代码</h3><pre><code class="java">……    private void initComponents() {        // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents        panel1 = new JPanel();        labelUser = new JLabel();        textFieldUserName = new JTextField();        labelPass = new JLabel();        passwordFieldPass = new JPasswordField();        buttonLogin = new JButton();        optionPaneok = new JOptionPane();        optionPanefail = new JOptionPane();        //======== this ========        setTitle(&quot;Emptinessboy \u6155\u8bfeIO\u4f5c\u4e1a&quot;);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setMinimumSize(new Dimension(420, 250));        Container contentPane = getContentPane();        contentPane.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 5, 0), -1, -1));        //======== panel1 ========        {            panel1.setMinimumSize(new Dimension(180, 90));            panel1.setLayout(new GridLayoutManager(2, 2, new Insets(10, 30, 10, 60), 0, 10));            //---- labelUser ----            labelUser.setText(&quot;\u7528\u6237\u540d \uff1a&quot;);            labelUser.setFont(labelUser.getFont().deriveFont(labelUser.getFont().getStyle() | Font.BOLD, labelUser.getFont().getSize() + 3f));            panel1.add(labelUser, new GridConstraints(0, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- textFieldUserName ----            textFieldUserName.setFont(textFieldUserName.getFont().deriveFont(textFieldUserName.getFont().getSize() + 3f));            panel1.add(textFieldUserName, new GridConstraints(0, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- labelPass ----            labelPass.setText(&quot;\u5bc6   \u7801 \uff1a&quot;);            labelPass.setFont(labelPass.getFont().deriveFont(labelPass.getFont().getStyle() | Font.BOLD, labelPass.getFont().getSize() + 3f));            panel1.add(labelPass, new GridConstraints(1, 0, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_NONE,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));            //---- passwordFieldPass ----            passwordFieldPass.setFont(passwordFieldPass.getFont().deriveFont(passwordFieldPass.getFont().getSize() + 3f));            panel1.add(passwordFieldPass, new GridConstraints(1, 1, 1, 1,                GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,                null, null, null));        }        contentPane.add(panel1, new GridConstraints(0, 0, 1, 1,            GridConstraints.ANCHOR_SOUTH, GridConstraints.FILL_HORIZONTAL,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        //---- buttonLogin ----        buttonLogin.setText(&quot;\u767b \u5f55&quot;);        buttonLogin.setVerticalTextPosition(SwingConstants.TOP);        buttonLogin.setFont(buttonLogin.getFont().deriveFont(buttonLogin.getFont().getStyle() | Font.BOLD, buttonLogin.getFont().getSize() + 3f));        buttonLogin.addActionListener(e -&gt; {            button2ActionPerformed(e);            buttonLoginActionPerformed(e);        });        contentPane.add(buttonLogin, new GridConstraints(1, 0, 1, 1,            GridConstraints.ANCHOR_NORTH, GridConstraints.FILL_NONE,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,            null, null, null));        pack();        setLocationRelativeTo(getOwner());        //---- optionPaneok ----        optionPaneok.setIcon(UIManager.getIcon(&quot;OptionPane.informationIcon&quot;));        optionPaneok.setMessageType(JOptionPane.INFORMATION_MESSAGE);        //---- optionPanefail ----        optionPanefail.setIcon(UIManager.getIcon(&quot;OptionPane.errorIcon&quot;));        optionPanefail.setMessageType(JOptionPane.ERROR_MESSAGE);        // JFormDesigner - End of component initialization  //GEN-END:initComponents    }    // JFormDesigner - Variables declaration - DO NOT MODIFY  //GEN-BEGIN:variables    private JPanel panel1;    private JLabel labelUser;    private JTextField textFieldUserName;    private JLabel labelPass;    private JPasswordField passwordFieldPass;    private JButton buttonLogin;    private JOptionPane optionPaneok;    private JOptionPane optionPanefail;    // JFormDesigner - End of variables declaration  //GEN-END:variables}</code></pre><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><a href="https://up.media.everdo.cn/image/nsxs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/05/29/hxfiowork.gif" alt="hxfiowork.gif"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习笔记01（基本语法）</title>
      <link href="/2020/04/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%89/"/>
      <url>/2020/04/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>！Python 程序各行开头的空白区称为缩进，这在 Python 中非常重要，Python 使用缩进来确定各行的级别和分组。处于同一级别的语句行的缩进必须是一致的。</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python 的单行注释以 <strong>#</strong> 井号 开头，注释从井号开始到行结束的所有字符。多行注释使用三个单引号 <strong>‘’’注释内容’’’</strong> 来进行标记。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是为了给例如变量、函数这些对象命名，命名标识符的规则如下：</p><ul><li>第一个字符为字母表中的字母或下划线</li><li>其他字符可包括字母、数字或下划线</li><li>标识符区分大小写</li><li>命名标识符不要和 Python 保留字同名</li></ul><h2 id="变量及赋值"><a href="#变量及赋值" class="headerlink" title="变量及赋值"></a>变量及赋值</h2><p>Python 中的变量不需要显示声明，当对一个变量名第一次赋值的时候，就是它被创建的时候。</p><pre><code class="python">a = b = z = 1Python 中给多个变量同时赋值的方法：a, b, c = 1, 2, 3Python 中交换两个变量的方法：a, b = b, a</code></pre><p>可以通过 type() 查看变量数据类型，id() 可以输出变量地址。<strong>Python变量名只是Python对象的标签，其本质是地址引用。对于小整数，系统已经预先分配内存空间。</strong></p><blockquote><p>内置函数可以被我们覆盖！！</p><p>如 <code>sum([1,2,3])</code> 的输出为 6，而如果我们给 sum 赋值 <code>sum = 1</code></p><p>那么这时 sum 的函数功能就失效了</p><p>若要恢复，则需要 <code>del(sum)</code></p></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>input 函数的作用是从键盘输入得到一个字符串并返回</p><p>input 函数可以无参数（小括号里为空），也可以给出提示性的文本，该文本会在运行的时候首先输出。<strong>input 函数的返回必然是一个字符串。</strong></p><p><strong>方式一：</strong> 可以使用 eval() 函数将用户输入的数字字符串转换成数字。eval 函数的作用是执行一个字符串表达式，并返回这个表达式的值。</p><p><strong>方式二：</strong> 强制类型转换 使用 int() 函数可以强制转换为整型</p><h3 id="直接切割输入"><a href="#直接切割输入" class="headerlink" title="直接切割输入"></a>直接切割输入</h3><pre><code class="python">x1,y1 = eval(input(&quot;请输入x1,y1坐标：&quot;))a,b,c = eval(input())</code></pre><h3 id="split-对输入进行切割"><a href="#split-对输入进行切割" class="headerlink" title="split 对输入进行切割"></a>split 对输入进行切割</h3><pre><code class="python"># a,b以斜线分割输入a,b = input().split(&quot;/&quot;)# 强制类型转换需要使用 map 映射a,b,c=map(int,input().split(&quot; &quot;))</code></pre><h3 id="eval-函数示例"><a href="#eval-函数示例" class="headerlink" title="eval 函数示例"></a>eval 函数示例</h3><pre><code class="python">a = eval(&quot;{&#39;a&#39;:{&#39;b&#39;:10,&#39;c&#39;:6}}&quot;)&gt;&gt;&gt; a{&#39;a&#39;: {&#39;b&#39;: 10, &#39;c&#39;: 6}}&gt;&gt;&gt; type(a)&lt;class &#39;dict&#39;&gt;</code></pre><pre><code class="python">x = 7&gt;&gt;&gt; eval( &#39;3 * x&#39; )21&gt;&gt;&gt; eval(&#39;pow(2,2)&#39;)4&gt;&gt;&gt; eval(&#39;2 + 2&#39;)4</code></pre><h2 id="print-函数"><a href="#print-函数" class="headerlink" title="print 函数"></a>print 函数</h2><p>print 是一个 Python 的内置函数，它的作用是输出一个或者多个对象的文本表示。print 默认向交互窗口输出。</p><pre><code class="python">print(&quot;HelloWorld!&quot;)</code></pre><blockquote><p>无参数的 print 输出一个空行</p><p>print 函数输出对象的文本表示，因此整数 100 和字符串 ”100” 的文本表示是一样的。</p><p>当 print 参数包含多个对象时，则依次输出每一个对象的文本表示，默认使用空格分隔。</p></blockquote><p>对 print 对 end 参数进行设置，可以去除换行，例如：</p><pre><code class="python">print(666,end=&quot;&quot;)</code></pre><h2 id="turtle-库"><a href="#turtle-库" class="headerlink" title="turtle 库"></a>turtle 库</h2><p>使用：</p><pre><code class="python">import turtle</code></pre><p>turtle 中包含了很多个函数，官方文档：<a href="https://docs.python.org/3.8/library/turtle.html" target="_blank" rel="noopener">https://docs.python.org/3.8/library/turtle.html</a></p><h3 id="画笔运动命令"><a href="#画笔运动命令" class="headerlink" title="画笔运动命令"></a><strong>画笔运动命令</strong></h3><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>turtle.forward(distance)</td><td>向当前画笔方向移动 distance 像素长度</td></tr><tr><td>turtle.backward(distance)</td><td>向当前画笔相反方向移动 distance 像素长度</td></tr><tr><td>turtle.right(degree)</td><td>顺时针转动 degree°</td></tr><tr><td>turtle.left(degree)</td><td>逆时针转动 degree°</td></tr><tr><td>turtle.pendown()</td><td>移动时绘制图形，缺省时也为绘制</td></tr><tr><td>turtle.penup()</td><td>提起笔移动，不绘制图形，用于另起—个地方绘制</td></tr><tr><td>turtle.goto(x,y)</td><td>将画笔移动到坐标为 x,y 的位置（画笔未提起时按直线移动并绘制）</td></tr><tr><td>setx()</td><td>将当前x轴移动到指定位置</td></tr><tr><td>sety()</td><td>将当前y轴移动到指定位置</td></tr><tr><td>setheading(angle)</td><td>设置当前朝向为angle角度</td></tr><tr><td>home()</td><td>设置当前画笔位置为原点，朝向东。</td></tr><tr><td>dot(r)</td><td>绘制一个指定直径和颜色的圆点</td></tr></tbody></table><h3 id="画笔控制命令"><a href="#画笔控制命令" class="headerlink" title="画笔控制命令"></a><strong>画笔控制命令</strong></h3><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>turtle.color(color1, color2)</td><td>同时设置pencolor=color1, fillcolor=color2</td></tr><tr><td>turtle.fillcolor(colorstring)</td><td>绘制图形的填充颜色</td></tr><tr><td>turtle.begin_fill()</td><td>准备开始填充图形</td></tr><tr><td>turtle.end_fill()</td><td>填充完成</td></tr><tr><td>turtle.filling()</td><td>返回当前是否在填充状态</td></tr><tr><td>turtle.hideturtle()</td><td>隐藏画笔的 turtle 形状</td></tr><tr><td>turtle.showturtle()</td><td>显示画笔的 turtle 形状</td></tr><tr><td>turtle.write(s, [font])</td><td>写文本，s为文本内容，font是字体的参数</td></tr><tr><td>turtle.circle(radius,extent,step)</td><td>radius表示半径，正值时逆时针旋转；extent 表示度数，用于绘制圆弧；step 表示边数，可用于绘制正多边形；（extent 和 step 参数可有可无。）</td></tr><tr><td>turtle.pensize()</td><td>设置画笔粗细，小于10的数</td></tr></tbody></table><h3 id="画笔全局命令"><a href="#画笔全局命令" class="headerlink" title="画笔全局命令"></a><strong>画笔全局命令</strong></h3><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>turtle.clear()</td><td>清空turtle窗口，但是turtle的位置和状态不会改变</td></tr><tr><td>turtle.reset()</td><td>清空窗口，重置turtle状态为起始状态</td></tr><tr><td>turtle.undo()</td><td>撤销上一个turtle动作</td></tr><tr><td>turtle.isvisible()</td><td>返回当前turtle是否可见</td></tr><tr><td>stamp()</td><td>复制当前图形</td></tr><tr><td>turtle.speed(speed)</td><td>画笔动画速度（0-10）</td></tr><tr><td>turtle.tracer(False)</td><td>是否显示动画</td></tr></tbody></table><blockquote><p>turtle.done() <strong>/</strong> 用来停止画笔绘制，但绘图窗体不关闭。</p></blockquote><p><strong>DEMO 画十字</strong></p><pre><code class="python">import turtleturtle.write(&quot;Welcometoturtle!&quot;)turtle.penup()turtle.goto(-100,0)turtle.pendown()turtle.goto(100,0)turtle.penup()turtle.goto(0,100)turtle.pendown()turtle.goto(0,-100)turtle.done()</code></pre><p><a href="https://up.media.everdo.cn/image/ILil" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/24/turtle-.jpg" alt="turtle.jpg"></a></p><p><strong>DEMO 画五角星</strong></p><pre><code class="python">import turtlefor i in range (5):    turtle.forward(100)    turtle.right(144)turtle.done()</code></pre><p><a href="https://up.media.everdo.cn/image/I8v0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/24/turtle.jpg" alt="turtle.jpg"></a></p><p><strong>DEMO 画奥迪车标</strong></p><pre><code class="python">import turtleturtle.penup()turtle.goto(-140,0)turtle.pendown()for i in range(4):    turtle.circle(50)    turtle.penup()    turtle.forward(80)    turtle.pendown()turtle.done()</code></pre><p><a href="https://up.media.everdo.cn/image/IalD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/24/turtlelogo.jpg" alt="turtlelogo.jpg"></a></p><p><strong>DEMO 正六边形</strong></p><pre><code class="python">import turtleturtle.right(36)turtle.color(&quot;orange&quot;,&quot;orange&quot;)turtle.begin_fill()turtle.circle(100,360,5)turtle.end_fill()turtle.hideturtle()turtle.done()</code></pre><p><a href="https://up.media.everdo.cn/image/IlDL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/24/turtlebaa66bd7ff2b7d56.jpg" alt="turtlebaa66bd7ff2b7d56.jpg"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inteliJ 学习 SwingGui 记录</title>
      <link href="/2020/04/inteliJ-%E5%AD%A6%E4%B9%A0SwingGui%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/04/inteliJ-%E5%AD%A6%E4%B9%A0SwingGui%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="GUI-相关工具组件"><a href="#GUI-相关工具组件" class="headerlink" title="GUI 相关工具组件"></a>GUI 相关工具组件</h2><h3 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h3><p>abstract window toolkit 抽象窗口工具包，提供了图形用户界面和图形，直接调用本地系统接口完成。</p><h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><p>Swing 是建立在 AWT 基础之上的，它利用了 AWT 的底层组件，包括图形、颜色、字体等。增加了界面修饰，使界面更美观，在丌同的操作系统中的显示更为相似。</p><a id="more"></a><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><blockquote><p>组件是一个可以以图形化的方式显示在屏幕上并能与用户进行交互的对象，例如一个按钮，一个标签等。容器本身也是一个组件，具有组件的所有性质，但是它的主要功能是容纳其它组件和容器。</p></blockquote><table><thead><tr><th>基本组件</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Window类</td><td>窗口类</td><td>Window 类的实例没有边框和标题,并且不能附加或嵌入到另一个容器中</td></tr><tr><td>Frame类</td><td>框架类</td><td>Frame 类的实例可以有一个菜单条，否则它与 Window 类的对象非常相似</td></tr><tr><td>Dialog类</td><td>对话框类</td><td>Dialog 类的对象只有在一个相关的 Frame 类对象存在时才存在</td></tr><tr><td>Panel类</td><td>面板类</td><td>Panel 类的是实例提供一个可以加入组件的容器，是容器组件的通用容器</td></tr></tbody></table><p>AWT 中的基本控件：</p><p>Button按钮，Label标签，TextField文本框，TextArea多行文本框，Checkbox复选框，CheckboxGroup单选框，Choice下拉式列表，List列表，Menu菜单<br>，Scrollbar滚动条</p><blockquote><p>.pack() 方法可以使组件适应大小调整<br>setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 设置默认窗体关闭按钮动作</p></blockquote><p>添加组件非常简单，只需要使用容器的 add 方法，例如 awt 下：</p><pre><code class="java">Frame f = new Frame();f.setLayout(new FlowLayout);Button b = new Button(&quot;ok&quot;)f.add(b)</code></pre><p>容器 Container 是一个类，实际上是 Component 的子类。容器的各种的组件的大小和位置是由容器的布局管理器进行控制。</p><blockquote><p>getContentPane() 返回此窗体的 contentPane 对象</p></blockquote><p>Swing 下：</p><pre><code class="java">JFrame jf = new JFrame();Container jframe_content = jf.getContentPane();jframe_content.setLayout(new FlowLayout);Button b = new Button(&quot;ok&quot;);jframe_content.add(b);jframe_content.add(new Button(&quot;Cancel&quot;))</code></pre><h4 id="公共属性"><a href="#公共属性" class="headerlink" title="公共属性"></a>公共属性</h4><pre><code class="java">public int getWidth() //宽度public int getHeight() //高度public void setSize(int width, int height) //宽度和高度public int getX() //位置的X坐标值public int getY() //位置的Y坐标值public void setLocation(int x, int y) //坐标位置，x、y指定组件左上角相对于容器的坐标位置</code></pre><pre><code class="java">public void setBounds(int x, int y, int width, int height) //坐标位置和宽度、高度public Color getBackground() //获得组件的背景颜色public void setBackground(Color c) //设置组件的背景颜色public Font getFont() //获得组件字体public void setFont(Font f) //设置组件字体public void setVisible(boolean b) //设置组件是否显示</code></pre><h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><blockquote><p>JFrame 和 JWindow 默认布局管理器为 BorderLayout，而 JPanel 默认的布局管理器为 FlowLayout。</p></blockquote><ul><li><p>BorderLayout（边框布局管理器）是 Window、JFrame 和 JDialog 的默认布局管理器。边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。</p></li><li><p>FlowLayout（流式布局管理器）是 JPanel 和 JApplet 的默认布局管理器。FlowLayout 会将组件按照从从左到右、上到下的放置规律逐行进行定位。（与其他布局管理器不同的是，FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。）</p></li><li><p>CardLayout（卡片布局管理器）能够帮助用户实现多个成员共享同一个显示空间，并且一次只显示一个容器组件的内容。（CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。）</p></li><li><p>GridLayout（网格布局管理器）为组件的放置位置提供了更大的灵活性。它将区域分割成行数（rows）和列数（columns）的网格状布局，组件按照由左至右、由上而下的次序排列填充到各个单元格中。（提示：GridLayout 布局管理器总是忽略组件的最佳大小，而是根据提供的行和列进行平分。该布局管理的所有单元格的宽度和高度都是一样的。）</p></li><li><p>GridBagLayout（网格包布局管理器）是在网格基础上提供复杂的布局，是最灵活、 最复杂的布局管理器。GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。每个 GridBagLayout 对象都维护了一组动态的矩形网格单元，每个组件占一个或多个单元，所占有的网格单元称为组件的显示区域。（GridBagLayout 所管理的每个组件都与一个 GridBagConstraints 约束类的对象相关。这个约束类对象指定了组件的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件。除了组件的约束对象，GridBagLayout 还要考虑每个组件的最小和首选尺寸，以确定组件的大小。）</p></li><li><p>BoxLayout（盒布局管理器）通常和 Box 容器联合使用。</p></li><li><p>SpringLayout 类实现的布局管理器称为弹簧布局管理器。利用该布局管理器管理组件，当改变窗体的大小时，能够在不改变组件间相对位置的前提下自动调整组件大小，使组件依旧布满整个窗体，从而保证了窗体的整体效果。</p></li><li><p>绝对布局，就是硬性指定组件在容 器中的位置和大小，可以使用绝对坐标的方式来指定组件的位置。（用户必须使用Java语言提供的setLocation(),setSize(),setBounds()等方法，为容器中的每个组件设置大小和显示位置，否则将无法看到这些组件。）</p></li></ul><h2 id="JAVA-事件"><a href="#JAVA-事件" class="headerlink" title="JAVA 事件"></a>JAVA 事件</h2><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><table><thead><tr><th>事件类型</th><th>事件内容</th></tr></thead><tbody><tr><td>ComponentEvent（组件事件）</td><td>组件尺寸的变化、移动</td></tr><tr><td>ContainerEvent（容器事件）</td><td>容器内组件的增加、删除</td></tr><tr><td>WindowEvent（窗口事件）</td><td>关闭和打开窗口</td></tr><tr><td>FocusEvent（焦点事件）</td><td>焦点的获得和释放</td></tr><tr><td>KeyEvent（键盘事件）</td><td>按键的按下，松开</td></tr><tr><td>MouseEvent（鼠标事件）</td><td>单击鼠标，拖动鼠标</td></tr><tr><td>ActionEvent（动作事件）</td><td>按钮按下，TextField中按Enter键</td></tr><tr><td>ItemEvent（项目事件）</td><td>选中项目或放弃选中项目</td></tr><tr><td>TextEvent（文本事件）</td><td>文本内容改变。</td></tr></tbody></table><h3 id="JAVA-事件监听器（难点）"><a href="#JAVA-事件监听器（难点）" class="headerlink" title="JAVA 事件监听器（难点）"></a>JAVA 事件监听器（难点）</h3><p><strong>1.事件对象：</strong> 一般继承自java.util.EventObject对象,由开发者自行定义.</p><p><strong>2.事件源：</strong> 就是触发事件的源头,不同的事件源会触发不同的事件类型.</p><p><strong>3.事件监听器：</strong> 事件监听器负责监听事件源发出的事件.一个事件监听器通常实现 java.util.EventListener 这个标识接口.</p><p>其整个处理过程是这样的,事件源可以注册事件监听器对象,并可以向事件监听器对象发送事件对象.事件发生后,事件源将事件对象发给已经注册的所有事件监听器. 监听器对象随后会根据事件对象内的相应方法响应这个事件.</p><p><strong>上面的正式说明我看糊涂了，以下为个人粗浅的理解：</strong></p><p>先看一段一段简单的实现按钮点击执行事件的实例代码：</p><pre><code class="java">Button b = new Button(&quot;button&quot;); //创建按钮b.addActionListener(new ActionListener() {    //使用内部匿名事件处理    @Override    public void actionPerformed(ActionEvent e) {        //点击后执行的代码    }});</code></pre><p>首先按钮等组件都会自带一个 addActionListener() 方法，这个方法需要传入一个参数（接口类ActionListener），并且这个类需要实现接口，其中必须写完整方法 actionPerformed(ActionEvent e)。</p><p>当 addActionListener() 方法被添加到按钮对象后，系统就会在后台监听事件发生，一旦触发事件（如按钮被点击），就会回调 ActionListener 接口中 actionPerformed() 这个方法，并传入参数 ActionEvent e。ActionEvent e 会包括发生事件的对象以及一些别的信息。</p><h3 id="JDK-源码"><a href="#JDK-源码" class="headerlink" title="JDK 源码"></a>JDK 源码</h3><p>官方源代码 JDK1.8：</p><p><strong><em>java\awt\event\ActionListener.java</em></strong></p><pre><code class="java">public interface ActionListener extends EventListener {    /**     * Invoked when an action occurs.     */    public void actionPerformed(ActionEvent e);}</code></pre><p><strong><em>java\awt\Button.java</em></strong></p><pre><code class="java">addActionListener(ActionListener l) {    if (l == null) {        return;    }    actionListener = AWTEventMulticaster.add(actionListener, l);    newEventsOnly = true;}</code></pre><p><strong><em>java\awt\AWTEventMulticaster.java</em></strong></p><pre><code class="java">public void processEvent(AWTEvent e) {    // when event occurs which causes &quot;action&quot; semantic    ActionListener listener = actionListener;    if (listener != null) {        listener.actionPerformed(new ActionEvent()); //这一步回调了！！！！    }}</code></pre><h3 id="实现监听的四种方法"><a href="#实现监听的四种方法" class="headerlink" title="实现监听的四种方法"></a>实现监听的四种方法</h3><h4 id="自身类作为事件监听器"><a href="#自身类作为事件监听器" class="headerlink" title="自身类作为事件监听器"></a>自身类作为事件监听器</h4><p>适合多个事件执行同一个方法，可以大大减少代码量，但东西多了就会很复杂</p><pre><code class="java">class EventListener extends JFrame implements ActionListener {    //继承JFrame，并继承接口    private JButton b1, b2;    public EventListener() {        //默认构造函数        ……定义窗体        b1 = new JButton(&quot;button&quot;);        b2 = new JButton(&quot;button&quot;);        // 将按钮添加事件监听器        //这一步就将自己所在的类传入        b1.addActionListener(this);        b2.addActionListener(this);        add(b1);add(b2);setVisible(true);    }    // ***********事件处理***********    @Override    public void actionPerformed(ActionEvent e) {        //多个按钮时需要通过传入的参数区分        if (e.getSource() == b1) {            //点击b1后执行的代码        } else if (e.getSource() == b2) {            //点击b2后执行的代码        }    }}</code></pre><h4 id="内部类处理"><a href="#内部类处理" class="headerlink" title="内部类处理"></a>内部类处理</h4><pre><code class="java">class EventListener extends JFrame {    private JButton b1, b2;    // 构造方法    public EventListener() {        ……定义窗体        b1 = new JButton(&quot;button&quot;);        b2 = new JButton(&quot;button&quot;);        // 添加事件监听器对象(面向对象思想)        b1.addActionListener(new b1Listener());        b2.addActionListener(new b2Listener());        add(b1);add(b2);setVisible(true);    }    // 内部类b1Listener，实现ActionListener接口    class b1Listener implements ActionListener {        @Override        public void actionPerformed(ActionEvent e) {            //点击b1后执行的代码        }    }    // 内部类b2Listener，实现ActionListener接口    class b2Listener implements ActionListener {        @Override        public void actionPerformed(ActionEvent e) {            //点击b2后执行的代码        }    }}</code></pre><h4 id="匿名内部类处理（inteliJ-默认）"><a href="#匿名内部类处理（inteliJ-默认）" class="headerlink" title="匿名内部类处理（inteliJ 默认）"></a>匿名内部类处理（inteliJ 默认）</h4><pre><code class="java">Button b1 = new Button(&quot;button&quot;);Button b2 = new Button(&quot;button&quot;); //创建按钮b1.addActionListener(new ActionListener() {    //使用内部匿名事件处理    @Override    public void actionPerformed(ActionEvent e) {        //点击b1后执行的代码    }});b2.addActionListener(new ActionListener() {    //使用内部匿名事件处理    @Override    public void actionPerformed(ActionEvent e) {        //点击b2后执行的代码    }});</code></pre><h4 id="外部类处理"><a href="#外部类处理" class="headerlink" title="外部类处理"></a>外部类处理</h4><pre><code class="java">class EventListener extends JFrame {    private JButton b1, b2;    public EventListener() {        ……定义窗体        b1 = new JButton(&quot;button&quot;);        b2 = new JButton(&quot;button&quot;);        // 将按钮添加事件监听器        b1.addActionListener(new b1Listener(this));        b2.addActionListener(new b2Listener());        add(b1);add(b2);setVisible(true);    }}// 外部类b1EventListener，实现ActionListener接口class b1Listener implements ActionListener {    private EventListener el;    @Override    public void actionPerformed(ActionEvent e) {        //点击b1后执行的代码    }}// 外部类DialogEventListener，实现ActionListener接口class b2Listener implements ActionListener {    @Override    public void actionPerformed(ActionEvent e) {        //点击b1后执行的代码    }}public class ActionListenerTest {    public static void main(String args[]) {        new EventListener();    }}</code></pre><h3 id="安卓中实现"><a href="#安卓中实现" class="headerlink" title="安卓中实现"></a>安卓中实现</h3><pre><code class="java">Button Cal = findViewById(R.id.buttonCal);Cal.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {    //点击后执行的代码    }});</code></pre><h2 id="常用属性之类"><a href="#常用属性之类" class="headerlink" title="常用属性之类"></a>常用属性之类</h2><p>此处先随便整理些课上讲的：</p><h3 id="简单控件"><a href="#简单控件" class="headerlink" title="简单控件"></a>简单控件</h3><p>text 属性：控件显示的文本</p><p>Columns 属性：控件列宽</p><p>变量名称 fieldname 属性：设置组件ID</p><p>按钮的 action 事件：点击执行的函数</p><p>控件的 getText 和 setText 方法：显示和修改文字</p><pre><code class="java">jTextField.getText()    //返回 String</code></pre><p>System.exit方法：结束程序（窗体的三种关闭方式：Exit、Dispose、Hide）</p><pre><code class="java">//ExitSystem.exit(0);//Dispose &amp; hidethis.dispose();this.hide();</code></pre><p>Lable 的 icon 属性：更改/显示标签的图片</p><pre><code class="java">//动态显示图片String s = System.getProperty(&quot;user.dir&quot;); //获取程序所在路径ImageIcon i = new ImageIcon(s+&quot;/hhh.jpg&quot;); //先设置ImageIconjLable.setIcon(i);</code></pre><p>icon 按比例缩放（用于不确定大小的图片不溢出）</p><pre><code class="java">ImageIcon i = new ImageIcon(s);Image pic = i.getImage().getScaledInstance(200,200,Image.SCALE_DEFAULT);ImageIcon ico = new ImageIcon(pic);PicLable.setIcon(ico);</code></pre><h3 id="单选按钮和复选框："><a href="#单选按钮和复选框：" class="headerlink" title="单选按钮和复选框："></a>单选按钮和复选框：</h3><pre><code>JTextArea：文本区域JRadioButton：单选按钮ButtonGroup：按钮组JCheckBox：复选框</code></pre><p>单选按钮具有 text、selected 属性；ButtonGroup是按钮组，不显示</p><h4 id="DEMO1"><a href="#DEMO1" class="headerlink" title="DEMO1"></a>DEMO1</h4><p>编写如图所示应用程序，选择字体字号后按设置按钮，上面文字按选择的字体和字号进行设置显示，按关闭按钮结束程序。</p><p><a href="https://up.media.everdo.cn/image/ImMX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/gui1.jpg" alt="gui1.jpg"></a></p><p>在 InteliJ 中，新建 Swing UI Designer，GUI Form</p><p><a href="https://up.media.everdo.cn/image/I9gi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui1.jpg" alt="hxfgui1.jpg"></a></p><p>输入类名后系统会自动创建两个文件，一个 form 文件和一个 java 文件。</p><p><a href="https://up.media.everdo.cn/image/IcD4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui2.jpg" alt="hxfgui2.jpg"></a></p><p>打开 form 文件，选定布局后即可在上面自由拖拽控件，此时应该将用到的控件添加 fieldname 也就是 ID 属性</p><p><a href="https://up.media.everdo.cn/image/IfcM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui3.jpg" alt="hxfgui3.jpg"></a></p><p>在可视化界面，右键控件可以自动生成监听器或快速跳转到监听器，这一步很方便</p><p><a href="https://up.media.everdo.cn/image/Is5Y" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui4.jpg" alt="hxfgui4.jpg"></a></p><p>创建完布局后，不同于 NetBeans，Idea 不会生成任何关于布局的 java 代码，所有的布局是在编译中直接打包进 class 的，并不是先为我们添加到 java 类文件。（这个很坑，没法偷懒直接拷贝他的代码了</p><p>系统就生成了这些：</p><pre><code class="java">package com.emptinessboy.learngui1;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class MainForm {    private JPanel panel;    private JButton ButtonSetting;    private JButton ButtonClose;    private JTextField TextField;    private JRadioButton SongTiRadioButton;    private JRadioButton HeiTiRadioButton;    private JRadioButton a12RadioButton;    private JRadioButton a18RadioButton;}</code></pre><p>在我们添加监听器，并编写完整代码后：</p><pre><code class="java">public MainForm() {    HeiTiRadioButton.setSelected(true);    a12RadioButton.setSelected(true);    ButtonSetting.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            System.out.println(&quot;设置按钮被点击&quot;);            if (HeiTiRadioButton.isSelected()){                if (a12RadioButton.isSelected()){                    TextField.setFont(new Font(&quot;黑体&quot;,0,12));                    System.out.println(&quot;设置为黑体12号&quot;);                }                else{                    TextField.setFont(new Font(&quot;黑体&quot;,0,18));                    System.out.println(&quot;设置为黑体18号&quot;);                }            }            if (SongTiRadioButton.isSelected()){                if (a12RadioButton.isSelected()){                    TextField.setFont(new Font(&quot;宋体&quot;,0,12));                    System.out.println(&quot;设置为宋体12号&quot;);                }                else{                    TextField.setFont(new Font(&quot;宋体&quot;,0,18));                    System.out.println(&quot;设置为宋体18号&quot;);                }            }        }    });    ButtonClose.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            System.exit(0);        }    });    SongTiRadioButton.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            if (SongTiRadioButton.isSelected()){                HeiTiRadioButton.setSelected(false);//单选框互斥                System.out.println(&quot;选中宋体&quot;);            }        }    });    HeiTiRadioButton.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            if (HeiTiRadioButton.isSelected()){                SongTiRadioButton.setSelected(false);//单选框互斥                System.out.println(&quot;选中黑体&quot;);            }        }    });    a12RadioButton.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            if (a12RadioButton.isSelected()){                a18RadioButton.setSelected(false);//单选框互斥                System.out.println(&quot;选中12号&quot;);            }        }    });    a18RadioButton.addActionListener(new ActionListener() {        @Override        public void actionPerformed(ActionEvent e) {            if (a18RadioButton.isSelected()){                a12RadioButton.setSelected(false);//单选框互斥                System.out.println(&quot;选中18号&quot;);            }        }    });}</code></pre><p>这里补充一波，<strong>设置字体和字号：</strong></p><pre><code class="java">TextField.setFont(new Font(&quot;宋体&quot;,0,18));</code></pre><p>最后到这里，程序没法运行。因为系统不会为我们生成 main 方法，手动生成很简单，直接右键即可：</p><p><a href="https://up.media.everdo.cn/image/I0Ra" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui5.jpg" alt="hxfgui5.jpg"></a></p><p>最后，运行效果：</p><p><a href="https://up.media.everdo.cn/image/I16s" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/guidemo01.gif" alt="guidemo01.gif"></a></p><p>查看编译生成的文件和打包成的 jar 后都可以看到，除了我们些的类，还要自动打包进去的 intelij/uiDesigner/core 的代码。推测，系统很可能把我们定义的布局文件生成到这些 class 里。</p><p><a href="https://up.media.everdo.cn/image/IMp3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui6.jpg" alt="hxfgui6.jpg"></a></p><p><strong>补充二</strong></p><p>这个案例，我是写程序判断 RadioButton 选中情况来实现两个按钮互斥功能，其实 intelij 也有 RadioButtonGroup，只不过没有像 NetBeans 那样显示到右侧组件栏</p><blockquote><p>（PS，intelij自带的组件真的少的可怜</p></blockquote><p><a href="https://up.media.everdo.cn/image/IyPG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui7.jpg" alt="hxfgui7.jpg"></a></p><p>ButtonGroup 的开启方式被隐藏到了属性栏</p><h3 id="组合框和列表"><a href="#组合框和列表" class="headerlink" title="组合框和列表"></a>组合框和列表</h3><pre><code>JTextField：文本字段JComboBox：组合框JList：列表</code></pre><p>JComboBox组合框，设置静态选项的方法是设置 model 属性，一行一个：</p><p><a href="https://up.media.everdo.cn/image/ITi9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui8.jpg" alt="hxfgui8.jpg"></a></p><p>动态修改则使用 addIthem 方法</p><pre><code class="java">comboBox.addItem(&quot;字符串&quot;);</code></pre><p>设置默认选中项，同理可以 get</p><pre><code class="java">comboBox.setSelectedIndex(0);</code></pre><p>JList列表要增加内容比较复杂，需要使用 setModel 方法，传入一个类，父类是抽象类，需要完成 getSize 和 getElementAt 方法</p><pre><code class="java">list.setModel(new AbstractListModel() {    String[] strings = {&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;};    @Override    public int getSize() {        return strings.length;    }    @Override    public Object getElementAt(int index) {        return strings[index];    }});</code></pre><h3 id="对话框和菜单"><a href="#对话框和菜单" class="headerlink" title="对话框和菜单"></a>对话框和菜单</h3><p>新建方式和新建窗体类似</p><p><a href="https://up.media.everdo.cn/image/IXvj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxf-gui9.png" alt="hxf-gui9.png"></a></p><p>打开对话框方式</p><pre><code class="java">new testDialog().setVisible(true);</code></pre><p>菜单：</p><pre><code class="java">JMenuBar：菜单条JMenu：菜单JMenuItem：菜单项</code></pre><p>通用对话框:</p><pre><code class="java">JFileChooser：文件选择对话框JOptionPane：消息对话框JColorChooser：颜色选择对话框</code></pre><p>文件选则的详细调用方法：</p><pre><code class="java">JFileChooser fc = new JFileChooser();int i = fc.showOpenDialog(ButtonChose);if(i==0){    s = fc.getSelectedFile().toString();    System.out.println(s);}else    System.out.println(&quot;被取消&quot;);</code></pre><p>JOptionPane：</p><pre><code class="java">JOptionPane.showConfirmDialog(null,&quot;yes or no&quot;,&quot;标题&quot;,JOptionPane.YES_NO_OPTION);</code></pre><h4 id="DEMO2"><a href="#DEMO2" class="headerlink" title="DEMO2"></a>DEMO2</h4><p>编写如图所示应用程序，单击选择图片文件按钮后，显示下面的打开文件对话框，选择要显示的图片，点击显示图片，显示刚刚选中的图片，按关闭按钮结束程序。</p><p><a href="https://up.media.everdo.cn/image/ICgO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/tp2.th.png" alt="tp2.th.png"></a></p><p>先设计窗体：</p><p><a href="https://up.media.everdo.cn/image/IpD6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui10.jpg" alt="hxfgui10.jpg"></a></p><p>接下来添加按钮点击事件,</p><p>文件选则按钮代码:</p><pre><code class="java">ButtonChose.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {        JFileChooser fc = new JFileChooser();        int i = fc.showOpenDialog(ButtonChose);        if(i==0){            s = fc.getSelectedFile().toString();            System.out.println(s);        }        else            System.out.println(&quot;被取消&quot;);    }});</code></pre><p>显示图片按钮代码：</p><pre><code class="java">ButtonShow.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {        ImageIcon i = new ImageIcon(s);        Image pic = i.getImage().getScaledInstance(200,200,Image.SCALE_DEFAULT);        ImageIcon ico = new ImageIcon(pic);        PicLable.setIcon(ico);    }});</code></pre><p>退出程序按钮代码：</p><pre><code class="java">ButtonClose.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {        System.exit(0);    }});</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/Iw5S" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui12.jpg" alt="hxfgui12.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/Itfn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui13.jpg" alt="hxfgui13.jpg"></a></p><h2 id="JFormDesigner"><a href="#JFormDesigner" class="headerlink" title="JFormDesigner"></a>JFormDesigner</h2><p>这是一款 idea 的增强 GUI 设计插件，设计的界面可以生成标准的 java 代码，而不是像 idea 自带的 Swing GUI Designer 一样没有代码生成。</p><p>同时这个插件还有更多的组件可以供选择！！！</p><p><a href="https://up.media.everdo.cn/image/IZNJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/22/hxfgui14.jpg" alt="hxfgui14.jpg"></a></p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>使用这个插件一定要手动编写 main 方法，系统生成的不管用。手动编写其实只要一句话：(新建时继承选择Jframe)</p><pre><code class="java">public static void main(String[] args) {    new form1().setVisible(true);}</code></pre><p><del>时间关系，JFormDesigner 我还没有深入使用，下次折腾了再补充！</del></p><hr><p>后来做了两个MOOC的练习，因为有些控件 IEDA 自带的设计器找不到，故使用了 JFD。</p><p>见链接： <a href="https://coding.emptinessboy.com/2020/05/%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JAVA-GUI%E7%BB%83%E4%B9%A0/">JFD使用的两个案例</a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 异常处理（转）</title>
      <link href="/2020/04/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2020/04/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>本文转载自 CSDN 泰斗贤若如 这位dalao</p><p>这篇文章将异常处理讲解的很细致，作为学习资料，在此收藏了！</p></blockquote><h2 id="异常的简介"><a href="#异常的简介" class="headerlink" title="异常的简介"></a>异常的简介</h2><p>在 Java 中，异常就是 Java 在编译、运行或运行过程中出现的错误。</p><h3 id="产生异常原因"><a href="#产生异常原因" class="headerlink" title="产生异常原因"></a>产生异常原因</h3><p>程序错误分为三种：编译错误、运行时错误和逻辑错误</p><ol><li><p>编译错误：因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置，这个也是新手在刚接触编程语言时经常遇到的问题。</p></li><li><p>运行时错：因为程序在执行时，运行环境发现了不能执行的操作。如除零</p></li><li><p>逻辑错误：因为程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制。</p></li></ol><p>下面看一段代码：</p><pre><code class="java">public class Test {    public static void main(String[] args) {        System.out.println(1/0);    //0不能做除数    }}</code></pre><p>运行后的结果为：</p><p><a href="https://up.media.everdo.cn/image/IbaL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/1.png" alt="1.png"></a></p><p>我们发现程序出了错，而图中的错误信息告诉我们两个信息：</p><p>出了什么错 / 出错的位置</p><h3 id="异常产生的过程"><a href="#异常产生的过程" class="headerlink" title="异常产生的过程"></a>异常产生的过程</h3><p>以上面的代码为例，程序在运行过程中，先运行 main 方法，然后执行到 1/0 时，程序就会报错，程序先会创建一个错误对象，然后把这个错误对象丢出来，我们都知道我们的程序是运行在 Java 虚拟机 (JVM) 上，程序丢出来的错误对象就会被 JVM 捕获到。当然，JVM 捕获到错误对象后，它也不知道该怎么办，它不可能帮你调错，JVM 会把错误信息给你打印出来。</p><p>总结：</p><ul><li>上例中出现的异常是运行时异常（异常是错误）</li><li>程序会创建一个错误对象，然后把错误对象丢出来（抛异常）</li><li>默认由JVM把错误信息进行捕获，打印出来（捕获异常）</li></ul><br><h3 id="为什么不能直接让JVM获取异常"><a href="#为什么不能直接让JVM获取异常" class="headerlink" title="为什么不能直接让JVM获取异常"></a>为什么不能直接让JVM获取异常</h3><blockquote><p>答：会造成程序中断</p></blockquote><p>先看下面代码：</p><pre><code class="java">public class Test {    public static void main(String[] args) {        System.out.println(1/0);    //0不能做除数        System.out.println(&quot;你好&quot;);    }}</code></pre><p><a href="https://up.media.everdo.cn/image/IeAc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/2.png" alt="2.png"></a></p><p>从上面代码和运行结果中，我们不难看出在控制台没有打印出你好。出现这种情况，是因为在 JVM 捕获到异常后，程序会终止。换句话说，在由 JVM 来处理错误的时候，此时，程序会终止，因此异常之后的代码就无法运行了。我们可以根据生活实例想想，什么时候百度会因为搜不到东西停服务，肯定是不会的，因此我们后面要做的就是如何在异常到达JVM之前把异常拦下来，自己单独处理，就不要麻烦 JVM 了。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>在上面实例中我说过程序会创建错误对象，说到对象，我们都知道对象是由类创建的，那异常对象肯定是通过异常类来创建的。下面图中就是 Java 给我们提供的异常类：</p><p><a href="https://up.media.everdo.cn/image/Iic2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/3.png" alt="3.png"></a></p><p>从图中我们能看出 Throwable 是所有异常的根，所有的异常类都继承自 Throwable，就像面向对象里面所有的类都继承自 Object。</p><p>下面我来说一下异常的分类：</p><ul><li>RuntimeException：运行时异常，一般不手动处理，出问题了再处理。</li><li>其他Exception：必须要经过手动处理。</li><li>Error：一般指的是系统级错误。</li></ul><p>我再用生活例子解释一下这三种异常，便于新手理解：</p><p>假设我们现在开车上山，开车的过程中发现山上有许多小石头，但我们不可能把所有小石头都处理了，这时候我们依旧正常开，什么时候小石头把车胎给弄坏了，我们再下来，换备胎，这就是 运行时异常</p><p>开车的过程中发现前面有一个很大的石头挡住了路，这时候你必须下车先把这石头挪走，你才能继续上山，这也就是 其他Exception。</p><p>开车上山的过程中山塌陷了，你又无法处理，必须要等到山好了你才能继续出发，也就是 Error，就是这种错误我们一般的程序员是处理不了的。</p><h2 id="异常的处理方法"><a href="#异常的处理方法" class="headerlink" title="异常的处理方法"></a>异常的处理方法</h2><h3 id="try···catch处理"><a href="#try···catch处理" class="headerlink" title="try···catch处理"></a>try···catch处理</h3><p>语法：</p><pre><code class="java">try{    //尝试执行的代码        }catch(Exception e){    //处理异常的代码        }finally{    //最终的}</code></pre><p>下面我将文中案例进行改造：</p><pre><code class="java">public class Test {    public static void main(String[] args) {        try {            System.out.println(1/0);            //0不能做除数        }catch (Exception e){            e.printStackTrace();            //打印错误信息，给程序员看的            System.out.println(&quot;系统出现错误，请联系管理员&quot;);            //给客户看的        }finally {            //一般做收尾工作            System.out.println(&quot;你好&quot;);        }    }}</code></pre><p>运行结果：</p><p><a href="https://up.media.everdo.cn/image/IWSt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/a.png" alt="a.png"></a></p><p>其中：</p><p>try： 用于监听。将要被监听的代码(可能抛出异常的代码)放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。</p><p>catch： 用于捕获异常。catch 用来捕获 try 语句块中发生的异常。</p><p>finally： finally 语句块总是会被执行。它主要用于回收在 try 块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。</p><h3 id="throws-和-throw处理"><a href="#throws-和-throw处理" class="headerlink" title="throws 和 throw处理"></a>throws 和 throw处理</h3><ul><li>throws 表示方法准备要扔出来一个异常</li><li>throw 表示向外抛出异常</li></ul><p>举例说明：</p><pre><code class="java">public class Test1 {    public static void chu(int a,int b) throws Exception{        if (b==0){            throw new Exception(&quot;除数不能为0&quot;);        }else {            System.out.println(a/b);        }    }    public static void main(String[] args) throws Exception{        chu(1,0);    }}</code></pre><p><a href="https://up.media.everdo.cn/image/IrZZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/4.png" alt="4.png"></a></p><p>以上这两种方法都是处理异常的，如果这个异常你可以处理，就用 try···catch 方法捕获并处理异常，如果这个异常你不能处理，就用 throws 方法抛出异常，但作为程序员的我们要始终记住一句话：<strong>产生的错误尽可能的自己处理，少向外抛出异常。</strong></p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>到这可能有的朋友要问了，为什么要自定义异常，Java 给的那么多还不够用吗？我可以告诉你，当然不够用，比如在生活中，我们都知道外面的澡堂子里边是分男女澡堂的，如果有男顾客走进了女澡堂或有女顾客走进了男澡堂，就坏事了，这算是一个大异常吧，那大家想，jdk 会给我们提供跟性别还有澡堂子有关的异常吗？肯定是不可能的，那此时就需要我们自定义异常。我以澡堂子为例，写一个程序，供大家参考。</p><blockquote><p>我的解读是，有些东西在系统看来不属于异常，但对我们程序逻辑来说是有问题的，这个没法用系统自动捕获抛出</p></blockquote><p><strong>自定义异常：直接继承 Exception 或者 RuntimeException 来是实现自定义异常</strong></p><p>Person 类：</p><pre><code class="java">public class Person {    String name;//姓名    String gender;//性别    public Person(String name, String gender) {        this.name = name;        this.gender = gender;    }}</code></pre><p>ZaoTangZi 类:</p><pre><code class="java">public class ZaoTangZi {    public void man(Person p) throws GenderException{        if (p.gender==&quot;男&quot;){            System.out.println(&quot;欢迎光临&quot;);        }else {            //需要抛出一个异常            throw new GenderException(&quot;性别错误，这里是男澡堂子&quot;);        }    }}</code></pre><p>GenderException 类:</p><pre><code class="java">public class GenderException extends Exception{    //自己定义的异常必须要继承Exception或RuntimeException    public GenderException(String msg){        super(msg);//调用父类的构造方法，Exception(msg)    }}</code></pre><p>Test 类:</p><pre><code class="java">public class Test {    public static void main(String[] args) throws GenderException{        Person p1 = new Person(&quot;张三&quot;,&quot;男&quot;);        Person p2 = new Person(&quot;小花&quot;,&quot;女&quot;);        ZaoTangZi z = new ZaoTangZi();        z.man(p2);    }}</code></pre><p>运行结果：</p><p><a href="https://up.media.everdo.cn/image/INPx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/21/b.png" alt="b.png"></a></p><p>文末，我们应该明白以下几个问题：什么是异常，出现异常如何处理，如何自定义异常。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发 Activity的详解（下）</title>
      <link href="/2020/04/Android%E5%BC%80%E5%8F%91-Activity%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/04/Android%E5%BC%80%E5%8F%91-Activity%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h2><p>在 Android 中每个界面都是一个 Activity，切换界面操作其实是多个不同 Activity 之间的实例化操作。在 Android 中 Activity 的启动模式决定了 Activity 的启动运行方式。</p><p>Activity启动模式设置（src/main/AndroidManifest.xml）：</p><pre><code class="xml">&lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;standard&quot; /&gt;</code></pre><p>Activity 的四种启动模式：</p><p>1.Standard 2.singleTop 3.singleTask 4.singleInstance</p><h3 id="Standard-默认模式"><a href="#Standard-默认模式" class="headerlink" title="Standard 默认模式"></a>Standard 默认模式</h3><p>默认启动模式，每次激活 Activity 时都会创建 Activity，并放入任务栈中。</p><p><strong>实验：</strong></p><p>创建一个全新的应用程序，在 MainActivity 添加一个按钮，点击后的 Intent 为再启动一个 MainActivity。</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    private static final String TAG = &quot;MainActivity&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Log.d(TAG, &quot;onCreate: &quot;+MainActivity.this.toString());        Button buttonGo = findViewById(R.id.buttonGo);        buttonGo.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //点击按钮后再启动一个 MainActivity                Intent intent = new Intent(MainActivity.this,MainActivity.class);                startActivity(intent);            }        });    }}</code></pre><p>运行后，不断点击按钮测试：</p><p><a href="https://up.media.everdo.cn/image/IPJ9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/StandardMode.jpg" alt="StandardMode.jpg"></a></p><p>可以看到输出的日志中，每次启动的 MainActivity 的编号都不一样，意味着每次都有新的 MainActivity 被放入栈中。</p><h3 id="singleTop-栈顶模式"><a href="#singleTop-栈顶模式" class="headerlink" title="singleTop 栈顶模式"></a>singleTop 栈顶模式</h3><p>如果在任务的栈顶正好存在该 Activity 的实例， 就重用该实例，否者就会创建新的实例并放入栈顶（即使栈中已经存在该 Activity 实例，只要不在栈顶，都会创建实例）。</p><blockquote><p>singleTop模式分3种情况:</p><p>当前栈中已有该 Activity 的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将 Intent 对象传入，回调 onNewIntent 方法</p><p>当前栈中已有该 Activity 的实例但是该实例不在栈顶时，其行为和 standard 启动模式一样，依然会创建一个新的实例</p><p>当前栈中不存在该 Activity 的实例时，其行为同 standard 启动模式</p></blockquote><p><strong>实验：</strong></p><p>修改 Manifest：</p><pre><code class="xml">&lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;singleTop&quot;&gt;</code></pre><p>重复之前的点击按钮，启动当前 Activity</p><p><a href="https://up.media.everdo.cn/image/IIej" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/SingleTop.jpg" alt="SingleTop.jpg"></a></p><p>这次并不会有 Activity 切换的动画，并且日志不再输出。</p><p>进一步试验，我们创建了 SecondActivity，在 SecondActivity 添加按钮，事件为打开 MainActivity。</p><p><a href="https://up.media.everdo.cn/image/Ih1O" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/SingleTop.gif" alt="SingleTop.gif"></a></p><p>可以看到，因为在启动 SecondActivity 后，处于栈顶端的就不是 MainActivity 了，因此当点击 SecondActivity 的按钮启动 MainActivity 的时候，就又被 onCreat 了一个新的 Activity。</p><h3 id="singleTask-单任务模式"><a href="#singleTask-单任务模式" class="headerlink" title="singleTask 单任务模式"></a>singleTask 单任务模式</h3><p>如果在栈中已经有该 Activity 的实例，就重用该实例。重用时，会让该实例回到栈顶，因此在<strong>它上面的实例将会被移除栈</strong>。如果栈中不存在该实例，将会创建新的实例放入栈中。</p><p><strong>实验：</strong></p><p>为 MainActivity 添加 onRestart 重写方法，打印日志。再为 SecondActivity 添加 onDestory 重写方法，打印被销毁日志，</p><p>在没有改变 Manifest 之前，还是和以前一样，只有 onCreat 信息被打印。</p><p>而在改变 MainActivity 为 singleTask 后，可以看到点击 SecondActivity 的按钮启动 MainActivity 时，因为之前有 MainActivity 在栈中，因此 SecondActivity 被挤出栈了。</p><p><a href="https://up.media.everdo.cn/image/Ina6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/SingleTask.jpg" alt="SingleTask.jpg"></a></p><h3 id="singleInstance-模式"><a href="#singleInstance-模式" class="headerlink" title="singleInstance 模式"></a>singleInstance 模式</h3><p><strong>！！不同于前面的所有模式，但凡使用 singleInstance 模式的 Activity 在实例化的时候，安卓都会为其独立创建一个全新的栈。</strong></p><p>在一个新栈中创建 Activity 实例，并让多个应用共享栈中的唯一这个 Activity 实例。任何应用再激活该 Activity 时，都会重用该栈中的实例，其效果相当于多个应用程序共享一个Activity。</p><p>一旦此模式的 Activity 的实例存在于某个栈中，任何应用再激活改 Activity 时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。</p><p><strong>实验：</strong></p><p>我们创建 MainActivity SecondActivity ThirdActivity，然后将 SecondActivity 设置为 singleInstanse 模式。</p><pre><code class="xml">&lt;activity android:name=&quot;.ThirdActivity&quot; android:label=&quot;ThirdActivity&quot; /&gt;&lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;SecondActivity&quot; android:launchMode=&quot;singleInstance&quot;/&gt;&lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;MainActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>最后设置在每个 APP 启动后，都使用 log 输出对应的 TaskID</p><pre><code class="java">Log.d(TAG, &quot;TaskID: &quot;+getTaskId());</code></pre><p>运行 APP 并点击按钮切换的效果如下图：</p><p><a href="https://up.media.everdo.cn/image/IBAn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/SingleInstance.jpg" alt="SingleInstance.jpg"></a></p><p>可以看到，MainActivity 和 ThirdActivity 因为是默认启动模式，所以使用同一个栈。而 SecondActivity 使用了一个新的栈。</p><p>这里用一个动图完整呈现过程，在依次开启三个 Activity 后，点击返回键直到 APP 退出。</p><p><a href="https://up.media.everdo.cn/image/IRES" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/SingleInstance.gif" alt="SingleInstance.gif"></a></p><p>可以看到，出栈顺序是先 <strong>ThirdActivity –&gt; MainActivity –&gt; SecondActivity</strong></p><p>也就是说，主栈先全部出栈了，singleInstance 才进行出栈。</p><h2 id="补充：extends-和-implements"><a href="#补充：extends-和-implements" class="headerlink" title="补充：extends 和 implements"></a>补充：extends 和 implements</h2><blockquote><p>补充： implements 与 Extends 的不同在于，extends 可以实现父类，也可以调用父类初始化 this.parent()。而且会覆盖父类定义的变量或者函数。implements 实现父类，子类不可以覆盖父类的方法或者变量。即使子类定义与父类相同的变量或者函数，也会被父类取代掉。</p><p>这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。</p><p>若同时用到 extends 和 implements 的时候，extends 必须放在 implements 关键字之前。如： class A extends B implements C.</p></blockquote><h2 id="完善-Demo"><a href="#完善-Demo" class="headerlink" title="完善 Demo"></a>完善 Demo</h2><p>这里完善之前的登录界面 DEMO，用新学的 Activity 相关知识增加注册页面。此 demo 之前的部分参考我前面的文章。</p><p>先创建一个新的 RegActivity，修改其对应的布局文件。</p><p><a href="https://up.media.everdo.cn/image/IjZQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/e65a1f8ed51f9b9cdbbe96fe0d3a5992.jpg" alt="e65a1f8ed51f9b9cdbbe96fe0d3a5992.jpg"></a></p><h3 id="难点-使用另一个-Style"><a href="#难点-使用另一个-Style" class="headerlink" title="难点 使用另一个 Style"></a>难点 使用另一个 Style</h3><p>因为设计注册界面时，希望能够保留顶栏 ActionBar，因此与主界面在主题上需要做分离：(这里将首页的沉浸式布局独立出来)</p><p>Manifest 文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.emptinessboy.logindemo&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity            android:name=&quot;.Register&quot;            android:label=&quot;用户注册&quot;/&gt;        &lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot;@style/FullPageTheme&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>重写两个独立的 Style，AppTheme 为带 ActionBar 的，FullPageTheme 为不带 ActionBar 的。</p><pre><code class="xml">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;    &lt;!-- 有ActionBar的主题--&gt;    &lt;!-- Customize your theme here. --&gt;    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimaryNormal&lt;/item&gt;    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDarkNormal&lt;/item&gt;    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccentNormal&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;FullPageTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;    &lt;!-- Customize your theme here. --&gt;    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;    &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;    &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt;</code></pre><p>完成后效果：</p><p><a href="https://up.media.everdo.cn/image/I2RJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/1.jpg" alt="1.jpg"></a></p><h3 id="难点-返回时自动关闭弹窗"><a href="#难点-返回时自动关闭弹窗" class="headerlink" title="难点 返回时自动关闭弹窗"></a>难点 返回时自动关闭弹窗</h3><p>接下来在 MainActivity 新建对象，实例化 customDialog 和 PopupWindow：</p><pre><code class="java">public class regdiaLog{    customDialog dialog;    PopupWindow regWindow;    int regCode;}</code></pre><p>之所以实例化的原因是为了在后面 Activity 返回的时候，自动关闭这些弹窗。关闭这两个弹窗的方法，这里采用了重写 onPause() 方法：</p><pre><code class="java">@Overrideprotected void onPause() {    super.onPause();    regdialog.dialog.dismiss();    regdialog.regWindow.dismiss();}</code></pre><p>运行效果（进入下个 Activity 之前，弹窗已经自动关闭）：</p><p><a href="https://up.media.everdo.cn/image/IDJl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/7598843e1898a6be52f51c069977c591.gif" alt="7598843e1898a6be52f51c069977c591.gif"></a></p><p>接下来，继续完善点击右上角注册按钮后的代码：</p><pre><code class="java">//注册按钮Button buttonReg = findViewById(R.id.buttonReg);buttonReg.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        View regView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popup_content,null,false);        regdialog.regWindow = new PopupWindow(regView, LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT,true);        regdialog.regWindow.setTouchable(true);        regdialog.regWindow.setAnimationStyle(R.style.pop_anim);        regdialog.regWindow.showAtLocation(v, Gravity.BOTTOM,0, 0);        //绑定popupWindow的视图对象        Button buttonUseEmail = regView.findViewById(R.id.buttonUseEmail);        regdialog.dialog  = new customDialog(MainActivity.this, new tosConfirm());        buttonUseEmail.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //调用customDialog                regdialog.regCode=1;//注册方式1                regdialog.dialog.show();            }        });        Button buttonUseName = regView.findViewById(R.id.buttonUseName);        buttonUseName.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //调用customDialog                regdialog.regCode=2;//注册方式2                regdialog.dialog.show();            }        });    }});</code></pre><p>重点：regdialog.dialog.show(); 之后，当用户点击同意用户协议后，需要跳转到 Register 类：</p><p>这里使用 Intent 跳转，并携带整数（传递用户的注册方式，邮箱或用户名）</p><pre><code class="java">public class tosConfirm implements customDialog.onCustomDialogListener{    @Override    public void buttonConfirmTosClicked(boolean isRead) {        if(isRead){            Intent reg = new Intent(MainActivity.this,Register.class);            reg.putExtra(&quot;mode&quot;,regdialog.regCode); //传递注册方式            startActivity(reg);            //Toast.makeText(MainActivity.this,&quot;注册还没开放哦！&quot;,Toast.LENGTH_SHORT).show();        }        else{            Toast.makeText(MainActivity.this,&quot;需要先同意协议才能注册哦！&quot;,Toast.LENGTH_SHORT).show();        }    }}</code></pre><p>Registart.java 里面需要对注册进行处理，这里预先定义了存放用户名密码的类 USER_POOL.AddUser(u,p) 这里直接调用；此外，这之前还额外定义了 popUpWndow 的样式：</p><pre><code class="java">Button reg = findViewById(R.id.buttonReg);reg.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        EditText editTextEmail = findViewById(R.id.editTextEmail);        EditText editTextPassword = findViewById(R.id.editTextPassword);        try {            String u = editTextEmail.getText().toString();            String p = editTextPassword.getText().toString();            if (u.length()&lt;3||p.length()&lt;6){                View regView = LayoutInflater.from(Register.this).inflate(R.layout.popup_regfail,null,false);                TextView err = regView.findViewById(R.id.textViewReg);                //透过 popUpWindow 的样式文件进行查找 ID                err.setText(&quot;注册失败,用户名或密码太短&quot;);                final PopupWindow regResult = new PopupWindow(regView, LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT,true);                regResult.setTouchable(true);                regResult.setAnimationStyle(R.style.pop_anim);                regResult.showAtLocation(v, Gravity.BOTTOM,0, 0);            }else{                USER_POOL.AddUser(u,p); //新增用户名密码                View regView = LayoutInflater.from(Register.this).inflate(R.layout.popup_regsuccess,null,false);                final PopupWindow regResult = new PopupWindow(regView, LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT,true);                regResult.setTouchable(true);                regResult.setAnimationStyle(R.style.pop_anim);                regResult.showAtLocation(v, Gravity.BOTTOM,0, 0);                //倒计时函数                CountDownTimer timer = new CountDownTimer(2000, 10) {                    @Override                    public void onTick(long millisUntilFinished) {                    }                    @Override                    public void onFinish() {                        finish();   //自动回到登录界面                    }                };                timer.start();            }        } catch (Exception e) {            //此处省略                }            }        });    }</code></pre><p>简易的通过字符串数组存放密码的用户类，临时存放用户名密码（测试用途，数据不能持久化，正常使用应该用数据库，或者将请求发送到服务器）</p><pre><code class="java">public final class UserPool {    private static final String[][] UserPass = new String[100][2];    private int index = -1;    UserPool(){        AddUser(&quot;hxf&quot;,&quot;123456&quot;);    }    void AddUser(String u,String p){    //增加用户函数        index++;        UserPass[index][0]=u;        UserPass[index][1]=p;    }    boolean Login(String u,String p){ //登录函数        for(int i=0;i&lt;=index;i++){            if( u.equals(UserPass[i][0]) &amp;&amp; p.equals(UserPass[i][1]) ){                return true;            }        }        return false;    }}</code></pre><h3 id="难点-通过非当前-View-查找-id"><a href="#难点-通过非当前-View-查找-id" class="headerlink" title="难点 通过非当前 View 查找 id"></a>难点 通过非当前 View 查找 id</h3><p>透过 popUpWindow 的样式文件进行查找 ID</p><p>此举主要是动态修改（通过外挂布局定义的 popUpWindow）注册成功或失败弹出的提示文字而不需要重写创建布局文件。</p><pre><code class="java">View regView = LayoutInflater.from(Register.this).inflate(R.layout.popup_regfail,null,false);TextView err = regView.findViewById(R.id.textViewReg);//透过 popUpWindow 的样式文件进行查找 IDerr.setText(&quot;注册失败,用户名或密码太短&quot;);</code></pre><p>当然，基础的布局还是要定义的</p><p><a href="https://up.media.everdo.cn/image/IFWy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/e8540353413f94020ef3f8a27f717747.jpg" alt="e8540353413f94020ef3f8a27f717747.jpg"></a></p><p>这一步实现效果：</p><p><a href="https://up.media.everdo.cn/image/I3Sd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/1068a93b8d1db89f0c135d09886fccc2.jpg" alt="1068a93b8d1db89f0c135d09886fccc2.jpg"></a></p><h3 id="难点-倒计时关闭-Activity"><a href="#难点-倒计时关闭-Activity" class="headerlink" title="难点 倒计时关闭 Activity"></a>难点 倒计时关闭 Activity</h3><p>此举主要是实现注册成功后自动返回主界面以增强用户体验，注册失败则留在原地不动。</p><pre><code class="java">//倒计时函数CountDownTimer timer = new CountDownTimer(2000, 10) {    @Override    public void onTick(long millisUntilFinished) {    }    @Override    public void onFinish() {        finish();   //自动回到登录界面(倒计时结束执行的代码)    }};timer.start();</code></pre><p>实现效果：</p><p><a href="https://up.media.everdo.cn/image/IVe0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/db9d73168a853f2ffd38fa82025f3aff.gif" alt="db9d73168a853f2ffd38fa82025f3aff.gif"></a></p><h3 id="难点-自动关闭软键盘"><a href="#难点-自动关闭软键盘" class="headerlink" title="难点 自动关闭软键盘"></a>难点 自动关闭软键盘</h3><p>这里我搬运了网上 dalao 的代码，自己水平不够，暂时先不自己造轮子了：</p><pre><code class="java">package com.emptinessboy.logindemo;import android.app.Activity;import android.content.Context;import android.os.IBinder;import android.view.MotionEvent;import android.view.View;import android.view.inputmethod.InputMethodManager;import android.widget.EditText;public class HideKeyBroadUtils {    private HideKeyBroadUtils(){    }    /**     * 隐藏软键盘     * @param activity     * @param ev     */    public static void hide(Activity activity, MotionEvent ev){        if (ev.getAction() == MotionEvent.ACTION_DOWN) {            View view = activity.getCurrentFocus();            if (isHideInput(view, ev)) {                HideSoftInput(activity,view.getWindowToken());            }        }    }    // 判定是否需要隐藏    private static boolean isHideInput(View v, MotionEvent ev) {        if (v != null &amp;&amp; (v instanceof EditText)) {            int[] l = { 0, 0 };            v.getLocationInWindow(l);            int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left                    + v.getWidth();            if (ev.getX() &gt; left &amp;&amp; ev.getX() &lt; right &amp;&amp; ev.getY() &gt; top                    &amp;&amp; ev.getY() &lt; bottom) {                return false;            } else {                return true;            }        }        return false;    }    // 隐藏软键盘    private static void HideSoftInput(Activity activity, IBinder token) {        if (token != null) {            InputMethodManager manager = (InputMethodManager)                    activity.getSystemService(Context.INPUT_METHOD_SERVICE);            manager.hideSoftInputFromWindow(token,                    InputMethodManager.HIDE_NOT_ALWAYS);        }    }}</code></pre><p>使用这个类的方法很简单：</p><pre><code class="java">只需重写 activity 里的 dispatchTouchEvent 方法，然后调用如下@Overridepublic boolean dispatchTouchEvent(MotionEvent ev){        HideKeyBroadUtils.hide(this,ev);        return super.dispatchTouchEvent(ev);}</code></pre><p>实现效果：</p><p><a href="https://up.media.everdo.cn/image/IYMD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/20/b3f81e805d8d2ed98cd95b625b21510b.gif" alt="b3f81e805d8d2ed98cd95b625b21510b.gif"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发 Activity的详解（上）</title>
      <link href="/2020/04/Android%E5%BC%80%E5%8F%91-Activity%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2020/04/Android%E5%BC%80%E5%8F%91-Activity%E7%9A%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="Activity-的传值"><a href="#Activity-的传值" class="headerlink" title="Activity 的传值"></a>Activity 的传值</h2><h3 id="方法一：直接把数据添加到-Intent-对象"><a href="#方法一：直接把数据添加到-Intent-对象" class="headerlink" title="方法一：直接把数据添加到 Intent 对象"></a>方法一：直接把数据添加到 Intent 对象</h3><p>先将数据添加到 Intent 对象，第二个界面再把数据从 Intent 中取出来。</p><p>1.MainActivity 启动 SecondActivity，传递 extra_data：</p><a id="more"></a><pre><code class="java">String data=&quot;Hi, SecondActivity&quot;;Intent intent=new Intent(MainActivity.this,SecondActivity.class);//向intent对象添加数据intent.putExtra(&quot;extra_data &quot;, data );startActivity(intent);</code></pre><blockquote><p><code>putExtra(&quot;A&quot;,B)</code> 中，AB为键值对，第一个参数为键名，第二个参数为键对应的值。</p></blockquote><p>2.在 SecondActivity 接收 extra_data：</p><pre><code class="java">//获取Intent对象Intent intent=getIntent();//获取传递过来的String类型的数据String data=intent.getStringExtra(&quot;extra_data &quot;);</code></pre><blockquote><p><code>getStringExtra(&quot;A&quot;)</code> 中，参数 A 为上一个 Activity 传递的键名。</p></blockquote><h4 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h4><p>新建 App，在主界面添加一个按钮，随后设置如下点击事件：</p><pre><code class="java">//MainActivity部分代码Button buttonGoTransfer = findViewById(R.id.buttonGoTransfer);buttonGoTransfer.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        String data=&quot;Hi,I am EmptinessBoy!&quot;;        Intent intent = new Intent(MainActivity.this,SecondActivity.class);        intent.putExtra(&quot;hello&quot;,data);        startActivity(intent);    }});</code></pre><p>在第二个页面获取 Intent</p><pre><code class="java">protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_second);    Intent intent = getIntent();    String hello = intent.getStringExtra(&quot;hello&quot;);    Toast.makeText(SecondActivity.this,hello,Toast.LENGTH_SHORT).show();}</code></pre><p>运行效果：</p><p>启动 Activity 并传递参数：</p><p><a href="https://up.media.everdo.cn/image/PSUk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/Activity.jpg" alt="Activity.jpg"></a></p><p>SecondActivity 接收到参数并使用 Toast 显示：</p><p><a href="https://up.media.everdo.cn/image/PC9Z" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/SecondActivity.jpg" alt="SecondActivity.jpg"></a></p><h3 id="方法二：把数据添加到-Bundle（大篮子）对象"><a href="#方法二：把数据添加到-Bundle（大篮子）对象" class="headerlink" title="方法二：把数据添加到 Bundle（大篮子）对象"></a>方法二：把数据添加到 Bundle（大篮子）对象</h3><p>由于第一种方法，每次传递数据都需要存入取出，在多个 Activity 中连续传递时会显得很麻烦。如图：</p><p><a href="https://up.media.everdo.cn/image/PtBB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/a535232df7aada6dd334099c8a797beb.jpg" alt="a535232df7aada6dd334099c8a797beb.jpg"></a></p><p>因此使用 Bundle 可以很好的解决这个问题</p><p>Bundle 类用作携带数据，它类似于 Map，用于存放 key-value 名值对形式的值</p><p>1.MainActivity 向 SecondActivity 传递 bubdle 对象：</p><pre><code class="java">//实例化bundle对象Bundle bundle = new Bundle();//向bundle对象添加数据bundle.putString(&quot;name&quot;, &quot;张三&quot; );bundle.putInt(&quot;age&quot;, 20);Intent intent = new Intent(MainActivity.this,SecondActivity.class);//向intent对象bundleintent.putExtras(bundle);startActivity(intent);</code></pre><p>2.在 SecondActivity 接收 bubdle 对象：</p><pre><code class="java">//获取bundle对象Bundle bundle = getIntent().getExtras();//通过key为“name”来获取value即 nameString.String name=bundle.getString(&quot;name&quot;);int age=bundle.getInt(&quot;age&quot;);</code></pre><h4 id="实验：-1"><a href="#实验：-1" class="headerlink" title="实验："></a>实验：</h4><p>修改上一个示例的按钮点击事件，使用 bundle 来传递多个数据：</p><pre><code class="java">buttonGoTransfer.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Bundle bundle = new Bundle();        bundle.putString(&quot;name&quot;,&quot;Emptinessboy&quot;);        bundle.putInt(&quot;age&quot;,19);        Intent intent = new Intent(MainActivity.this,SecondActivity.class);        intent.putExtras(bundle);        startActivity(intent);    }});</code></pre><p>SecondActivity 修改接收参数的方法并使用 Toast 显示：</p><pre><code class="java">Intent intent = getIntent();Bundle bundle = intent.getExtras();String name = bundle.getString(&quot;name&quot;);int age = bundle.getInt(&quot;age&quot;);Toast.makeText(SecondActivity.this,&quot;姓名：&quot;+name+&quot; 年龄：&quot;+age,Toast.LENGTH_SHORT);</code></pre><p>运行效果（bundle已经被正常传递）：</p><p><a href="https://up.media.everdo.cn/image/Pwxt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/TransferSuccess.jpg" alt="TransferSuccess.jpg"></a></p><h2 id="Activity-接收返回值"><a href="#Activity-接收返回值" class="headerlink" title="Activity 接收返回值"></a>Activity 接收返回值</h2><h3 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a><strong>大致流程：</strong></h3><ol><li>MainActivity 通过调用 startActivityForResult() 跳转到 OtherActivity。</li><li>OtherActivity 在自己关闭之前，通过 setResult() 方法返回数据给 MainActivity。</li><li>MainActivity 通过复写 onActivityResult() 方法来取得回传值。</li></ol><pre><code class="java">首先在 MainActivity 中调用startActivityForResult(Intent intent, int requestCode);</code></pre><pre><code class="java">然后在 SecondActivity 返回setResult(int resultCode, Intent data);</code></pre><pre><code class="java">最后在 MainActivity 中调用接口来获取数值onActivityResult(int requestCode, int resultCode, Intent data);</code></pre><blockquote><p>1、调用 startActivityForResult 方法可以开启一个获取返回值的 activity，在第一个 activity 中重写 onActivityResult 方法来接收返回的值。</p><p>2、请求码：请当同一个 activity 多次使用 startActivityForResult 方法获取返回值后，通过请求码 requestCode 来区分是哪次请求。</p><p>3、结果码：当返回多个结果时，用来区分结果。</p></blockquote><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>MainActivity：</p><pre><code class="java">// 返回的结果码public final static int REQUEST_CODE = 1; //创建intent对象Intent intent=new Intent(this,OtherActivity.class);//启动OtherActivity，并发送请求码startActivityForResult(intent,REQUEST_CODE);</code></pre><p>SecondActivity：</p><pre><code class="java">EditText editText=findViewById(R.id.editText);//数据是使用Intent返回Intent intent = new Intent();//把返回数据存入Intentintent.putExtra(&quot;result&quot;, editText.getText().toString());//设置返回数据setResult(0,intent);//关闭当前窗口finish();</code></pre><p>MainActivity 实现接口：</p><pre><code class="java">protected void onActivityResult(int requestCode, int resultCode, Intent data) {    ……    switch (requestCode){        case REQUEST_CODE:            textView.setText(data.getStringExtra(&quot;result&quot;);break;        default:            result=&quot;未获取到数据。&quot;;    }}</code></pre><h4 id="实验：-2"><a href="#实验：-2" class="headerlink" title="实验："></a>实验：</h4><p>简单设计 MainActivity 的布局：</p><p><a href="https://up.media.everdo.cn/image/PZJI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/MainActivity.jpg" alt="MainActivity.jpg"></a></p><p>编写代码：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    public final static int REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button initSecAct = findViewById(R.id.buttonInitSecAct);        initSecAct.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //发起需要结果的请求                Intent intent = new Intent(MainActivity.this,SecondActivity.class);                startActivityForResult(intent,REQUEST_CODE);            }        });    }}</code></pre><p>简单设计 SecondActivity 的布局：</p><p><a href="https://up.media.everdo.cn/image/P5dX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/SecActivity.jpg" alt="SecActivity.jpg"></a></p><p>编写代码：</p><pre><code class="java">Button buttonSubAndBack = findViewById(R.id.buttonSubAndBack);buttonSubAndBack.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        //获取输入文字        EditText editTextTextPersonName = findViewById(R.id.editTextTextPersonName);        String inputValue = editTextTextPersonName.getText().toString();        //创建Intent        Intent intent = new Intent();        intent.putExtra(&quot;inputValue&quot;,inputValue);        //返回intent        setResult(1,intent);        //返回上一级        finish();    }});</code></pre><p>返回 MainActivity 重写 onActivityResult()：</p><p><a href="https://up.media.everdo.cn/image/PG1i" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/faf223ccc7575a190ac944ed61dc8b90.jpg" alt="faf223ccc7575a190ac944ed61dc8b90.jpg"></a></p><p>使用 IED 进行自动生成</p><p><a href="https://up.media.everdo.cn/image/PKa4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/1.jpg" alt="1.jpg"></a></p><p>补全代码：</p><pre><code class="java">protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {    super.onActivityResult(requestCode, resultCode, data);    TextView textViewHello = findViewById(R.id.textViewHello);    switch (resultCode){        case 1:            textViewHello.setText(data.getStringExtra(&quot;inputValue&quot;));            break;        default:            textViewHello.setText(&quot;返回码异常&quot;);            break;    }}</code></pre><p>最后运行效果：</p><p><a href="https://up.media.everdo.cn/image/POCx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/d0fc250f47624c10691abda9b78e1392.gif" alt="d0fc250f47624c10691abda9b78e1392.gif"></a></p><blockquote><p>一般情况下不论有没有操作 SecondActivity 里的按钮，只要从这里返回了 MainActivity，接口都会返回相同的 requestCode。</p></blockquote><h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><p>Task 就是一个存放 Activity 栈 (A task is a stack of activities.) ，这个栈里面存放了很多 Activity ，它遵循着后进先出的原则。栈有两个动作：进栈（把对象压入到栈当中）和出栈（把栈中的第一个对象从栈里面拿出来）。</p><p>当我们将 Activity 创建好，放入栈中，先放的位于下方，后进入的位于上方。（顺序：先进后出）</p><h3 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h3><p>Activity在进栈与出栈的过程中，一般意义上有四种状态：</p><ol><li>【运行】当 Activity 位于栈顶时，此时正好处于屏幕最前方，此时处于运行状态；（最不会被系统回收）</li><li>【暂停】当 Activity 失去了焦点但仍然部分可见（如栈顶的 Activity 是透明的或者栈顶 Activity 并不是铺满整个手机屏幕），此时处于暂停状态；（系统也不会轻易回收这样的活动，除非是内存极低的情况）</li><li>【停止】当 Activity 被其他 Activity 完全遮挡，此时此 Activity 对用户不可见，此时处于停止状态；（内存中保留Activity对象，当内存较低时系统会回收这样的活动）</li><li>【非活动】当 Activity 由于人为或系统原因（如低内存等）被销毁，此时处于销毁状态。</li></ol><h3 id="七个回调方法"><a href="#七个回调方法" class="headerlink" title="七个回调方法"></a>七个回调方法</h3><p>在每个不同的状态阶段，Adnroid 系统对 Activity 内相应的方法进行了回调。因此，我们在程序中写 Activity 时，一般都是继承 Activity 类并重写相应的回调方法。</p><ol><li><strong>onCreate()</strong> 当Activity第一次被创建时调用，完成活动的初始化操作。</li><li><strong>onStart()</strong> 当用户可以看到这个Activity时调用。</li><li><strong>onResume()</strong> 当获得了用户的焦点时,就是用户点击了屏幕。</li><li><strong>onPause()</strong> 当系统准备启动或回复另一个活动时调用。</li><li><strong>onStop()</strong> 当活动完全不可见时调用，当新启动的活动是对话框式的，还处于可见时，该方法不会被调用。</li><li><strong>onDestroy()</strong> 活动被销毁时调用。</li><li><strong>onRestart()</strong> 当活动由停止状态变为运行状态时调用。</li></ol><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><a href="https://up.media.everdo.cn/image/P83M" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/Activity.jpg" alt="Activity.jpg"></a></p><h2 id="三种生命周期"><a href="#三种生命周期" class="headerlink" title="三种生命周期"></a>三种生命周期</h2><p><strong>1.完整生命周期：</strong> 活动在 onCreate() 方法和 onDestroy() 方法之间所经历的，就是完整生命周期。一般情况下，一个活动会在onCreate()方法中完成各种初始化， onDestroy()方法中完成释放资源的操作。</p><p><strong>2.前台生命周期：</strong> 活动在 onResume() 方法和 onPause() 方法之间所经历的就是前台生命周期。在前台生命周期内，活动总是处于运行状态，此时的活动可以与用户进行交互。</p><p><strong>3.可视生命周期：</strong> 活动在 onStart() 方法与 onStop() 方法之间所经历的，就是可视生命周期。在可视生命周期内，活动对于用户是可见的，但可能无法和用户进行交互。</p><p><a href="https://up.media.everdo.cn/image/PaEY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/Activityd7df6b607bd46a0b.jpg" alt="Activityd7df6b607bd46a0b.jpg"></a></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>重写生命周期的方法，并打印输出日志</p><p><strong>完整生命周期实验：</strong></p><blockquote><p>启动 Activity 后 onCreate() –&gt; onStart() –&gt; onResume()<br>按 Back 键 –&gt; onPause() –&gt; onStop() –&gt; onDestroy()</p></blockquote><p><a href="https://up.media.everdo.cn/image/PgUa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/4aa5dbc22c5e50176385722a1bc62063.jpg" alt="4aa5dbc22c5e50176385722a1bc62063.jpg"></a></p><p>这里重写了 HelloWorld程序 完整生命周期的所有方法</p><p>运行后，程序启动时打印了前三条日志，按下返回键后打印了后三条日志：</p><p><a href="https://up.media.everdo.cn/image/PuBs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/f7f1b1767ea717942071267daa914add.jpg" alt="f7f1b1767ea717942071267daa914add.jpg"></a></p><p><strong>前台生命周期实验：</strong></p><p>新建一个 TestActivity，并在 MainActivity 中设置按钮点击跳转。</p><p>在 AndroidManifest.xml 中，将第二个 Activity 的样式设为 dialog 对话框，来实现半遮挡效果：</p><pre><code class="xml">&lt;activity    android:name=&quot;.TestActivity&quot;    android:theme=&quot;@style/Theme.AppCompat.Dialog&quot;    android:label=&quot;TestActivity&quot;/&gt;</code></pre><p>运行程序测试：</p><p><a href="https://up.media.everdo.cn/image/I4W3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/2e5e7200f2bbd9af9aa3f8e992fce67e.gif" alt="2e5e7200f2bbd9af9aa3f8e992fce67e.gif"></a></p><p>可以看到，当点击按钮后，MainActivity 被遮挡时，输出 onPause 的日志，按下返回键返回 MainActivity 时，输出 onResume 日志。</p><p><strong>可视生命周期实验：</strong></p><p>不改变示例程序，我们在程序运行时呼入电话：</p><p><a href="https://up.media.everdo.cn/image/IHCG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/19/1.gif" alt="1.gif"></a></p><p>可以看到：</p><pre><code>2020-04-19 01:47:25.803 30014-30014/com.emptinessboy.testlifecycle D/MainActivity: onPause: 被暂停2020-04-19 01:47:27.089 30014-30014/com.emptinessboy.testlifecycle D/MainActivity: onStop: 被停止</code></pre><p>挂掉电话后则输出了（图略）：</p><pre><code>2020-04-19 01:47:48.733 30014-30014/com.emptinessboy.testlifecycle D/MainActivity: onStart: 正在运行2020-04-19 01:47:48.734 30014-30014/com.emptinessboy.testlifecycle D/MainActivity: onResume: 被重新开始</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发之 Activity与Intent 入门</title>
      <link href="/2020/04/Android%E5%BC%80%E5%8F%91%E4%B9%8B-Activity%E4%B8%8EIntent-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/04/Android%E5%BC%80%E5%8F%91%E4%B9%8B-Activity%E4%B8%8EIntent-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>可以与用户交互的一个单独的屏幕（页面）称为 Activity。</p><p>Activity 用来管理需要显示的各种组件，例如，按钮、输入框、文本框等等。</p><p>一个应用程序一般由多个 Activity 构成，此外 Activity 具有生命周期。</p><h2 id="Activity-概述"><a href="#Activity-概述" class="headerlink" title="Activity 概述"></a>Activity 概述</h2><p>创建 Activity 的内部流程（AndroidStudio 会自动帮我们完成的）：</p><ol><li>创建一个继承 Activity 类或 Activity 派生类的子类</li><li>实现回调方法 onCreadte()，并调用 setContentView(int LayoutResID) 方法，加载布局文件。</li><li>在 AndroidManifest.xml 中声明 Activity</li></ol><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>在 AndroidStudio 选中 MainActivity 使用快捷键 ctrl+H 即可查看这个类的父类层级：</p><p><a href="https://up.media.everdo.cn/image/P99Q" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/17/activity.jpg" alt="activity.jpg"></a></p><p>模板代码：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    }}</code></pre><blockquote><p>现在默认系统会自动将 MainActivity extends AppCompatActivity，如果使用旧版 MainActivity extends Activity 直接继承父类，则会不显示 ToolBar，生成一个非常干净的空白页面。</p></blockquote><h2 id="Intent-与-IntentFilter"><a href="#Intent-与-IntentFilter" class="headerlink" title="Intent 与 IntentFilter"></a>Intent 与 IntentFilter</h2><p>Intent 的中文意思是“意向、意图”。Android 中提供了 Intent 机制来协助应用间的交互和应用程序内部的 activity, service 和 broadcast receiver 之间的交互。即使用 Intent 实现程序的“调用意图”。</p><h3 id="Intent-属性"><a href="#Intent-属性" class="headerlink" title="Intent 属性"></a>Intent 属性</h3><p>Intent 包括如下的属性，用于完成执行的意图：</p><ol><li>action（动作）: 用来表示意图的动作，如：查看，发邮件，打电话</li><li>category（类别）: 用来表示动作的类别。</li><li>data（数据）: 表示与动作要操作的数据。如：查看指定的联系人</li><li>type（数据类型）: 对data类型的描述。</li><li>extras（附件信息）: 附件信息。如：详细资料，一个文件，某事。</li><li>component（目标组件）: 目标组件。</li></ol><h3 id="IntentFilter-属性"><a href="#IntentFilter-属性" class="headerlink" title="IntentFilter 属性"></a>IntentFilter 属性</h3><p>IntentFilter 是 Intert 的过滤器。 Android 操作系统使用过滤器来指定一系列活动、服务和广播接收器处理意图，需要借助于意图所指定的动作、类别、数据模式。</p><p>“过滤”大多情况下不在 java 代码中设置，而是在应用的 manifest 文件中作为 <code>&lt;intent-filter&gt;</code> 元素的方式声明。在 manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素在活动，服务和广播接收器中列出对应的动作，类别和数据类型。</p><p>下面是 menifest 文件 <code>&lt;intent-filter&gt;</code> 部分展示：</p><pre><code class="xml"> &lt;application    &lt;!-- 此处不是重点，省略... --&gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;!-- 定义打开应用后最先执行的方法/组件 --&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;!-- 设置过滤器动作类别，此行表示在程序列表看到此应用图标 --&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;</code></pre><h2 id="Activity-间的跳转"><a href="#Activity-间的跳转" class="headerlink" title="Activity 间的跳转"></a>Activity 间的跳转</h2><p>Intent（意图） 分为 显式Intent 和 隐式Intent。</p><p><strong>显式Intent：</strong></p><p>显式意图经常用于连接应用程序的内部世界。例如，在一个应用中，需要从一个 Activity 跳转到另外一个 Activity。</p><p><strong>隐式Intent：</strong></p><p>隐式意图经常用于激活其他应用程序的组件。例如，启动浏览器打开一个网页，启动拨打电话界面等。</p><h3 id="显式-Intent-跳转-Activity"><a href="#显式-Intent-跳转-Activity" class="headerlink" title="显式 Intent 跳转 Activity"></a>显式 Intent 跳转 Activity</h3><p>实现同一个 APP 内两个 Activity 间互相跳转，最简单的方法是使用显式 Intent。</p><p>通过名称启动目标组件的步骤：</p><ol><li>实例化 Intent 对象。其中一个Intent构造方法：<strong>Intent(Context Context, Class&lt;?&gt; cls)</strong></li><li>调用 <strong>Activity.startActivity(Intent intent)</strong> 方法，启动一个 Activity</li></ol><blockquote><p>Intent构造方法中第一个参数：Context 是当前 Activity 的上下文对象。第二个参数 cls 是要跳转的目标 Activity 的类名。</p></blockquote><p>示例代码：</p><pre><code class="java">// 通过指定类名的显式意图Intent intent=new Intent(MainActivity.this,SecondActivity.class);// 启动目标活动startActivity(intent);</code></pre><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>新建一个 Activity：second activity</p><p><a href="https://up.media.everdo.cn/image/PEUJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/activity.jpg" alt="activity.jpg"></a></p><p>修改一个好记的名字：</p><p><a href="https://up.media.everdo.cn/image/Pf7y" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/activity1.jpg" alt="activity1.jpg"></a></p><pre><code class="xml">在 AndroidManifest.xml 中组件声明处新增 lable，方便后续查看&lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;Second Activity&quot;&gt;&lt;/activity&gt;</code></pre><p>在 MainActivity 添加按钮，并添加点击事件监听：</p><p><a href="https://up.media.everdo.cn/image/Psxd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/7905609c89e96e63287ad2e02071ba29.jpg" alt="7905609c89e96e63287ad2e02071ba29.jpg"></a></p><p>完整按钮以及 Intent 使用的代码：</p><pre><code class="java">Button gotoSecAct = findViewById(R.id.gotoSecAct);gotoSecAct.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Intent intent = new Intent(MainActivity.this,SecondActivity.class);        startActivity(intent);    }});</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/PzXl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/IntentActivity.gif" alt="IntentActivity.gif"></a></p><h3 id="隐式-Intent-启动不确定的目标："><a href="#隐式-Intent-启动不确定的目标：" class="headerlink" title="隐式 Intent 启动不确定的目标："></a>隐式 Intent 启动不确定的目标：</h3><p>当无法确定意图目标，即目标组件名称时，使用隐式 Intent 启动。通常用于启动其他应用的组件。</p><h4 id="A-启动默认浏览器："><a href="#A-启动默认浏览器：" class="headerlink" title="A 启动默认浏览器："></a>A 启动默认浏览器：</h4><pre><code class="java">//准备Intent的data属性数据Uri uri = Uri.parse(&quot;https://coding.emptinessboy.com&quot;);//设置Intent的action属性和data属性Intent intent = new Intent(Intent.ACTION_VIEW, uri);//启动目标意图startActivity(intent);</code></pre><h5 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h5><p>增加打开浏览器的按钮：</p><p><a href="https://up.media.everdo.cn/image/P1H0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/3d9f7d3c347a49dab125758ef45c7a3c.md.jpg" alt="3d9f7d3c347a49dab125758ef45c7a3c.md.jpg"></a></p><p>增加按钮监听事件：</p><pre><code class="java">Button gotoBrowser = findViewById(R.id.gotoBrowser);gotoBrowser.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Uri emptinessboy = Uri.parse(&quot;https://coding.emptinessboy.com/&quot;);        //设置Intent的action属性和data属性        Intent intEmptinessboy = new Intent(Intent.ACTION_VIEW,emptinessboy);        //启动目标意图        startActivity(intEmptinessboy);//启动目标意图    }});</code></pre><p>运行效果（成功打开浏览器）：</p><p><a href="https://up.media.everdo.cn/image/PMdD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/IntentBrowser.gif" alt="IntentBrowser.gif"></a></p><h4 id="B-注册自定义“浏览器”："><a href="#B-注册自定义“浏览器”：" class="headerlink" title="B 注册自定义“浏览器”："></a>B 注册自定义“浏览器”：</h4><p>这个例子将一个自定义应用注册为浏览器，并配置可以接收另一个应用的传入值：</p><p>先新建一个测试 APP（自定义浏览器）</p><p>1.向自定义浏览器的 AndroidManiFest.xml 文件添加过滤器配置</p><pre><code class="xml">&lt;intent-filter&gt;    &lt;!-- 赋予具备查看的功能 --&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    &lt;!-- 赋予默认类别和浏览类别的数值 --&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;    &lt;!-- 传递这两个开头网址，就被过滤器筛选出 --&gt;    &lt;data android:scheme=&quot;http&quot; /&gt;    &lt;data android:scheme=&quot;https&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>2.在 MainAcitivity 中获取网页地址</p><pre><code class="java">//获取Intent对象Intent intent=getIntent();//获取intent对象中data属性的字符串数据String uriStr=intent.getDataString();</code></pre><pre><code class="java">//进行显示TextView t = findViewById(R.id.TextView);/**可能产生空指针异常if(!uriStr.isEmpty()){    t.setText(uriStr);}*/if(uriStr != null){    t.setText(uriStr);}</code></pre><p>运行效果，可以看到单击按钮后，看到了我们创建的“浏览器应用”</p><p><a href="https://up.media.everdo.cn/image/Pv0L" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/133a08fe6b871673d63b926003b04abb.jpg" alt="133a08fe6b871673d63b926003b04abb.jpg"></a></p><p>点击我们创建的“浏览器”后，可以正确显示传入网址：</p><p><a href="https://up.media.everdo.cn/image/Py8c" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/f4812890cb4f1caaa3253a9c847d98a4.jpg" alt="f4812890cb4f1caaa3253a9c847d98a4.jpg"></a></p><h5 id="直接启动自定义“浏览器”："><a href="#直接启动自定义“浏览器”：" class="headerlink" title="直接启动自定义“浏览器”："></a>直接启动自定义“浏览器”：</h5><p>1.在自定义浏览器的AndroidManifest.xml中增加过滤器action属性值。</p><pre><code class="java">&lt;intent-filter&gt;    ……    &lt;action android:name=&quot;com.emptinessboy.testbrower.start&quot; /&gt;    ……&lt;/intent-filter&gt;</code></pre><p>2.通过在测试 APP 调用自定义浏览器设定的 action 动作：“com.emptinessboy.testbrower.start”，直接启动自定义浏览器:</p><pre><code class="java">//准备Intent的data属性数据Uri uri = Uri.parse(&quot;https://coding.emptinessboy.com&quot;);//旧的 Intent intEmptinessboy = new Intent(Intent.ACTION_VIEW,uri;Intent intent = new Intent(&quot;com.emptinessboy.testbrower.start&quot;,uri);startActivity(intent);</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/PX32" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/18/IntentBrowserdefault.gif" alt="IntentBrowserdefault.gif"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS文档整理 02-字体和段落</title>
      <link href="/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-02-%E5%AD%97%E4%BD%93%E5%92%8C%E6%AE%B5%E8%90%BD/"/>
      <url>/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-02-%E5%AD%97%E4%BD%93%E5%92%8C%E6%AE%B5%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>注：字体和段落几乎都支持 inherit 继承属性，下文可能部分省略。</p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><h3 id="字体-font-family"><a href="#字体-font-family" class="headerlink" title="字体 font-family"></a>字体 font-family</h3><p>font-family 属性用于指定文字字体类型，如宋体、黑体、等，即在网页中展示字体不同的形状。<a id="more"></a></p><h4 id="字体名称"><a href="#字体名称" class="headerlink" title="字体名称"></a>字体名称</h4><p>具体的语法格式如下：</p><pre><code class="css">body {font-family: 微软雅黑,宋体;}</code></pre><p>使用name字体名称，按优先顺序排列，以逗号隔开，如果字体名称包含空格，则应使用引号括起</p><h4 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h4><p>具体的语法格式如下：</p><pre><code class="css">body {font-family: sans-serif;}</code></pre><p>在 CSS 中，有两种不同类型的字体系列名称：</p><ul><li>通用字体系列 - 拥有相似外观的字体系统组合（比如 “Serif” 或 “Monospace”）</li><li>特定字体系列 - 具体的字体系列（比如 “Times” 或 “Courier”）</li></ul><p>下面是 5 种通用字体系列：</p><p><strong>Serif 字体：</strong> 这些字体成比例，而且有上下短线。如果字体中的所有字符根据其不同大小有不同的宽度，则成该字符是成比例的。</p><p><strong>Sans-serif 字体：</strong> 这些字体是成比例的，而且没有上下短线。</p><p><strong>Monospace 字体：</strong> Monospace 字体并不是成比例的。它们通常用于模拟打字机打出的文本、老式点阵打印机的输出，甚至更老式的视频显示终端。采用这些字体，每个字符的宽度都必须完全相同，所以小写的 i 和小写的 m 有相同的宽度。这些字体可能有上下短线，也可能没有。如果一个字体的字符宽度完全相同，则归类为 Monospace 字体，而不论是否有上下短线。</p><p><strong>Cursive 字体：</strong> 这些字体试图模仿人的手写体。通常，它们主要由曲线和 Serif 字体中没有的笔划装饰组成。</p><p><strong>Fantasy 字体：</strong> 这些字体无法用任何特征来定义，只有一点是确定的，那就是我们无法很容易地将其规划到任何一种其他的字体系列当中。</p><p>下面是一个具体案例：</p><pre><code class="html">&lt;p style=&quot;font-family: serif;&quot;&gt;I am Emptinessboy !&lt;/p&gt;&lt;p style=&quot;font-family: sans-serif;&quot;&gt;I am Emptinessboy !&lt;/p&gt;</code></pre><p style="font-family:serif">I am Emptinessboy !</p><p style="font-family:sans-serif">I am Emptinessboy !</p><h4 id="混搭"><a href="#混搭" class="headerlink" title="混搭"></a>混搭</h4><p>可以通过混合特定字体名和通用字体系列来解决兼容性问题：</p><pre><code class="html">&lt;p style=&quot;font-family: 黑体,serif;&quot;&gt;I am Emptinessboy !&lt;/p&gt;</code></pre><p style="font-family:黑体,serif">I am Emptinessboy !</p><h3 id="字号-font-size"><a href="#字号-font-size" class="headerlink" title="字号 font-size"></a>字号 font-size</h3><p>在 CSS3 新规定中，通常使用 font-size 设置文字大小，其属性值如下。</p><pre><code>xx-small | x-small | small | medium | large | x-large| xx-large把字体的尺寸设置为不同的尺寸，从 xx-small 到 xx-large。默认值：medium。</code></pre><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>smaller</td><td>把 font-size 设置为比父元素更小的尺寸。</td></tr><tr><td>larger</td><td>把 font-size 设置为比父元素更大的尺寸。</td></tr><tr><td>length</td><td>把 font-size 设置为一个固定的值。</td></tr><tr><td>%</td><td>把 font-size 设置为基于父元素的一个百分比值。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承字体尺寸。</td></tr></tbody></table><p>font-size 值可以是绝对或相对值。绝对值大小在确定了输出的物理尺寸时很有用，但不允许用户在所有浏览器中改变文本大小（不利于可用性）。相对大小：相对于周围的元素来设置大小，允许用户在浏览器改变文本大小。</p><pre><code class="html">&lt;div style=&quot;font-size:13pt&quot;&gt;    上级标记大小    &lt;p style=&quot;font-size:inherit&quot;&gt;inherit 继承&lt;/p&gt;    &lt;p style=&quot;font-size:x-small&quot;&gt;x-small&lt;/p&gt;    &lt;p style=&quot;font-size:x-large&quot;&gt;x-large&lt;/p&gt;    &lt;p style=&quot;font-size:smaller&quot;&gt;smaller&lt;/p&gt;    &lt;p style=&quot;font-size:larger&quot;&gt;larger&lt;/p&gt;    &lt;p style=&quot;font-size:50%&quot;&gt;50%&lt;/p&gt;    &lt;p style=&quot;font-size:16pt&quot;&gt;16pt&lt;/p&gt;&lt;/div&gt;</code></pre><p></p><div style="font-size:13pt">上级标记大小<p style="font-size:inherit">inherit 继承</p><p style="font-size:x-small">x-small</p><p style="font-size:x-large">x-large</p><p style="font-size:smaller">smaller</p><p style="font-size:larger">larger</p><p style="font-size:50%">50%</p><p style="font-size:16pt">16pt</p></div><p>在上面例子中，font-size 字体大小为 50% 时，其比较对象是上一级标签中的13pt。同样还可以使用 inherit 值，直接继承上级标记的字体大小。</p><h4 id="使用-em-来设置字体大小"><a href="#使用-em-来设置字体大小" class="headerlink" title="使用 em 来设置字体大小"></a>使用 em 来设置字体大小</h4><p>许多开发者使用 em 单位代替 pixels。W3C 推荐使用 em 尺寸单位。</p><p>1em 等于当前的字体尺寸。如果一个元素的 font-size 为 16 像素，那么对于该元素，1em 就等于 16 像素。在设置字体大小时，<strong>em 的值会相对于父元素的字体大小改变。</strong></p><p>浏览器中默认的文本大小是 16 像素。因此 1em 的默认尺寸是 16 像素。</p><blockquote><p>可以使用下面这个公式将像素转换为 em：pixels/16=em（注：16 等于父元素的默认字体大小，假设父元素的 font-size 为 20px，那么公式需改为：pixels/20=em）。</p></blockquote><p>所以最推荐的做法是：结合使用百分比和 EM</p><p>在所有浏览器中均有效的方案是为 body 元素（父元素）以百分比设置默认的 font-size 值，例如：</p><pre><code class="css">body {font-size:100%;}h1 {font-size:3.75em;}h2 {font-size:2.5em;}p {font-size:0.875em;}</code></pre><h3 id="字重-font-weight"><a href="#字重-font-weight" class="headerlink" title="字重 font-weight"></a>字重 font-weight</h3><p>格式：</p><pre><code class="css">body {font-weight:normal;}</code></pre><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>100-900</td><td>定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。</td></tr><tr><td>normal</td><td>默认值。定义标准的字符。</td></tr><tr><td>bold</td><td>定义粗体字符。</td></tr><tr><td>bolder</td><td>定义更粗的字符。</td></tr><tr><td>lighter</td><td>定义更细的字符。</td></tr></tbody></table><p>inherit 规定应该从父元素继承字体的粗细。</p><p>下面是具体使用案例：</p><pre><code class="html">&lt;p style=&quot;font-weight:normal&quot;&gt;正常&lt;/p&gt;&lt;p style=&quot;font-weight:lighter&quot;&gt;细体&lt;/p&gt;&lt;p style=&quot;font-weight:bolder&quot;&gt;细体&lt;/p&gt;</code></pre><p style="font-weight:400">正常</p><p style="font-weight:lighter">细体</p><p style="font-weight:bolder">细体</p><h3 id="字体风格-font-style"><a href="#字体风格-font-style" class="headerlink" title="字体风格 font-style"></a>字体风格 font-style</h3><p>font-style通常用来定义字体风格，即字体的显示样式。在CSS3新规定中，语法格式如下：</p><pre><code class="css">body {font-style:normal}</code></pre><p>该属性有三个值：</p><ul><li>normal - 文本正常显示</li><li>italic - 文本斜体显示</li><li>oblique - 文本倾斜显示</li></ul><p>斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。与此不同，倾斜（oblique）文本则是正常竖直文本的一个倾斜版本。</p><pre><code class="html">案例：&lt;p style=&quot;font-style:normal&quot;&gt;正常&lt;/p&gt;&lt;p style=&quot;font-style:italic&quot;&gt;italic 斜体&lt;/p&gt;&lt;p style=&quot;font-style:oblique&quot;&gt;oblique 倾斜&lt;/p&gt;</code></pre><p style="font-style:normal">正常</p><p style="font-style:italic">italic 斜体</p><p style="font-style:oblique">oblique 倾斜</p><h3 id="大小写-font-variant"><a href="#大小写-font-variant" class="headerlink" title="大小写 font-variant"></a>大小写 font-variant</h3><blockquote><p>font-variant 不同于 <a href="https://coding.emptinessboy.com/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-02-%E5%AD%97%E4%BD%93%E5%92%8C%E6%AE%B5%E8%90%BD/#%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2-text-transform">text-transform 点击查看</a></p></blockquote><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>normal</td><td>默认值。浏览器会显示一个标准的字体。</td></tr><tr><td>small-caps</td><td>浏览器会显示小型大写字母的字体。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 font-variant 属性的值。</td></tr></tbody></table><pre><code class="html">案例：&lt;p style=&quot;font-variant: normal&quot;&gt;SETTING normal&lt;/p&gt;&lt;p style=&quot;font-variant: small-caps&quot;&gt;SETTING small-caps&lt;/p&gt;</code></pre><p style="font-variant:normal">SETTING normal</p><p style="font-variant:small-caps">SETTING small-caps</p><p>使用了 small-caps 属性值的段落文本全部变成了大写，只是大写字母的尺寸不同。</p><h3 id="字体复合属性-font"><a href="#字体复合属性-font" class="headerlink" title="字体复合属性 font"></a>字体复合属性 font</h3><p>font 属性可以一次性地使用多个属性的属性值定义文本字体（一句话设置上面一堆属性），其语法格式如下：</p><pre><code class="css">body {font:font-style font-variant font-weight font-size font-family}</code></pre><blockquote><p>注意：font-size 和 font-family 则必须按照固定的顺序出现，如果这两个的顺序不对或缺少一个，那么整条样式规则可能因此会被忽略。</p></blockquote><h3 id="字体颜色-color"><a href="#字体颜色-color" class="headerlink" title="字体颜色 color"></a>字体颜色 color</h3><p>直接使用 color 属性设置 16 进制值改变颜色。此外 CSS3 中新增加的表现形式，分别是HSL()、HSLA() 和 RGBA()：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    p.normal{color:#00ff00}    p.ex{color:rgb(0,0,255)}    p.hs{color:hsl(0,75%,50%)}    p.ha{color:hsla(120,50%,50%,1)}    p.ra{color:rgba(125,10,45,0.5)}&lt;/style&gt;&lt;p class=&quot;normal&quot;&gt;这是一段普通的段落。&lt;/p&gt;&lt;p class=&quot;ex&quot;&gt;该段落定义了 class=&quot;ex&quot;。该段落中的文本是蓝色的。&lt;/p&gt;&lt;p class=&quot;hs&quot;&gt;此处使用了CSS3中的新增加的HSL函数，构建颜色。&lt;/p&gt;&lt;p class=&quot;ha&quot;&gt;此处使用了CSS3中的新增加的HSLA函数，构建颜色。&lt;/p&gt;&lt;p class=&quot;ra&quot;&gt;此处使用了CSS3中的新增加的RGBA函数，构建颜色。&lt;/p&gt;</code></pre><style type="text/css">p.normal{color:#0f0}p.ex{color:#00f}p.hs{color:#df1f1f}p.ha{color:hsla(120,50%,50%,1)}p.ra{color:rgba(125,10,45,.5)}</style><p class="normal">这是一段普通的段落。</p><p class="ex">该段落定义了 class="ex"。该段落中的文本是蓝色的。</p><p class="hs">此处使用了CSS3中的新增加的HSL函数，构建颜色。</p><p class="ha">此处使用了CSS3中的新增加的HSLA函数，构建颜色。</p><p class="ra">此处使用了CSS3中的新增加的RGBA函数，构建颜色。</p><h2 id="文本高级样式"><a href="#文本高级样式" class="headerlink" title="文本高级样式"></a>文本高级样式</h2><h3 id="阴影文本-text-shadow"><a href="#阴影文本-text-shadow" class="headerlink" title="阴影文本 text-shadow"></a>阴影文本 text-shadow</h3><p>text-shadow 属性有4个属性值，最后两个是可选的，第一个属性值表示阴影的水平位移，可取正负值；第二个属性值表示阴影垂直位移，可取正负值；第三个属性值表示阴影模糊半径，不可为负值，该值可选；第4个个属性值表示阴影颜色值，该值可选。语法格式如下：</p><pre><code class="css">text-shadow: length length opacity color;</code></pre><p>下面是示例代码：</p><pre><code class="html">&lt;p style=&quot;text-shadow: .05em .05em .1em purple;font-size: 2em;&quot;&gt;Hello, I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-shadow: .3em .05em .1em purple;font-size: 2em;&quot;&gt;Hello, I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-shadow: .3em .3em .1em purple;font-size: 2em;&quot;&gt;Hello, I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-shadow: .3em .3em .6em purple;font-size: 2em;&quot;&gt;Hello, I am EmptinessBoy !&lt;/p&gt;</code></pre><p style="text-shadow:.05em .05em .1em purple;font-size:2em">Hello, I am EmptinessBoy !</p><p style="text-shadow:.3em .05em .1em purple;font-size:2em">Hello, I am EmptinessBoy !</p><p style="text-shadow:.3em .3em .1em purple;font-size:2em">Hello, I am EmptinessBoy !</p><p style="text-shadow:.3em .3em .6em purple;font-size:2em">Hello, I am EmptinessBoy !</p><p>模糊半径是一个长度值，它支持了模糊效果的范围，但如何计算效果的具体算法并没有指定。在阴影效果的长度值之前或之后，还可以指定一个颜色值。颜色值会被用作阴影效果的基础，如果没有指定颜色，那么将使用文本颜色来替代。</p><h3 id="溢出文本-text-overflow"><a href="#溢出文本-text-overflow" class="headerlink" title="溢出文本 text-overflow"></a>溢出文本 text-overflow</h3><p>text-overflow 属性用来定义当文本溢出时是否显示省略标记，即定义省略文本的显示方式，并不具备其他的样式属性定义。</p><p>要实现溢出时产生省略号的效果还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果。</p><pre><code class="css">基本语法：text-overflow: clip|ellipse;</code></pre><p>下面是使用的具体案例：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;.test_demo_clip{text-overflow:clip; overflow:hidden; white-space:nowrap; width:200px; background:#333;}  .test_demo_ellipsis{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:200px;background:#333;} &lt;/style&gt;&lt;p class=&quot;test_demo_clip&quot;&gt;不显示省略标记，而是简单的裁切条&lt;/p&gt;&lt;p class=&quot;test_demo_ellipsis&quot;&gt;显示省略标记，不是简单的裁切条&lt;/p&gt;</code></pre><style type="text/css">.test_demo_clip{text-overflow:clip;overflow:hidden;white-space:nowrap;width:200px;background:#333}.test_demo_ellipsis{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:200px;background:#333}</style><p class="test_demo_clip">不显示省略标记，而是简单的裁切条</p><p class="test_demo_ellipsis">显示省略标记，不是简单的裁切条</p><h3 id="控制换行-word-wrap"><a href="#控制换行-word-wrap" class="headerlink" title="控制换行 word-wrap"></a>控制换行 word-wrap</h3><p>CSS3 中新增加的 word-wrap 文本样式来控制文本换行。其基本语法如下：</p><pre><code class="css">word-warp: normal|break-world</code></pre><ul><li>normal 只在允许的断字点换行（浏览器保持默认处理）。</li><li>break-world 在长单词或 URL 地址内部进行换行。</li></ul><p>下面是具体案例：</p><pre><code class="html">&lt;p style=&quot;width:11em; border:1px solid #000000;word-wrap:break-word;&quot;&gt;This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will break and wrap to the next line.&lt;/p&gt;&lt;p style=&quot;width:11em; border:1px solid #000000;word-wrap:normal;&quot;&gt;This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will not break and wrap to the next line.&lt;/p&gt;</code></pre><p style="width:11em;border:1px solid #000;word-wrap:break-word">This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will break and wrap to the next line.</p><p style="overflow:visible;width:11em;border:1px solid #000;word-wrap:normal">This paragraph contains a very long word: thisisaveryveryveryveryveryverylongword. The long word will not break and wrap to the next line.</p><h3 id="字体尺寸适配-font-size-adjust（兼容性差）"><a href="#字体尺寸适配-font-size-adjust（兼容性差）" class="headerlink" title="字体尺寸适配 font-size-adjust（兼容性差）"></a>字体尺寸适配 font-size-adjust（兼容性差）</h3><p>实际应用中，只需把 font-size-adjust 属性的值，设置为首选字体的 aspect 值，就可以保证使用备选字体后，文本的显示尺寸不发生变化。</p><pre><code>公式：aspect =（x-height）/（font-size）首选字体的字体尺寸 * （font-size-adjust 值 / 可用字体的 aspect 值）= 可应用到可用字体的字体尺寸</code></pre><p>举例：如果 14px 的 Verdana（aspect 值是 0.58）不可用，但是某个可用的字体的 aspect 值是 0.46，那么替代字体的尺寸将是 14 * (0.58/0.46) = 17.65px。</p><p>下面是一个具体案例：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    /*定义整体样式*/    div{font-size:16px;}    #div1{font-family:&#39;Times New Roman&#39;;}    #div2{font-family:Verdana}&lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;div1&quot;&gt;Hello World !&lt;/div&gt;    &lt;div id=&quot;div2&quot;&gt;Hello World !&lt;/div&gt;&lt;/body&gt;</code></pre><style type="text/css">div{font-size:16px}#div1{font-family:'Times New Roman'}#div2{font-family:Verdana}</style><body><div id="div1">Hello World !</div><div id="div2">Hello World !</div></body><p>西方字体的 aspect 值：</p><table><thead><tr><th>字体类型</th><th>aspect值</th></tr></thead><tbody><tr><td>Fjemish Script</td><td>0.28</td></tr><tr><td>Caflisch Script Web</td><td>0.37</td></tr><tr><td>Bernhard Modern</td><td>0.4</td></tr><tr><td>Gill Sans</td><td>0.46</td></tr><tr><td>Times New Roman</td><td>0.46</td></tr><tr><td>Minion Web</td><td>0.47</td></tr><tr><td>Myriad Web</td><td>0.48</td></tr><tr><td>Georgia</td><td>0.5</td></tr><tr><td>Trebuchet MS</td><td>0.53</td></tr><tr><td>Comic Sans MS</td><td>0.54</td></tr><tr><td>Verdana</td><td>0.58</td></tr></tbody></table><h2 id="段落属性"><a href="#段落属性" class="headerlink" title="段落属性"></a>段落属性</h2><h3 id="单词间隔-word-spacing"><a href="#单词间隔-word-spacing" class="headerlink" title="单词间隔 word-spacing"></a>单词间隔 word-spacing</h3><p>单词之间的间隔如果设置合理，一是会给整个网页布局节省空间，二是可以给人赏心悦目的感觉，提高用户的阅读效率。在 CSS3 中，可以使用 word-spacing 直接定义指定区域或段落中字符之间的间隔。</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>normal</td><td>默认。定义单词间的标准空间。</td></tr><tr><td>length</td><td>定义单词间的固定空间。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 word-spacing 属性的值。</td></tr></tbody></table><p>下面是一个具体案例：</p><pre><code class="html">&lt;p style=&quot;word-spacing:normal&quot;&gt;I am EmptinessBoy&lt;/p&gt;&lt;p style=&quot;word-spacing:25px&quot;&gt;I am EmptinessBoy&lt;/p&gt;&lt;p style=&quot;word-spacing:25px&quot;&gt;吼吼吼 吼吼吼&lt;/p&gt;</code></pre><p style="word-spacing:normal">I am EmptinessBoy</p><p style="word-spacing:25px">I am EmptinessBoy</p><p style="word-spacing:25px">吼吼吼 吼吼吼</p><blockquote><p>注意：word-spacing 属性不能用于设置文字之间的间隔。</p></blockquote><h3 id="字符间隔-letter-spacing"><a href="#字符间隔-letter-spacing" class="headerlink" title="字符间隔 letter-spacing"></a>字符间隔 letter-spacing</h3><p>在CSS3中，可以通过 letter-spacing 来设置字符文本之间的距离，这里允许使用负值，这可让字符之间更加紧凑。其语法格式如下：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>normal</td><td>默认。规定字符间没有额外的空间。</td></tr><tr><td>length</td><td>定义字符间的固定空间（允许使用负值）。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 letter-spacing 属性的值。</td></tr></tbody></table><p>下面是一个具体案例：</p><pre><code class="html">&lt;p style=&quot;letter-spacing: -0.3em&quot;&gt;I am EmptinessBoy&lt;/p&gt;&lt;p style=&quot;letter-spacing: 1.3em&quot;&gt;I am EmptinessBoy&lt;/p&gt;</code></pre><p style="letter-spacing:-.3em">I am EmptinessBoy</p><p style="letter-spacing:1.3em">I am EmptinessBoy</p><h3 id="文字修饰-text-decoration"><a href="#文字修饰-text-decoration" class="headerlink" title="文字修饰 text-decoration"></a>文字修饰 text-decoration</h3><p>在CSS3中，text-decoration属性是文本修饰属性，该属性可以为页面提供多种文本的修饰效果，如下画线、删除线、闪烁等。text-decoration属性语法格式如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。</td></tr><tr><td>underline</td><td>定义文本下的一条线。</td></tr><tr><td>overline</td><td>定义文本上的一条线。</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。</td></tr><tr><td>blink</td><td>定义闪烁的文本。(难兼容)</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 text-decoration 属性的值。</td></tr></tbody></table><p>下面是案例代码：</p><pre><code class="html">&lt;p style=&quot;text-decoration:none&quot;&gt;Hello World!&lt;/p&gt;&lt;p style=&quot;text-decoration:underline&quot;&gt;Hello World!&lt;/p&gt;&lt;p style=&quot;text-decoration:overline&quot;&gt;Hello World!&lt;/p&gt;&lt;p style=&quot;text-decoration:line-through&quot;&gt;Hello World!&lt;/p&gt;&lt;p style=&quot;text-decoration:blink&quot;&gt;Hello World!&lt;/p&gt;</code></pre><p style="text-decoration:none">Hello World!</p><p style="text-decoration:underline">Hello World!</p><p style="text-decoration:overline">Hello World!</p><p style="text-decoration:line-through">Hello World!</p><p style="text-decoration:blink">Hello World!</p><h3 id="垂直对齐方式-vertial-align"><a href="#垂直对齐方式-vertial-align" class="headerlink" title="垂直对齐方式 vertial-align"></a>垂直对齐方式 vertial-align</h3><p>该属性用来设置垂直对齐方式。该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值，这会使元素降低而不是升高。在表格中，这个属性可以用来设置单元格内容的对齐方式。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>baseline</td><td>默认。元素放置在父元素的基线上。</td></tr><tr><td>sub</td><td>垂直对齐文本的下标。</td></tr><tr><td>super</td><td>垂直对齐文本的上标</td></tr><tr><td>top</td><td>把元素的顶端与行中最高元素的顶端对齐</td></tr><tr><td>text-top</td><td>把元素的顶端与父元素字体的顶端对齐</td></tr><tr><td>middle</td><td>把此元素放置在父元素的中部。</td></tr><tr><td>bottom</td><td>把元素的顶端与行中最低的元素的顶端对齐。</td></tr><tr><td>text-bottom</td><td>把元素的底端与父元素字体的底端对齐。</td></tr><tr><td>length</td><td></td></tr><tr><td>%</td><td>使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 vertical-align 属性的值。</td></tr></tbody></table><p>下面是一个具体案例：</p><pre><code class="html">这是一幅 &lt;img class=&quot;top&quot; border=&quot;0&quot; src=&quot;/i/eg_cute.gif&quot; /&gt; 位于段落中的图像。这是一幅 &lt;img class=&quot;bottom&quot; border=&quot;0&quot; src=&quot;/i/eg_cute.gif&quot; /&gt; 位于段落中的图像。</code></pre><p>这是一幅 <img style="vertical-align:text-top" border="0" src="https://media.everdo.cn/tank/pic-bed/2020/04/15/eg_cute.gif"> 位于段落中的图像。</p><p>这是一幅 <img style="vertical-align:text-bottom" src="https://media.everdo.cn/tank/pic-bed/2020/04/15/eg_cute.gif"> 位于段落中的图像。</p><p></p><blockquote><p>vertical-align属性值还能使用百分比来设置垂直高度</p></blockquote><h3 id="文本转换-text-transform"><a href="#文本转换-text-transform" class="headerlink" title="文本转换 text-transform"></a>文本转换 text-transform</h3><p>在 CSS 样式中，text-transform 属性可用于设置文本字体的大小写转换。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义带有小写字母和大写字母的标准的文本。</td></tr><tr><td>capitalize</td><td>文本中的每个单词以大写字母开头。</td></tr><tr><td>uppercase</td><td>定义仅有大写字母。</td></tr><tr><td>lowercase</td><td>定义无大写字母，仅有小写字母。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 text-transform 属性的值。</td></tr></tbody></table><blockquote><p>如果值为 capitalize，则要对某些字母大写，但是并没有明确定义如何确定哪些字母要大写，这取决于用户代理如何识别出各个“词”。</p></blockquote><p>下面是具体使用案例：</p><pre><code class="html">&lt;p style=&quot;text-transform: uppercase&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-transform: lowercase&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-transform: capitalize&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-transform: normal&quot;&gt;I am EmptinessBoy !&lt;/p&gt;</code></pre><p style="text-transform:uppercase">I am EmptinessBoy !</p><p style="text-transform:lowercase">I am EmptinessBoy !</p><p style="text-transform:capitalize">I am EmptinessBoy !</p><p style="text-transform:normal">I am EmptinessBoy !</p><h3 id="水平对齐方式-text-align"><a href="#水平对齐方式-text-align" class="headerlink" title="水平对齐方式 text-align"></a>水平对齐方式 text-align</h3><p>text-align 属性用于定义对象文本的对齐方式。与 CSS2 相比，CSS3 增加了 start、end 和 string 属性值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>left，right，center</td><td>把文本排列到左边，右边，中间。</td></tr><tr><td>justify</td><td>实现两端对齐文本效果。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 text-align 属性的值。</td></tr></tbody></table><p>在新增加的属性值中，start 和 end 属性值主要是针对行内元素的（即在包含元素的头部或尾部显示），而 <code>&lt;string&gt;</code> 属性值主要用于表格单元格中，将根据某个指定的字符对齐。</p><pre><code class="html">代码示例：&lt;p style=&quot;text-align: justify&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-align: left&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-align: center&quot;&gt;I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-align: right&quot;&gt;I am EmptinessBoy !&lt;/p&gt;</code></pre><p style="text-align:justify">I am EmptinessBoy !</p><p style="text-align:left">I am EmptinessBoy !</p><p style="text-align:center">I am EmptinessBoy !</p><p style="text-align:right">I am EmptinessBoy !</p><h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 text-indent</h3><p>在普通段落中，通常首行缩进两个字符，用来表示这是一个段落的开始。同样在网页的文本编辑中可以通过指定属性来控制文本缩进。CSS 的 text-indent 属性可用来设置文本块中首行的缩进。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>定义固定的缩进。默认值：0。</td></tr><tr><td>%</td><td>定义基于父元素宽度的百分比的缩进。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 text-indent 属性的值。</td></tr></tbody></table><p>具体案例：</p><pre><code class="html">&lt;p style=&quot;text-align: justify;text-indent: 2em&quot;&gt;I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;text-align: justify;text-indent: 10%&quot;&gt;I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !&lt;/p&gt;</code></pre><p style="text-align:justify;text-indent:2em">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><p style="text-align:justify;text-indent:10%">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><h3 id="文本行高-line-height"><a href="#文本行高-line-height" class="headerlink" title="文本行高 line-height"></a>文本行高 line-height</h3><p>在 CSS 中，line-height 属性用来设置行间距，即行高。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认。设置合理的行间距。</td></tr><tr><td>number</td><td>设置数字，此数字会与当前的字体尺寸相乘来设置行间距。</td></tr><tr><td>length</td><td>设置固定的行间距。</td></tr><tr><td>%</td><td>基于当前字体尺寸的百分比行间距。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 line-height 属性的值。</td></tr></tbody></table><pre><code class="html">&lt;p style=&quot;line-height:15px&quot;&gt;I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !&lt;/p&gt;&lt;p style=&quot;line-height:200%&quot;&gt;I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! &lt;/p&gt;</code></pre><p style="line-height:15px">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><p style="line-height:200%">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><h3 id="处理空白-white-sapce"><a href="#处理空白-white-sapce" class="headerlink" title="处理空白 white-sapce"></a>处理空白 white-sapce</h3><blockquote><p><strong>空白字符：</strong> 在网页文本编辑中，有时需要包含一些不必要的制表符、换行符或额外的空白符（多于单词之间的一个标准的空格），这些符号统称为空白字符。通常情况下，浏览器可以自动忽略这些额外的空白字符并按照一种适合窗口的方式布置文本。它会丢弃段落开头和结尾处任何额外的空白，并将单词之间的所有制表符、换行和额外的空白压缩（合并）成单一的空白字符。此外，当用户调整窗口大小，时浏览器会根据需要重新格式化文本以便匹配新的窗口尺寸。对于某些元素，可能会以某种方式特意格式化文本以便包含额外的空白字符，而不抛弃或压缩这些字符。</p></blockquote><p>white-space 属性用于设置对象内空格字符的处理方式，该属性对文本的显示有着重要的影响。在标记上应用 white-space 属性可以影响浏览器对字符串或文本间空白的处理方式。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认。空白会被浏览器忽略。</td></tr><tr><td>pre</td><td>空白会被浏览器保留。其行为方式类似 HTML 中的 <code>&lt;pre&gt;</code> 标签。</td></tr><tr><td>nowrap</td><td>文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code> 标签为止。</td></tr><tr><td>pre-wrap</td><td>保留空白符序列，但是正常地进行换行。</td></tr><tr><td>pre-line</td><td>合并空白符序列，但是保留换行符。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 white-space 属性的值。</td></tr></tbody></table><p>示例代码：</p><pre><code class="html">&lt;p style=&quot;white-space: pre-wrap;&quot;&gt;    I am EmptinessBoy  !I am EmptinessBoy  !I am EmptinessBoy  !&lt;/p&gt;&lt;p style=&quot;white-space: nowrap;&quot;&gt;    I am EmptinessBoy  !I am EmptinessBoy  !I am EmptinessBoy  !&lt;/p&gt;</code></pre><p style="white-space:pre-wrap">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><p style="white-space:nowrap">I am EmptinessBoy ! I am EmptinessBoy ! I am EmptinessBoy !</p><h3 id="文本反排"><a href="#文本反排" class="headerlink" title="文本反排"></a>文本反排</h3><p>在网页文本编辑中，通常英语文档的基本方向是从左至右。如果文档中某一段的多个部分包含从右至左阅读的语言，此时可以通过 CSS 提供的 unicode-bidi 和 direction 两个属性解决文本反排的问题。</p><h4 id="unicode-bidi"><a href="#unicode-bidi" class="headerlink" title="unicode-bidi"></a>unicode-bidi</h4><p>（这里我也没咋搞明白）</p><ul><li><p>normal 元素不会对双向算法打开附加的一层嵌套。对于行内元素，顺序的隐式重排会跨元素边界进行。</p></li><li><p>embed 如果是一个行内元素，这个值对于双向算法会打开附件的一层嵌套。这个嵌套层的方向由 direction 属性指定。会在元素内部隐式地完成顺序重排。这对应于在元素开始处增加一个 LRE（对于 direction:ltr ：U+202A）或 RLE（对于 direction:rtl ：U+202B），并在元素的最后增加一个 PDF（U+202C）。</p></li><li><p>bidi-override 这会为行内元素创建一个覆盖。对于块级元素，将为不在另一块中的行内后代创建一个覆盖。这说明，顺序重排在元素内部严格按照 direction 属性进行；忽略了双向算法的隐式部分。这对应于在元素开始处增加一个 LRO（对于 direction:ltr ：U+202D）或 RLO（对于 direction:rtl ：U+202E），并在元素最后增加一个 PDF（U+202C）。</p></li></ul><h4 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h4><p>direction属性用于设置文本流的方向：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>ltr</td><td>默认。文本方向从左到右。</td></tr><tr><td>rtl</td><td>文本方向从右到左。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 direction 属性的值。</td></tr></tbody></table><p>下面是具体样例：</p><pre><code class="html">默认右对齐反转：&lt;p style=&quot;direction:rtl; unicode-bidi:bidi-override&quot;&gt;1234567890&lt;/p&gt;</code></pre><p style="direction:rtl;unicode-bidi:bidi-override">1234567890</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> CSS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 回调机制的解读（转）</title>
      <link href="/2020/04/JAVA-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A3%E8%AF%BB%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2020/04/JAVA-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A3%E8%AF%BB%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><blockquote><p>本文转载自 <a href="https://www.cnblogs.com/heshuchao/p/5376298.html" target="_blank" rel="noopener">https://www.cnblogs.com/heshuchao/p/5376298.html</a></p><p>学习这一块内容的时候，看了网上很多文章，感觉都有点不太容易理解。刚好翻到了这位大神通俗易懂的解说。就在这里记录学习啦！</p></blockquote><p>开始之前，先想象一个场景：幼稚园的小朋友刚刚学习了10以内的加法。</p><a id="more"></a><h2 id="第1章-故事的缘起"><a href="#第1章-故事的缘起" class="headerlink" title="第1章. 故事的缘起"></a>第1章. 故事的缘起</h2><p>幼师在黑板上写一个式子 “1 + 1 = ”，由小明同学来填空。</p><p>由于已经学习了10以内的加法，小明同学可以完全靠自己来计算这个题目，模拟该过程的代码如下：</p><pre><code class="java">public class Student{    private String name = null;    public Student(String name)    {        this.name = name;    }    public void setName(String name)    {        this.name = name;    }    private int calcADD(int a, int b)    {        return a + b;    }    public void fillBlank(int a, int b)    {        int result = calcADD(a, b);        System.out.println(name + &quot;心算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);    }}</code></pre><p>小明同学在填空 (fillBalnk) 的时候，直接心算 (clacADD) 了一下，得出结果是 2，并将结果写在空格里。测试代码如下：</p><pre><code class="java">public class Test{    public static void main(String[] args)    {        int a = 1;        int b = 1;        Student s = new Student(&quot;小明&quot;);        s.fillBlank(a, b);    }}</code></pre><p>运行结果如下：</p><pre><code>小明心算:1 + 1 = 2</code></pre><p>该过程完全由 Student 类的实例对象单独完成，并未涉及回调机制。</p><h2 id="第2章-幼师的找茬"><a href="#第2章-幼师的找茬" class="headerlink" title="第2章. 幼师的找茬"></a>第2章. 幼师的找茬</h2><p>课间，幼师突发奇想在黑板上写了 “168 + 291 = ” 让小明完成，然后回办公室了。</p><p>花擦！为什么所有老师都跟小明过不去啊？明明超纲了好不好！这时候小明同学明显不能再像上面那样靠心算来完成了，正在懵逼的时候，班上的小红同学递过来一个只能计算加法的计算器（奸商啊）！！！！而小明同学恰好知道怎么用计算器，于是通过计算器计算得到结果并完成了填空。</p><p>计算器的代码为：</p><pre><code class="java">public class Calculator{    public int add(int a, int b)    {        return a + b;    }}</code></pre><p>修改Student类，添加使用计算器的方法：</p><pre><code class="java">public class Student{    private String name = null;    public Student(String name)    {        this.name = name;    }    public void setName(String name)    {        this.name = name;    }    @SuppressWarnings(&quot;unused&quot;)    private int calcADD(int a, int b)    {        return a + b;    }    private int useCalculator(int a, int b)    {        return new Calculator().add(a, b);    }    public void fillBlank(int a, int b)    {        int result = useCalculator(a, b);        System.out.println(name + &quot;使用计算器:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);    }}</code></pre><p>测试代码如下：</p><pre><code class="java">public class Test{    public static void main(String[] args)    {        int a = 168;        int b = 291;        Student s = new Student(&quot;小明&quot;);        s.fillBlank(a, b);    }}</code></pre><p>运行结果如下：</p><pre><code>小明使用计算器:168 + 291 = 459</code></pre><p>该过程中仍未涉及到回调机制，但是部分小明的部分工作已经实现了转移，由计算器来协助实现。</p><h2 id="第3章-幼师回来了"><a href="#第3章-幼师回来了" class="headerlink" title="第3章. 幼师回来了"></a>第3章. 幼师回来了</h2><p>发现小明完成了 3 位数的加法，老师觉得小明很聪明，是个可塑之才。于是又在黑板上写下了 “26549 + 16487 = ”，让小明上课之前完成填空，然后又回办公室了。</p><p>小明看着教室外面撒欢儿的小伙伴，不禁悲从中来。再不出去玩，这个课间就要废了啊！！！！ 看着小红再一次递上来的计算器，小明心生一计：让小红代劳。</p><p>小明告诉小红题目是 “26549 + 16487 = ”，然后指出填写结果的具体位置，然后就出去快乐的玩耍了。</p><p>这里，不把小红单独实现出来，而是把这个只能算加法的计算器和小红看成一个整体，一个会算结果还会填空的超级计算器。这个超级计算器需要传的参数是两个加数和要填空的位置，而这些内容需要小明提前告知，也就是小明要把自己的一部分方法暴漏给小红，最简单的方法就是把自己的引用和两个加数一块告诉小红。</p><p>因此，超级计算器的 add 方法应该包含两个操作数和小明自身的引用，代码如下：</p><pre><code class="java">public class SuperCalculator{    public void add(int a, int b, Student  xiaoming)    {        int result = a + b;        xiaoming.fillBlank(a, b, result);    }}</code></pre><p>小明这边现在已经不需要心算，也不需要使用计算器了，因此只需要有一个方法可以向小红寻求帮助就行了，代码如下：</p><pre><code class="java">public class Student{    private String name = null;    public Student(String name)    {        this.name = name;    }    public void setName(String name)    {        this.name = name;    }    public void callHelp (int a, int b)    {        new SuperCalculator().add(a, b, this);    }    public void fillBlank(int a, int b, int result)    {        System.out.println(name + &quot;求助小红计算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);    }}</code></pre><p>测试代码如下：</p><pre><code class="java">public class Test{    public static void main(String[] args)    {        int a = 26549;        int b = 16487;        Student s = new Student(&quot;小明&quot;);        s.callHelp(a, b);    }}</code></pre><p>运行结果为：</p><pre><code>小明求助小红计算:26549 + 16487 = 43036</code></pre><p>执行流程为：小明通过自身的 callHelp 方法调用了小红 new SuperCalculator() 的add方法，在调用的时候将自身的引用（this）当做参数一并传入，小红在使用计算器得出结果之后，回调了小明的 fillBlank 方法，将结果填在了黑板上的空格里。</p><p>灯灯灯！到这里，回调功能就正式登场了，小明的 fillBlank 方法就是我们常说的回调函数。</p><p>通过这种方式，可以很明显的看出，对于完成老师的填空题这个任务上，小明已经不需要等待到加法做完且结果填写在黑板上才能去跟小伙伴们撒欢了，填空这个工作由超级计算器小红来做了。回调的优势已经开始体现了。</p><h2 id="第4章-门口的婆婆"><a href="#第4章-门口的婆婆" class="headerlink" title="第4章. 门口的婆婆"></a>第4章. 门口的婆婆</h2><p>幼稚园的门口有一个头发花白的老婆婆，每天风雨无阻在那里摆着地摊卖一些快过期的垃圾食品。由于年纪大了，脑子有些糊涂，经常算不清楚自己挣了多少钱。有一天，她无意间听到了小明跟小伙伴们吹嘘自己如何在小红的帮助下与幼师斗智斗勇。于是，婆婆决定找到小红牌超级计算器来做自己的小帮手，并提供一包卫龙辣条作为报酬。小红经不住诱惑，答应了。</p><p>回看一下上一章的代码，我们发现小红牌超级计算器的add方法需要的参数是两个整型变量和一个Student对象，但是老婆婆她不是学生，是个小商贩啊，这里肯定要做修改。这种情况下，我们很自然的会想到继承和多态。如果让小明这个学生和老婆婆这个小商贩从一个父类进行继承，那么我们只需要给小红牌超级计算器传入一个父类的引用就可以啦。</p><p>不过，实际使用中，考虑到 java 的单继承，以及不希望把自身太多东西暴漏给别人，这里使用从接口继承的方式配合内部类来做。</p><p>换句话说，小红希望以后继续向班里的小朋友们提供计算服务，同时还能向老婆婆提供算账服务，甚至以后能够拓展其他人的业务，于是她向所有的顾客约定了一个办法，用于统一的处理，也就是自己需要的操作数和做完计算之后应该怎么做。这个统一的方法，小红做成了一个接口，提供给了大家，代码如下：</p><pre><code class="java">public interface doJob{    public void fillBlank(int a, int b, int result);}</code></pre><p>因为灵感来自帮小明填空，因此小红保留了初心，把所有业务都当做填空（fillBlank）来做。</p><p>同时，小红修改了自己的计算器，使其可以同时处理不同的实现了 doJob 接口的人，代码如下：</p><pre><code class="java">public class SuperCalculator{    public void add(int a, int b, doJob  customer)    {        int result = a + b;        customer.fillBlank(a, b, result);    }}</code></pre><p>小明和老婆婆拿到这个接口之后，只要实现了这个接口，就相当于按照统一的模式告诉小红得到结果之后的处理办法，按照之前说的使用内部类来做，代码如下：</p><p>小明的：</p><pre><code class="java">public class Student{    private String name = null;    public Student(String name)    {        this.name = name;    }    public void setName(String name)    {        this.name = name;    }    public class doHomeWork implements doJob    {        @Override        public void fillBlank(int a, int b, int result)        {            System.out.println(name + &quot;求助小红计算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);        }    }    public void callHelp (int a, int b)    {        new SuperCalculator().add(a, b, new doHomeWork());    }}</code></pre><p>老婆婆的：</p><pre><code class="java">public class Seller{    private String name = null;    public Seller(String name)    {        this.name = name;    }    public void setName(String name)    {        this.name = name;    }    public class doHomeWork implements doJob    {        @Override        public void fillBlank(int a, int b, int result)        {            System.out.println(name + &quot;求助小红算账:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result + &quot;元&quot;);        }    }    public void callHelp (int a, int b)    {        new SuperCalculator().add(a, b, new doHomeWork());    }}</code></pre><p>测试程序如下：</p><pre><code class="java">public class Test{    public static void main(String[] args)    {        int a = 56;        int b = 31;        int c = 26497;        int d = 11256;        Student s1 = new Student(&quot;小明&quot;);        Seller s2 = new Seller(&quot;老婆婆&quot;);        s1.callHelp(a, b);        s2.callHelp(c, d);    }}</code></pre><p>运行结果如下：</p><pre><code>小明求助小红计算:56 + 31 = 87老婆婆求助小红算账:26497 + 11256 = 37753元</code></pre><p>最后的话：</p><p>可以很明显的看到，小红已经把这件事情当做一个事业来做了，看她给接口命的名字 doJob 就知道了。</p><p>有人也许会问，为什么老婆婆摆摊能挣那么多钱？ 你的关注点有问题好吗！！这里聊的是回调机制啊！！</p><p>我只知道，后来小红的业务不断扩大，终于在幼稚园毕业之前，用挣到的钱买了人生的第一套房子。</p><p>完！！！</p><h2 id="一些体会"><a href="#一些体会" class="headerlink" title="一些体会"></a>一些体会</h2><p>回调是一种双向的调用方式, 其实而言, 回调有同步和异步之分。</p><p>回调的思想是:</p><ul><li>类A的 a() 方法调用类 B 的 b() 方法</li><li>类B的 b() 方法执行完毕主动调用类 A 的 callback() 方法</li></ul><p>因为自己水平太菜，更多的内容还需要研究后才能填坑。这里先摘录这些。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发UI和布局（下）</title>
      <link href="/2020/04/Android-%E5%BC%80%E5%8F%91UI%E5%92%8C%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/04/Android-%E5%BC%80%E5%8F%91UI%E5%92%8C%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="Constraint-Layout-布局"><a href="#Constraint-Layout-布局" class="headerlink" title="Constraint Layout 布局"></a>Constraint Layout 布局</h2><p>Google I/O 2016 上发布了 Constraint Layout，Constraint 就是约束的意思。</p><p>约束帮助保持控件对齐. 你可以使用锚点(约束手柄)来确定各控件之间的对齐规则。</p><h3 id="创建手工约束"><a href="#创建手工约束" class="headerlink" title="创建手工约束"></a>创建手工约束</h3><blockquote><p>有一个像磁铁一样的小图标，打开和关闭用于切换自动/手动创建约束。</p></blockquote><a id="more"></a><p>要创建一个约束, 你需要在指定手柄上点击并按住鼠标, 然后拖到另一个控件的约束手柄. 一旦锚点变绿, 就可以松开鼠标完成约束创建.</p><p><a href="https://up.media.everdo.cn/image/JZKS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/contraintLayOut.gif" alt="contraintLayOut.gif"></a></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>如下所示创建一个 TextView 上锚点和 ImageView 底锚点之间的约束。</p><p><a href="https://up.media.everdo.cn/image/JG2Q" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/contraintLayOut2.gif" alt="contraintLayOut2.gif"></a></p><h4 id="调整元素尺寸"><a href="#调整元素尺寸" class="headerlink" title="调整元素尺寸"></a>调整元素尺寸</h4><p>此外，约束模式支持点击拖动角以调整图片大小：</p><p><a href="https://up.media.everdo.cn/image/JKmJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/contraintLayOut1.gif" alt="contraintLayOut1.gif"></a></p><h4 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h4><p>我们还可以使用左和右侧边约束锚定 ImageView 在布局中间：</p><p><a href="https://up.media.everdo.cn/image/JLwy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/contraintLayOut3.gif" alt="contraintLayOut3.gif"></a></p><h4 id="基线约束"><a href="#基线约束" class="headerlink" title="基线约束"></a>基线约束</h4><p>要连接控件的基线, 鼠标悬浮在空间上, 等几秒钟, 基线约束出现然后就可以连接了。</p><p><a href="https://up.media.everdo.cn/image/Jand" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/contraintLayOut4.gif" alt="contraintLayOut4.gif"></a></p><h3 id="Inspector-工具"><a href="#Inspector-工具" class="headerlink" title="Inspector 工具"></a>Inspector 工具</h3><p>ViewInspector.Inspector 在 UI 生成器上的右边. 除了列出所选控件的属性, 它还展示了 View 是如何对齐的以及所有的约束。</p><p><a href="https://up.media.everdo.cn/image/JgQl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/Inspector.jpg" alt="Inspector.jpg"></a></p><p>Inspector 显示出控件控件所在的区域</p><h4 id="Margins："><a href="#Margins：" class="headerlink" title="Margins："></a><strong>Margins：</strong></h4><p>控件外部的左右上下就是 margin. 可以点击 margin 的值并设置成另一个值来改变它.</p><h4 id="相对约束定位控件："><a href="#相对约束定位控件：" class="headerlink" title="相对约束定位控件："></a><strong>相对约束定位控件：</strong></h4><p>当一个控件上有至少两个对立的连接时, 比如上和下, 或者左和右, 你可以看到一个可以让你沿着对立连接的轴调整控件位置的滑块. 这也被称为横向或纵向偏量. 调整纵向和横向偏量然后改变方向, 可以看到偏量依然保留. 另外也可以通过移动控件到目标目标位置实现这一点.</p><p><a href="https://up.media.everdo.cn/image/JlT0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/aeb88b5a9ecddd7ed2da4a96effb3095.gif" alt="aeb88b5a9ecddd7ed2da4a96effb3095.gif"></a></p><h4 id="控件内部尺寸"><a href="#控件内部尺寸" class="headerlink" title="*控件内部尺寸: *"></a>*<em>控件内部尺寸: *</em></h4><p>控件内部的线允许你控制它的尺寸。</p><p><a href="https://up.media.everdo.cn/image/P44D" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/size.png" alt="size.png"></a></p><p>这是 Inspector 中一个控件的放大视图. 点击 Inspector 面板控件内部的线, 会循环切换以下选项</p><p><a href="https://up.media.everdo.cn/image/PPL2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/size1.png" alt="size1.png"></a><strong>Fixed:</strong> 此选项允许你指定控件的高和宽.</p><p><a href="https://up.media.everdo.cn/image/PHYL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/size2.png" alt="size2.png"></a><strong>AnySize:</strong> 此选项让控件占用所有可用空间以适应约束. 换句话说, 这更像是匹配约束. 与 match_parent 不同, 后者占用父 View 的所有可用空间.AnySize 与容器无关. 如果 ImageView 约束于一个 Button, 设置为 AnySize 只会扩展它适应 button.</p><p><a href="https://up.media.everdo.cn/image/PJzc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/size3.png" alt="size3.png"></a><strong>Wrap Content:</strong> 此选项仅扩展至所含元素(如 text 或者 drawable)填充满 widget.</p><h4 id="擅用辅助线"><a href="#擅用辅助线" class="headerlink" title="擅用辅助线"></a>擅用辅助线</h4><p>单击辅助线位置上的标记，可以在 dp 和百分比之间切换。可以将控件基于辅助线创建约束。</p><h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><p>这里为了后面的学习，我使用 Constraint Layout 绘制了一个看起来还不错的登录界面。最终效果图如下：</p><p><a href="https://up.media.everdo.cn/image/Ph2Z" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/login.jpg" alt="login.jpg"></a></p><p>布局细节：（因为水平有限，外层 Constraint Layout，中间部分嵌套了 LinerLayout）</p><p><a href="https://up.media.everdo.cn/image/Pnmk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/login1.jpg" alt="login1.jpg"></a></p><h5 id="顶部透明状态栏"><a href="#顶部透明状态栏" class="headerlink" title="顶部透明状态栏"></a>顶部透明状态栏</h5><p>通过修改 <code>res/values/styles.xml</code></p><pre><code class="xml">&lt;resources&gt;    &lt;!-- Base application theme. --&gt;    &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;        &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;         &lt;!-- 透明部分. --&gt;        &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;        &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;</code></pre><p>主题色 <code>res/values/colors.xml</code></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;color name=&quot;colorPrimary&quot;&gt;#505050&lt;/color&gt;    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303030&lt;/color&gt;    &lt;color name=&quot;colorAccent&quot;&gt;#FF9800&lt;/color&gt;&lt;/resources&gt;</code></pre><h5 id="自定义的按钮"><a href="#自定义的按钮" class="headerlink" title="自定义的按钮"></a>自定义的按钮</h5><p>顶部两个灰色按钮和下方的登录按钮使用了 imgButton 和 普通按钮的集合：</p><blockquote><p>使用 selector 改变 Button 点击时和非点击时的背景，实现点击按钮改变颜色的触摸反馈。</p></blockquote><ol><li>在 drawable 中新建两个 xml 文件，使用 shape 定义背景。（<code>shape_normal.xml</code> 和 <code>shape_pressed.xml</code>）</li><li>在 drawable 中新建 <code>button_selector.xml</code> 文件。</li><li>使用 item 中的 <code>android:state_pressed</code> 属性指定点击时和非点击时使用的效果文件。</li><li>在 Button 中添加 <code>android:background=&quot;@drawable/button_selector&quot;</code> 属性</li></ol><p>主布局文件处修改：</p><pre><code class="xml">&lt;ImageButton   android:id=&quot;@+id/buttonClose&quot;   android:layout_width=&quot;35dp&quot;   android:layout_height=&quot;35dp&quot;   android:background=&quot;@drawable/imgbutton_selector&quot;/&gt;&lt;!--按钮内部分代码省略，主要修改了background--&gt;&lt;Button   android:id=&quot;@+id/buttonReg&quot;   android:layout_width=&quot;58dp&quot;   android:layout_height=&quot;31dp&quot;   android:background=&quot;@drawable/button_selector&quot;   android:text=&quot;@string/reg&quot;   android:textColor=&quot;#FFFFFF&quot;   android:textColorHint=&quot;#505050&quot;/&gt;&lt;!--按钮内部分代码省略，主要修改了background--&gt;</code></pre><p>由于修改了默认的背景样式，导致按钮不能继承默认主题的样式，所以会失去点击触发效果。因此这里给按钮增加选择器：</p><pre><code class="xml">&lt;!--res/drawable/button_selector.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:state_pressed=&quot;true&quot;        android:drawable=&quot;@drawable/shape_pressed&quot;/&gt;    &lt;item android:state_pressed=&quot;false&quot;        android:drawable=&quot;@drawable/shape_normal&quot;/&gt;&lt;/selector&gt;&lt;!--res/drawable/imgbutton_selector.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:state_pressed=&quot;true&quot;        android:drawable=&quot;@drawable/imgbutton_circlepressed&quot;/&gt;    &lt;item android:state_pressed=&quot;false&quot;        android:drawable=&quot;@drawable/imgbutton_circlenormal&quot;/&gt;&lt;/selector&gt;</code></pre><p>创建上面所引用的四个 xml 文件：（由于另外三个代码部分基本相同就不再展示）</p><pre><code class="xml">&lt;!--res/drawable/imgbutton_circlenormal.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt;    &lt;solid android:color=&quot;#60000000&quot; /&gt;    &lt;!--    &lt;stroke android:width=&quot;1dip&quot; android:color=&quot;#3F3F3F&quot;/&gt;--&gt;    &lt;!--     圆角--&gt;    &lt;corners android:radius=&quot;100dp&quot; /&gt;    &lt;!--     边距--&gt;    &lt;padding        android:bottom=&quot;3dp&quot;        android:left=&quot;3dp&quot;        android:right=&quot;3dp&quot;        android:top=&quot;3dp&quot; /&gt;&lt;/shape&gt;</code></pre><h5 id="按钮触摸反馈动画"><a href="#按钮触摸反馈动画" class="headerlink" title="按钮触摸反馈动画"></a>按钮触摸反馈动画</h5><p>使用系统自带的两个 Ripple 波纹效果</p><pre><code class="java">//有边界?android:attr/selectableItemBackground//无边界 （要求API21以上）?android:attr/selectableItemBackgroundBorderless </code></pre><p>使用时只需要把上面这两个值作为 View 的 <code>android:background=&quot;&quot; 或 android:foreground=&quot;&quot;</code> 即可（如果已经有背景， 可以设置到前景属性中）。</p><p>想要效果显示出来要保证 View 的 <code>android:clickable=&quot;true&quot;</code>。<br>这里的颜色是系统默认的，可以在 theme 里更改默认的波纹颜色：</p><pre><code class="xml">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;    &lt;!-- API 21 theme customizations can go here. --&gt;    &lt;item name=&quot;android:colorControlHighlight&quot;&gt;#ff0000&lt;/item&gt;&lt;/style&gt;</code></pre><h5 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h5><p>通过设置 <code>android:letterSpacing</code> 这个属性就可以非常方便的设置水平方向文本的字间距。</p><pre><code class="java">// 在XML中：android:letterSpacing=&quot;0.05&quot;// 在代码中动态设置，如下：textView.setLetterSpacing(0.05);</code></pre><h2 id="Popup-Window-控件"><a href="#Popup-Window-控件" class="headerlink" title="Popup Window 控件"></a>Popup Window 控件</h2><p>PopupWindow 是一个可以在 Activity 之上显示任意 View 的控件。在 Android 经常使用，效果跟 Dialog 效果类似，不同点在于可以控制显示的位置，比如底部显示等。</p><p>特性：浮动弹出自定义窗体，并可设置弹出位置。</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>PopupWindow</td><td>构造函数，常用参数表：contentView – 弹窗界面内容 width – 弹窗宽度 height – 弹窗高度 focusable – 能否聚焦</td></tr><tr><td>setTouchable</td><td>是否支持点击操作</td></tr><tr><td>showAtLocation</td><td>按指定位置弹出显示自定义视图</td></tr><tr><td>showAsDropDown</td><td>下拉弹出显示自定义视图</td></tr></tbody></table><h3 id="定义弹出的布局"><a href="#定义弹出的布局" class="headerlink" title="定义弹出的布局"></a>定义弹出的布局</h3><p>这里采用新建布局文件 XML 的形式添加弹出控件：（以登录界面 DEMO 为例）：</p><p>此处新建了一个 popup_content.xml 的布局文件：</p><p><a href="https://up.media.everdo.cn/image/P7OB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/popupwindow.jpg" alt="popupwindow.jpg"></a></p><p>并在里面添加了两组按钮。</p><p><a href="https://up.media.everdo.cn/image/PRnt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/popupwindow1.jpg" alt="popupwindow1.jpg"></a></p><pre><code class="java">PopupWindow regWindow = new PopupWindow(regView, LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT,true);</code></pre><p>上述代码设置了弹出 regView 的界面，宽高自适应父容器，允许聚焦。</p><h4 id="LayoutInflater-作用及使用"><a href="#LayoutInflater-作用及使用" class="headerlink" title="LayoutInflater 作用及使用"></a>LayoutInflater 作用及使用</h4><p>作用：</p><ol><li>对于一个没有被载入或者想要动态载入的界面, 都需要使用 inflate 来载入.</li><li>对于一个已经载入的 Activity，就可以使用实现了这个 Activiyt 的findViewById 方法来获得其中的界面元素。</li></ol><p>LayoutInflater 这个类的作用类似于 findViewById(),不同点是 LayoutInflater 是用来找 layout 下 xml 布局文件，并且实例化！而 findViewById() 是找具体 xml 下的具体 widget 控件。</p><p>最简单的使用方法：</p><pre><code class="java">View regView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popup_content,null,false);</code></pre><p>LayoutInflater.from 从给定的上下文获取 LayoutInflater。</p><p>.inflate 方法从指定的 xml 资源中添加新的视图层次结构。InflateException 如果有错误则抛出。最后该方法会返回一个 View。</p><p>第一个参数 resource int：要加载的XML布局资源的 ID（例如，R.layout.main_page）。第二个参数 root ViewGroup：作为生成层次结构的父级的可选视图，此值可能是 null。第三个参数 boolean attachToRoot 控制是否将第一个参数所指定的 View 添加到 root 中。</p><h3 id="设置允许触摸"><a href="#设置允许触摸" class="headerlink" title="设置允许触摸"></a>设置允许触摸</h3><pre><code class="java">regWindow.setTouchable(true);</code></pre><h3 id="设置弹出位置"><a href="#设置弹出位置" class="headerlink" title="设置弹出位置"></a>设置弹出位置</h3><ul><li>showAsDropDown(View anchor)：相对某个控件的位置（正左下方），无偏移</li><li>showAsDropDown(View anchor,int xoff,int yoff)：相对某个控件的位置，有偏移</li><li>showAtLocation(View parent,int gravity,int x,int y)：相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移</li></ul><pre><code class="java">regWindow.showAtLocation(v, Gravity.BOTTOM,0, 0);//regWindow.showAtLocation(getWindow().getDecorView(), Gravity.BOTTOM,0, 0);</code></pre><p>到这一步的时候，点击右上角注册按钮，已经可以正常弹出注册对话框了。</p><p><a href="https://up.media.everdo.cn/image/Pjqx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/popupwindow2.jpg" alt="popupwindow2.jpg"></a></p><p>修改样式加以美化：</p><p><a href="https://up.media.everdo.cn/image/PoXI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/popupwindow3.jpg" alt="popupwindow3.jpg"></a></p><h3 id="添加动画（参考网络）"><a href="#添加动画（参考网络）" class="headerlink" title="添加动画（参考网络）"></a>添加动画（参考网络）</h3><p>首先在 res/src 下创建 anim 文件夹</p><p>创建 pophide.xml 隐藏时的动画参数</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;     &lt;translate        android:duration=&quot;1000&quot;        android:fromYDelta=&quot;0&quot;        android:toYDelta=&quot;50%p&quot; /&gt;    &lt;alpha        android:duration=&quot;1000&quot;        android:fromAlpha=&quot;1.0&quot;        android:toAlpha=&quot;0.0&quot; /&gt;&lt;/set&gt;</code></pre><p>创建 popshow.xml 显示时的动画</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;     &lt;translate        android:duration=&quot;1000&quot;        android:fromYDelta=&quot;100%p&quot;        android:toYDelta=&quot;0&quot; /&gt;    &lt;alpha        android:duration=&quot;1000&quot;        android:fromAlpha=&quot;0.0&quot;        android:toAlpha=&quot;1.0&quot; /&gt;&lt;/set&gt;</code></pre><p>然后在主题配置文件 style.xml 里创建</p><style name="mypopwindow_anim_style"></style><p>最后在activity中调用</p><pre><code class="java">// 设置popWindow的显示和消失动画popupWindow.setAnimationStyle(R.style.mypopwindow_anim_style);</code></pre><p><a href="https://up.media.everdo.cn/image/PF4X" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/popupwinow.gif" alt="popupwinow.gif"></a></p><h2 id="AlertDialog-控件"><a href="#AlertDialog-控件" class="headerlink" title="AlertDialog 控件"></a>AlertDialog 控件</h2><p>AlertDialog 用于弹出警告窗体，提示重要信息，提示用户再次确认操作。可设置确认、取消按钮等事件。</p><h3 id="AlertDialog-窗体的常用方法"><a href="#AlertDialog-窗体的常用方法" class="headerlink" title="AlertDialog 窗体的常用方法"></a>AlertDialog 窗体的常用方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>show</td><td>显示警告窗体</td></tr><tr><td>isShowing</td><td>判断警告窗体是否处于显示状态</td></tr><tr><td>setTitle</td><td>设置警告窗体标题</td></tr><tr><td>setIcon</td><td>设置图标</td></tr><tr><td>setMessage</td><td>设置警告内容正文</td></tr><tr><td>setButton</td><td>设置操作按钮</td></tr></tbody></table><h3 id="AlertDialog-Builder-构造器的常用方法"><a href="#AlertDialog-Builder-构造器的常用方法" class="headerlink" title="AlertDialog.Builder 构造器的常用方法"></a>AlertDialog.Builder 构造器的常用方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>AlertDialog.Builder</td><td>警告窗体构造器的构造函数</td></tr><tr><td>builder.create</td><td>创建警告窗体</td></tr></tbody></table><h3 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="DEMO"></a>DEMO</h3><p>这里我们为登录案例的退出按钮添加一个警告对话框，在创建监听器后，编写警告窗体实例：</p><pre><code class="java">public void onClick(View v) {    //创建警告窗体实例    AlertDialog quitConfirm = new AlertDialog.Builder(MainActivity.this).create();    //设置内容    quitConfirm.setIcon(R.drawable.close);    quitConfirm.setMessage(&quot;您确定要离开么？&quot;);    quitConfirm.setButton(AlertDialog.BUTTON_POSITIVE, &quot;确认&quot;, new DialogInterface.OnClickListener() {        @Override        public void onClick(DialogInterface dialog, int which) {        //确认按钮后执行的内容            android.os.Process.killProcess(android.os.Process.myPid()); //退出程序代码        }    });    quitConfirm.setButton(AlertDialog.BUTTON_NEGATIVE, &quot;取消&quot;, new DialogInterface.OnClickListener() {        @Override        public void onClick(DialogInterface dialog, int which) {            //点击取消后执行的代码        }    });    quitConfirm.show();}</code></pre><p>运行效果：</p><p><a href="https://up.media.everdo.cn/image/P3bi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/09/AlertDialog.jpg" alt="AlertDialog.jpg"></a></p><p>点击退出后，整个 APP 退出。</p><h2 id="自定义对话框-CustomDialog"><a href="#自定义对话框-CustomDialog" class="headerlink" title="自定义对话框 CustomDialog"></a>自定义对话框 CustomDialog</h2><p>如果 AlertDialog 不能满足一些较为复杂的程序设计需求，那么可以使用 CustomDialog 进行高级的定制：</p><blockquote><p>开发者可以设计继承于 android.app.Dialog 的自定义对话框派生类（有时习惯命名为 CustomDialog）来弹出自定义界面的对话框，用户可在对话框进行下一步操作输入输出界面、操作按钮事件等均可自定义</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>构造函数</td><td>实例化过程中的初始化程序，可自定义参数表传入用户自定义参数</td></tr><tr><td>onCreate</td><td>对话框初始化</td></tr><tr><td>show</td><td>显示对话框</td></tr></tbody></table><p>简单的自定义对话框类的成员结构 (类名：CustomDialog)：</p><pre><code class="java">//构造函数：CustomDialog(Context context, String content, CustomDialog.OnCustomDialogListener customDialogListener)</code></pre><pre><code class="java">//按钮事件功能的定义：interface OnCustomDialogListener {    public void func1(String data); //回调功能    public void func2(String data); //回调功能    //可以定义一个或多个回调功能…}</code></pre><pre><code class="java">//初始化：onCreate(Bundle savedInstanceState) {    …    setContentView(R.layout.custom_dialog);  //调用自定义对话框布局设置     …        //按钮1单击事件调用customDialogListener.func1功能    //按钮2单击事件调用customDialogListener.func2功能    …} </code></pre><p>对自定义对话框类的调用：</p><pre><code class="java">CustomDialog dialog = new CustomDialog(MainActivity.this,&quot;对话框提示内容&quot;,     new CustomDialog.OnCustomDialogListener() {        @Override        public void func1(String data) { … }  //编写按钮1的事件实现程序        @Override        public void func1(String data) { … }  //编写按钮2的事件实现程序    });  //自定义对话框的实例化dialog.show();  //显示自定义对话框</code></pre><h3 id="添加布局设计"><a href="#添加布局设计" class="headerlink" title="添加布局设计"></a>添加布局设计</h3><p>在 res/layout 下新建 custom_dialog.xml</p><p><a href="https://up.media.everdo.cn/image/PA04" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_layout.jpg" alt="custom_dialog_layout.jpg"></a></p><p>绘制用户协议的基本布局：</p><p><a href="https://up.media.everdo.cn/image/PDLM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_tos.jpg" alt="custom_dialog_tos.jpg"></a></p><h3 id="新增自定义类"><a href="#新增自定义类" class="headerlink" title="新增自定义类"></a>新增自定义类</h3><p>这里创建一个 CustomDialog 的派生类</p><p><a href="https://up.media.everdo.cn/image/PYFY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_class.jpg" alt="custom_dialog_class.jpg"></a></p><pre><code class="java">package com.emptinessboy.logindemo;import android.app.Dialog;public class customDialog extends Dialog {  //这里我们将这个自定义类继承于 android.app.Dialog}</code></pre><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p><a href="https://up.media.everdo.cn/image/Pbma" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_constructor.jpg" alt="custom_dialog_constructor.jpg"></a></p><p>这里我们使用系统自带模板生成构造函数：</p><p><a href="https://up.media.everdo.cn/image/Pi73" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_constructor1.jpg" alt="custom_dialog_constructor1.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/PrqG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_constructor2.jpg" alt="custom_dialog_constructor2.jpg"></a></p><p>同时用生成器生成一个重载的方法 onCreat()</p><p><a href="https://up.media.everdo.cn/image/PQX9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/custom_dialog_constructor3.jpg" alt="custom_dialog_constructor3.jpg"></a></p><pre><code class="java">package com.emptinessboy.logindemo;import android.app.Dialog;import android.content.Context;import android.os.Bundle;import androidx.annotation.NonNull;public class customDialog extends Dialog {    public customDialog(@NonNull Context context) {        super(context); //生成的构造函数    }    @Override    //onCreate()用作对话框的初始化    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState); //生成的方法重载        setContentView(R.layout.custom_dialog); //调用样式    }}</code></pre><p>最后完整的代码 custonDialog 类代码：</p><pre><code class="java">public class customDialog extends Dialog {    private onCustomDialogListener CustomDialogListener;    //将实例化的对象保存    public customDialog(@NonNull Context context,onCustomDialogListener CustomDialogListener) { //第二个参数用来传入已经实例化的对象        super(context); //生成的构造函数        this.CustomDialogListener = CustomDialogListener;    }    //用于调用的接口    public interface onCustomDialogListener {        //定义回调事件        //按钮点击事件        public void buttonConfirmTosClicked();    }    @Override    //onCreate()用作对话框的初始化    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState); //生成的方法重载        setContentView(R.layout.custom_dialog); //调用样式        Button buttonConfirmTos = findViewById(R.id.buttonConfirmTos);        buttonConfirmTos.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                CustomDialogListener.buttonConfirmTosClicked(); //此处回调接口的方法，具体触发的事件由接口在主函数中定义            }        });    }}</code></pre><h4 id="禁用EditText（DEMO）"><a href="#禁用EditText（DEMO）" class="headerlink" title="禁用EditText（DEMO）"></a>禁用EditText（DEMO）</h4><p>代码如下</p><pre><code class="java">editText.setEnabled(false);//简单粗暴editText.setFocusable(false);//不可编辑editText.setFocusableInTouchMode(false);//触摸不可编辑editText.setKeyListener(null);//不可粘贴，长按不会弹出粘贴框editText.setClickable(false);//不可点击，但是这个效果我这边没体现出来，不知道怎没用</code></pre><p>因此修改后增加下面的代码：(在自定义类的 onCreat方法中)：</p><pre><code class="java">//这段代码定义了宽度Window window = this.getWindow();WindowManager.LayoutParams lp = window.getAttributes();lp.width = WindowManager.LayoutParams.MATCH_PARENT;lp.height = 1800;this.getWindow().setAttributes(lp);EditText tos = findViewById(R.id.Tos);tos.setFocusable(false);//不可编辑</code></pre><p>那么现在要做的就是从主函数调用接口了，在主函数中，使用 regTos 函数进行调用。调用过程中需要创建一个继承类：</p><pre><code class="java">void regTos(){    //调用customDialog    customDialog dialog = new customDialog(MainActivity.this, new tosConfirm());    dialog.show();}public class tosConfirm implements customDialog.onCustomDialogListener{    public void buttonConfirmTosClicked() {        Toast.makeText(MainActivity.this,&quot;需要先同意协议才能注册哦！&quot;,Toast.LENGTH_SHORT).show();    }}</code></pre><h4 id="回调参数（DEMO）"><a href="#回调参数（DEMO）" class="headerlink" title="回调参数（DEMO）"></a>回调参数（DEMO）</h4><p>这里还需要增加是否阅读协议的判断，可以为接口添加传入参数：</p><p>先修改接口</p><pre><code class="java">这里是 custonDialog 类 接口部分//用于调用的接口public interface onCustomDialogListener {    //定义回调事件    //按钮点击事件    public void buttonConfirmTosClicked(boolean isRead);}......下面是 custonDialog 类按钮监听事件下的 OnCreat 函数部分public void onClick(View v) {    CheckBox checkBoxConfirmTos = findViewById(R.id.checkBoxConfirmTos);    boolean isRead = false;    if(checkBoxConfirmTos.isChecked())        isRead = true;    CustomDialogListener.buttonConfirmTosClicked(isRead); //此处回调接口的方法，具体触发的事件由接口在主函数中定义}</code></pre><p>这里是 MainActivity 修改回调传入参数部分：</p><pre><code class="java">void regTos(){    //调用customDialog    customDialog dialog = new customDialog(MainActivity.this, new tosConfirm());    dialog.show();}public class tosConfirm implements customDialog.onCustomDialogListener{    @Override    public void buttonConfirmTosClicked(boolean isRead) {        if(isRead){            Toast.makeText(MainActivity.this,&quot;注册还没开放哦！&quot;,Toast.LENGTH_SHORT).show();        }        else{            Toast.makeText(MainActivity.this,&quot;需要先同意协议才能注册哦！&quot;,Toast.LENGTH_SHORT).show();        }    }}</code></pre><p>最终完成效果：</p><p><a href="https://up.media.everdo.cn/image/PxHj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/10/loginfinish.gif" alt="loginfinish.gif"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发UI和布局（上）</title>
      <link href="/2020/04/Android-%E5%BC%80%E5%8F%91UI%E5%92%8C%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2020/04/Android-%E5%BC%80%E5%8F%91UI%E5%92%8C%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p><a href="https://up.media.everdo.cn/image/JRl6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/uibujv.jpg" alt="uibujv.jpg"></a></p><h2 id="LinearLayout-布局"><a href="#LinearLayout-布局" class="headerlink" title="LinearLayout 布局"></a>LinearLayout 布局</h2><p>LinearLayout 是线性布局控件，它作为容器将其包含的子控件以横向或纵向的方式排列。</p><h3 id="布局方向"><a href="#布局方向" class="headerlink" title="布局方向"></a>布局方向</h3><p><a href="https://up.media.everdo.cn/image/J2fS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/LinearLayout-new.jpg" alt="LinearLayout-new.jpg"></a></p><p>子元素被排列成一行或一列，并使用 orientation 属性设置方向。horizontal 为横向水平排列，vertical 为垂直纵向排列</p><a id="more"></a><h3 id="布局定位："><a href="#布局定位：" class="headerlink" title="布局定位："></a>布局定位：</h3><ul><li>layout_gravity：元素在容器中的位置</li><li>gravity：元素所包含的内容或子元素在元素中的位置。</li></ul><br><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>下面是一个具体案例：</p><p>新建项目后，删除默认控件后，修改布局为 LinearLayout，</p><p><a href="https://up.media.everdo.cn/image/JFGQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/convert-linerlayout.jpg" alt="convert-linerlayout.jpg"></a></p><p>然后将 LinerLayout 主界面设置为 vertical 纵向排列。</p><p><a href="https://up.media.everdo.cn/image/JAoJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/convert-linerlayout-ver.jpg" alt="convert-linerlayout-ver.jpg"></a></p><p>尝试添加文本框部件，并修改默认显示文字 hint 属性值：</p><p><a href="https://up.media.everdo.cn/image/JDNy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/LinearLayout-text.jpg" alt="LinearLayout-text.jpg"></a></p><p>添加一个嵌套的 LinerLayout 布局（设置为 horizontal），并添加 button 控件：</p><p><a href="https://up.media.everdo.cn/image/JVtd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/linerlayout-button.png" alt="linerlayout-button.png"></a></p><p>至此，布局完成，模拟器显示界面和设计一致：</p><p><a href="https://up.media.everdo.cn/image/JbIl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/LinearLayout-ok.jpg" alt="LinearLayout-ok.jpg"></a></p><h2 id="RelativeLayout-布局"><a href="#RelativeLayout-布局" class="headerlink" title="RelativeLayout 布局"></a>RelativeLayout 布局</h2><p>RelativeLayout 布局下，元素在相对位置显示，可避免嵌套，保持简洁的层次结构。</p><p><a href="https://up.media.everdo.cn/image/Jdr0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/RelativeLayout.jpg" alt="RelativeLayout.jpg"></a></p><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>layout_alignParentTop</td><td>父元素顶部对齐（true）</td></tr><tr><td>layout_alignParentBottom</td><td>父元素底部对齐（true）</td></tr><tr><td>layout_alignParentStart</td><td>父元素左侧对齐（true）</td></tr><tr><td>layout_alignParentEnd</td><td>父元素右侧对齐（true）</td></tr><tr><td>layout_centerHorizontal</td><td>水平居中（true）</td></tr><tr><td>layout_centerVertical</td><td>垂直居中（true）</td></tr><tr><td>layout_marginTop</td><td>距离顶部</td></tr><tr><td>layout_marginBottom</td><td>距离底部</td></tr><tr><td>layout_marginStart</td><td>距离左侧</td></tr><tr><td>layout_marginEnd</td><td>距离右侧</td></tr><tr><td>layout_above</td><td>底部置于给定元素之上</td></tr><tr><td>layout_below</td><td>顶部置于给定元素之下</td></tr><tr><td>layout_alignTop</td><td>顶部与给定元素顶部对齐</td></tr><tr><td>layout_alignBaseline</td><td>baseline 与给定元素的 baseline 对齐</td></tr><tr><td>layout_alignBottom</td><td>底部与给定元素底部对齐</td></tr><tr><td>layout_alignStart</td><td>左侧对齐给定元素</td></tr><tr><td>layout_alignEnd</td><td>右侧对齐给定元素</td></tr><tr><td>layout_toStartOf</td><td>右侧对齐给定元素开始的位置</td></tr><tr><td>layout_toEndOf</td><td>左侧对齐给定元素结束的位置</td></tr></tbody></table><h3 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="DEMO"></a>DEMO</h3><p>下面是一个具体案例：</p><p><a href="https://up.media.everdo.cn/image/JeyD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/RelativeLayout-cj.png" alt="RelativeLayout-cj.png"></a></p><p>设定布局模式为 RelativeLayout 后，将上方工具栏的磁吸工具开启，然后向屏幕内拖放控件。</p><p><a href="https://up.media.everdo.cn/image/JilL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/RelativeLayout-demo.jpg" alt="RelativeLayout-demo.jpg"></a></p><p>调整完后，重新设置相对关系：</p><p><a href="https://up.media.everdo.cn/image/JQVc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/move.png" alt="move.png"></a></p><p>至此，布局完成，模拟器显示界面和设计一致：</p><p><a href="https://up.media.everdo.cn/image/Jqs2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/RelativeLayout-run.jpg" alt="RelativeLayout-run.jpg"></a></p><h2 id="FrameLayout-布局"><a href="#FrameLayout-布局" class="headerlink" title="FrameLayout 布局"></a>FrameLayout 布局</h2><p>FrameLayout 是帧布局控件，可以使子元素逐个叠加在栈中。（最后添加的元素位于视图的最上层，也可以理解为图层堆叠的形态）</p><p>两个属性:</p><ul><li>android:foreground:*设置改帧布局容器的前景图像</li><li>android:foregroundGravity:设置前景图像显示的位置</li></ul><p><a href="https://up.media.everdo.cn/image/JChG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/05/FrameLayout.jpg" alt="FrameLayout.jpg"></a></p><h2 id="View-控件（顶层）"><a href="#View-控件（顶层）" class="headerlink" title="View 控件（顶层）"></a>View 控件（顶层）</h2><p>View，TextView，Button 与 EditText 的关系：</p><p><a href="https://up.media.everdo.cn/image/J9hx" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/view-tree.jpg" alt="view-tree.jpg"></a></p><p><a href="https://up.media.everdo.cn/image/JNkB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/view.jpg" alt="view.jpg"></a></p><h3 id="TextView-控件（父类）"><a href="#TextView-控件（父类）" class="headerlink" title="TextView 控件（父类）"></a>TextView 控件（父类）</h3><p>显示文字，只读，可设置字体、字号、颜色、链接等样式。</p><p><a href="https://up.media.everdo.cn/image/J6ok" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/textview.jpg" alt="textview.jpg"></a></p><h4 id="EditText-控件（子类）"><a href="#EditText-控件（子类）" class="headerlink" title="EditText 控件（子类）"></a>EditText 控件（子类）</h4><p>显示和编辑文字，可编辑，可设置软键盘类型。</p><p><a href="https://up.media.everdo.cn/image/Jktt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/eidt-text.jpg" alt="eidt-text.jpg"></a></p><h2 id="Button-控件（EditText-子类）"><a href="#Button-控件（EditText-子类）" class="headerlink" title="Button 控件（EditText 子类）"></a>Button 控件（EditText 子类）</h2><h3 id="继承关系："><a href="#继承关系：" class="headerlink" title="继承关系："></a>继承关系：</h3><p><a href="https://up.media.everdo.cn/image/J1KY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/tree.jpg" alt="tree.jpg"></a></p><h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3><ul><li>单击事件：通过触屏或鼠标点击按钮所激发的事件</li><li>长按事件：通过触屏或鼠标按下按钮控并保持不放开所激发的事件</li></ul><p>单点事件定义方法：</p><ul><li>Button 控件提供了 onClick 属性</li><li>事件监听器绑定方法通过调用控件的 setOnClickListener 绑定相应方法</li></ul><p>下面是一个具体案例：（简单 BMI 计算器）</p><p>先构造 UI 布局，这里采用了 LinerLayout 线性布局。然后向视图内摆放 UI 控件。（为了美观，可以设置下 LayoutMargin 进行布局排版）</p><p><a href="https://up.media.everdo.cn/image/JEQI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmi-creat.png" alt="bmi-creat.png"></a></p><p>这里需要将 textView 的 inputType 设置为 numberDecline 类型（软键盘类型，增强用户体验）</p><p><a href="https://up.media.everdo.cn/image/JcyX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmi-numberdecline.png" alt="bmi-numberdecline.png"></a></p><p>这里我们在 MainActivity.java 文件中编写我们的代码：</p><p>先构造一个简单的函数 btnCalBmi()，并将其绑定到 button 的 onClick 事件中。</p><p><a href="https://up.media.everdo.cn/image/JzY4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmi-onclick.png" alt="bmi-onclick.png"></a></p><p>我们把函数写完整：</p><pre><code class="java">public void btnCalBmi(View v){    //引用控件（定义两个变量）    EditText inHeight = findViewById(R.id.inputHeight);    EditText inWeight = findViewById(R.id.inputWeight);    TextView textBmi = findViewById(R.id.textBmi);    Double height = Double.parseDouble(inHeight.getText().toString());    Double weight = Double.parseDouble(inWeight.getText().toString());    //体质指数（BMI）=体重（kg）÷身高^2（m）    //最理想的体重指数是22， BMI指数为18.5～23.9时属正常，具体分类如下：    //过轻：低于18.5    //正常：18.5-23.9    //过重：24-27    //肥胖：28-32    //非常肥胖, 高于32    Double bmi = weight/Math.pow(height/100,2);    if(bmi&lt;18.5){        textBmi.setText(&quot;您的 MBI 为：&quot;+bmi+&quot; 您的体型为有一丢丢瘦&quot;);    }    else if(bmi&gt;=18.5&amp;&amp;bmi&lt;24){        textBmi.setText(&quot;您的 MBI 为：&quot;+bmi+&quot; 您的体型为正常体型&quot;);    }    else if(bmi&gt;=14&amp;&amp;bmi&lt;28){        textBmi.setText(&quot;您的 MBI 为：&quot;+bmi+&quot; 您的体型为微微发胖&quot;);    }    else if(bmi&gt;=18&amp;&amp;bmi&lt;32){        textBmi.setText(&quot;您的 MBI 为：&quot;+bmi+&quot; 您的体型为肥胖！！&quot;);    }    else{        textBmi.setText(&quot;您的 MBI 为：&quot;+bmi+&quot; 您简直是一个超级大胖次！&quot;);    }}</code></pre><p>这里补上一段使用事件监听的简单框架：</p><pre><code class="java">Button Cal = findViewById(R.id.buttonCal);Cal.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {    //之前函数 btnCalBmi(View v) 内的代码    }});</code></pre><blockquote><p>OnClickListener 会比直接绑定按钮事件拥有更好性能。</p></blockquote><p><a href="https://up.media.everdo.cn/image/Jfui" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmi-function.png" alt="bmi-function.png"></a></p><p>到这里，我们就可以运行程序了，输入我的身高 178.5CM 体重 53.gKG，点击计算按钮后获得我的 BMI 为 16.79 （好吧，我偏瘦了，要多吃肉肉 /dog</p><p><a href="https://up.media.everdo.cn/image/J0sM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmiRun.jpg" alt="bmiRun.jpg"></a></p><h3 id="CompoundButton（Button-子类）"><a href="#CompoundButton（Button-子类）" class="headerlink" title="CompoundButton（Button 子类）"></a>CompoundButton（Button 子类）</h3><h4 id="RadioButton（子类）"><a href="#RadioButton（子类）" class="headerlink" title="RadioButton（子类）"></a>RadioButton（子类）</h4><p>单项选择的实现，通过分组容器对 RadioButton 进行分组。</p><p>下面是上面 BMI计算器 案例的进阶：</p><p><a href="https://up.media.everdo.cn/image/Jvoa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/raido-group.png" alt="raido-group.png"></a></p><p>这里我们先创建 RadioGroup 组件，然后在 RadioGroup 中添加三个 RadioButton 按钮控件。</p><p>为了使选框进行横向排列，我们需要将 RadioGroup 的 orientation 设置为 horizontal。</p><p>我们在 btnCalBmi() 函数中新引入 RadioButton 控件。</p><pre><code class="java">RadioButton asia = findViewById(R.id.stdAsia);RadioButton who = findViewById(R.id.stdWho);RadioButton cn = findViewById(R.id.stdCn);</code></pre><p>使用 <strong><code>.isChecked()</code></strong> 方法来判断选框有没有选中。</p><p>改版后函数为：</p><pre><code class="java">public void btnCalBmi(View v){    //引用控件（定义两个变量）    EditText inHeight = findViewById(R.id.inputHeight);    EditText inWeight = findViewById(R.id.inputWeight);    RadioButton asia = findViewById(R.id.stdAsia);    RadioButton who = findViewById(R.id.stdWho);    RadioButton cn = findViewById(R.id.stdCn);    TextView textBmi = findViewById(R.id.textBmi);    Double height = Double.parseDouble(inHeight.getText().toString());    Double weight = Double.parseDouble(inWeight.getText().toString());    //计算    Double bmi = weight/Math.pow(height/100,2);    //判断选中    if(who.isChecked()){        //who标准    else if(asia.isChecked()){    //亚洲标准    }    else if(cn.isChecked()){    //中国标准    }    else{        textBmi.setText(&quot;请先选择一个标准！&quot;);    }}</code></pre><p>编写完成后，调试应用程序：</p><p><a href="https://up.media.everdo.cn/image/Jyks" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/04/bmi-plus.png" alt="bmi-plus.png"></a></p><p>这时候如果没有输入身高体重，APP会闪退，这里修复空指针闪退，并添加重置功能：</p><pre><code class="java">//空字符串问题修复if(TextUtils.isEmpty(inHeight.getText().toString())){    textBmi.setText(&quot;请输入身高！&quot;);}else if(TextUtils.isEmpty(inWeight.getText())){    textBmi.setText(&quot;请输入体重！&quot;);}else{    Double height = Double.parseDouble(inHeight.getText().toString());    Double weight = Double.parseDouble(inWeight.getText().toString());    calBmi(height,weight,textBmi);}</code></pre><pre><code class="java">//重置按钮点击事件Reset.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {    EditText inHeight = findViewById(R.id.inputHeight);    EditText inWeight = findViewById(R.id.inputWeight);    inHeight.setText(&quot;&quot;);    inWeight.setText(&quot;&quot;);    }});</code></pre><p><a href="https://up.media.everdo.cn/image/JTw3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/05/bmi_final.jpg" alt="bmi_final.jpg"></a></p><h4 id="CheckBox（子类）"><a href="#CheckBox（子类）" class="headerlink" title="CheckBox（子类）"></a>CheckBox（子类）</h4><p>用处：核选项的实现，多项选择的实现。</p><p>使用方法和 radioButton 相似。使用 <strong><code>.isChecked()</code></strong> 方法来判断选框有没有选中</p><h2 id="Toast-控件"><a href="#Toast-控件" class="headerlink" title="Toast 控件"></a>Toast 控件</h2><p>Toast 是消息提示控件，该控件用于弹出提示消息（小气泡），可设置弹出时间长度。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>makeText</td><td>定义消息内容</td></tr><tr><td>setGravity</td><td>设置布局位置（改变提示位置）</td></tr><tr><td>getView</td><td>获取Toast视图</td></tr><tr><td>show</td><td>显示</td></tr></tbody></table><h3 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h3><p>纯文字提示代码示例：</p><pre><code class="java">Toast.makeText(MainActivity.this,&quot;提示文字&quot;,Toast.LENGTH_SHORT).show();</code></pre><p>makeText 方法分别调用了三个参数，分别传入运行对象，显示内容，和停留时长</p><p>setGravity 方法并不直接返回 Toast 对象，所以没法使用链式方法。</p><pre><code class="java">Toast sg = Toast.makeText(MainActivity.this,&quot;请输入身高&quot;,Toast.LENGTH_SHORT);//使用setGravity() 方法设置设置 Toast 在屏幕上的位置，第一个参数设置重力位置，有 TOP. BOTTOM. START 和 END 等值，第二.三个参数用于水平和垂直方向上的偏移量sg.setGravity(Gravity.CENTER,0,0);sg.show();</code></pre><h3 id="图文样例"><a href="#图文样例" class="headerlink" title="图文样例"></a>图文样例</h3><p>getView 方法可以用来自定义带图片信息的提示：（进阶）</p><pre><code class="java">//新建 Toast 控件 zjToast zj = Toast.makeText(MainActivity.this,&quot;震惊 ！！&quot;,Toast.LENGTH_SHORT);//设置控件位置（底部向上偏移160dp）zj.setGravity(Gravity.BOTTOM,0,160);//使用 getView() 方法得到 Toast 的 ViewLinearLayout zjView = (LinearLayout)zj.getView();//创建一个 ImageViewImageView zjImg = new ImageView(getApplicationContext());//设置图像zjImg.setImageResource(R.drawable.zhenjing);//使用 LinearLayout.LayoutParams 方法设置图片大小和图片在 LinerLayout 里的位置LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(150,150);params.setMargins(0,30,0,-20);zjImg.setLayoutParams(params);//调整 Toast 的 View 的 LinerLayout 的内部布局zjView.setGravity(Gravity.CENTER);zjView.setOrientation(LinearLayout.VERTICAL);//图像添加到 zjView 里面，第二个参数决定了显示顺序（图片和文字的先后）zjView.addView(zjImg,0);//显示 Toastzj.show();</code></pre><p>上面的案例的最终效果是显示一个 Toast，其中第一行是一个震惊的可爱小图片，第二行是文字 “震惊 ！！”</p><p>我们把这段代码添加到我们在上一篇文章中的 BMI 计算器中，为大胖子加入震惊效果（dog</p><p><a href="https://up.media.everdo.cn/image/JSQ9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/05/bmi-addzj.png" alt="bmi-addzj.png"></a></p><h3 id="外挂布局文件（复杂-！）"><a href="#外挂布局文件（复杂-！）" class="headerlink" title="外挂布局文件（复杂 ！）"></a>外挂布局文件（复杂 ！）</h3><p>如果 Toast 的样式非常复杂，包含了一大堆奇形怪状的东西，可以为 Toast控件 单独建立一个 Layout.xml</p><ol><li>在 .res/layout 路径下，新建 toast_01.xml</li><li>把视图和控件摆放完毕</li><li>为控件设置独立 ID</li><li>在函数中调用布局<ul><li>将 Toast 实例化 <strong><code>Toast zj = Toast.makeText(MainActivity.this,&quot;震惊 ！！&quot;,Toast.LENGTH_SHORT);</code></strong></li><li>加载布局文件 <strong><code>View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.toast_01, null);</code></strong></li><li>修改布局内显示的元素（查找ID）<strong><code>TextView 随便写 = (TextView)view.findViewById(R.id.布局内元素ID);</code></strong></li></ul></li><li>Toast 关联我们创建的 View <strong><code>toast.setView(view);</code></strong></li><li>设置显示在屏幕中的位置 <strong><code>zj.setGravity(Gravity.CENTER, 0,0);</code></strong></li><li>显示 <strong><code>toast.show();</code></strong></li></ol><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS文档整理 01-快速入门</title>
      <link href="/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-01-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-01-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CSS（Cascading Style Sheet）称为层叠样式表，也可以称为CSS样式表或样式表，其文件扩展名为.css。CSS是用于增强或控制网页样式，并允许将样式信息与网页内容分离的一种标记性语言。</p><p>样式表定义如何显示 HTML 元素。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。</p><p>CSS 3 最大的优势是在后期维护中，如果一些外观样式需要修改，就只修改相应的代码即可。</p><h2 id="CSS-基础语法"><a href="#CSS-基础语法" class="headerlink" title="CSS 基础语法"></a>CSS 基础语法</h2><p>在前面介绍过，CSS样式表由若干条样式规则组成，这些样式规则可以应用到不同的元素或文档中来定义它们的显示效果。每一条样式规则由三部分构成：选择符（selector）、属性（property）和属性值（value）。其基本格式如下：</p><pre><code class="css">selector{    property:value;}</code></pre><p>selector 可以采用多种形式，可以为文档中的 HTML 标记（如 <code>&lt;body&gt;、&lt;table&gt;、&lt;p&gt;</code> 等），也可以是XML文档中的标记。</p><p>value 指定了属性的值。如果定义选择符的多个属性，则属性和属性值为一组，组与组之间用 “;” 隔开。</p><pre><code class="css">selector{    property1:value1;    property2:value2;    ……}</code></pre><h2 id="在-HTML5-中使用-CSS3"><a href="#在-HTML5-中使用-CSS3" class="headerlink" title="在 HTML5 中使用 CSS3"></a>在 HTML5 中使用 CSS3</h2><p>CSS 样式表能很好地控制页面显示，分离网页内容和样式代码，它控制 HTML5 页面效果的方式通常包括行内样式、内嵌样式、链接样式和导入样式。</p><h3 id="行内样式（内联样式）"><a href="#行内样式（内联样式）" class="headerlink" title="行内样式（内联样式）"></a>行内样式（内联样式）</h3><p>行内样式是所有样式中比较简单、直观的方法，它可以直接把 CSS 代码添加到HTML文件中，是作为 HTML 的标记属性存在的。通过这种方法，可以很简单地对某个元素单独定义样式。</p><p>使用行内样式方法直接在 HTML 标记中使用 style 属性，该属性的内容就是 CSS 的属性和值。例如：</p><blockquote><p>提示：如果值为若干单词，则要给值加引号：</p></blockquote><pre><code class="html">&lt;p style=&quot;color:red&quot;&gt;段落样式&lt;/p&gt;</code></pre><p>下面是两个具体的行内样式案例：</p><pre><code class="html">&lt;p style=&quot;color:red;font-size:20px;text-decoration:underline;text-align:center&quot;&gt;此段落使用行内样式修饰&lt;/p&gt;&lt;p style=&quot;color:blue;font-style:italic&quot;&gt;正文内容&lt;/p&gt;</code></pre><p style="color:red;font-size:20px;text-decoration:underline;text-align:center">此段落使用行内样式修饰</p><p style="color:#00f;font-style:italic">正文内容</p><p>可以看到两个p标记中都使用了style属性，并且设置了CSS样式，各个样式之间互不影响，分别显示自己的样式效果。第一个段落为红色字体，居中显示且带有下画线；第二个段落为蓝色字体，并以斜体显示。</p><p>尽管行内样式简单，但这种方法并不常用，因为这样添加无法完全发挥样式表 “内容结构和样式控制代码分离” 的优势，而且这种方式也不利于样式的重用。如果为每一个标记都设置 style 属性，那么后期维护成本会过高，网页也容易过胖，故不推荐使用。</p><h3 id="内嵌样式（内部样式表）"><a href="#内嵌样式（内部样式表）" class="headerlink" title="内嵌样式（内部样式表）"></a>内嵌样式（内部样式表）</h3><p>内嵌样式就是将CSS样式代码添加到 <code>&lt;head&gt;与&lt;/head&gt;</code> 之间，并且用 <code>&lt;style&gt;和&lt;/style&gt;</code> 标记进行声明。这种写法虽然没有实现页面内容和样式控制代码完全分离，但可以用于设置一些比较简单且需要样式统一的页面。</p><p>格式如下：</p><pre><code class="html">&lt;head&gt;    &lt;style&gt;        p{            color:red;            font-size:12px;        }    &lt;/style&gt;&lt;/head&gt;</code></pre><blockquote><p>TIPS: 有些较低版本的浏览器不识别 <code>&lt;style&gt;</code> 标记，不能将样式正确地应用到页面显示上，而是直接将标记中的内容以文本的形式显示。为了解决此类问题，可以使用 HMTL 注释将标记中的内容隐藏。如果浏览器能够识别 <code>&lt;style&gt;</code> 标记，则标记内被注释的 CSS 样式定义代码依旧能够发挥作用。</p></blockquote><h3 id="链接样式（外部样式表）"><a href="#链接样式（外部样式表）" class="headerlink" title="链接样式（外部样式表）"></a>链接样式（外部样式表）</h3><p>链接样式是 CSS 中使用频率最高，也是最实用的方法。它可以很好地将 “页面内容” 和 “样式风格代码” 分离成两个文件或多个文件，实现了页面框架 HTML 代码和 CSS 代码的完成分离。</p><p>基本语法如下：</p><pre><code class="html">&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; /&gt;&lt;/head&gt;</code></pre><p>（1）rel 表示链接到样式表，其值为 stylesheet。（2）type 表示样式表类型为 CSS 样式表。（3）href 指定了CSS样式表文件的路径。</p><blockquote><p>在设计整个网站时，为了实现相同的样式风格，可以将同一个 CSS 文件链接到所有的页面中。如果整个网站需要修改样式，则只修改 CSS 文件即可。</p></blockquote><h3 id="导入样式（-import方法）"><a href="#导入样式（-import方法）" class="headerlink" title="导入样式（@import方法）"></a>导入样式（@import方法）</h3><p>导入样式和链接样式基本相同，都需要创建一个单独的 CSS 文件，然后将其引入到 HTML 文件中，只不过语法和运作方式有所差别。采用导入样式是在 HTML 文件初始化时，会被导入到 HTML 文件内作为文件的一部分，类似于内嵌效果。而链接样式则是在 HTML 标记需要样式风格时才以链接方式引入。</p><p>基本代码如下：</p><pre><code class="html">&lt;style&gt;  &lt;!--    @import &quot;1.css&quot;    @import &quot;2.css&quot;  --&gt;&lt;/style&gt;</code></pre><p>导入外部样式表相当于将样式表导入到内嵌样式表中，其中 @import 必须在样式表的开始部分（即位于其他样式表代码的上面）。</p><h3 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h3><p>当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？</p><p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 5 拥有最高的优先权。</p><ol><li>浏览器缺省设置</li><li>导入样式（@import）</li><li>外部样式表</li><li>内部样式表（位于 <code>&lt;head&gt;</code> 标签内部）</li><li>内联样式（在 HTML 元素内部）</li></ol><p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明：<code>&lt;head&gt;</code> 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</p><h2 id="CSS3-选择器"><a href="#CSS3-选择器" class="headerlink" title="CSS3 选择器"></a>CSS3 选择器</h2><p>根据 CSS 选择器用途可以把选择器分为标记选择器、类选择器、全局选择器、ID选择器和伪类选择器等。</p><h3 id="标记选择器"><a href="#标记选择器" class="headerlink" title="标记选择器"></a>标记选择器</h3><p>基本语法如下：</p><pre><code class="css">tagName{    property:value;}</code></pre><p>其中 tagName 表示标记名称，如 p、h1 等HTML标记；property 表示CSS3属性；value 表示 CSS3 属性值。</p><p>通过声明一个具体标记，可以对文档里这个标记出现的每一个地方应用样式定义，<strong>这种做法通常用在设置整个网站都会出现的基本样式。</strong></p><p>下面是一个设置全局默认字体的例子：</p><pre><code class="css">body,p,td,th,div,blockquote,dl,ul,ol{    font-family: Tahome, Verdana, Arial, Helvetica, sans-serif;    font-size: 1em;    color: #000000;}</code></pre><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>使用标记选择器可以控制该页面中所有相关标记的显示样式，如果需要对其中一系列标记重新设置，此时仅使用标记选择器是远远不够的，还需要使用类选择器。</p><p>常用的语法格式如下：</p><pre><code class="css">.classValue{    property:value;}</code></pre><p>classValue 是选择器的名称，具体名称由 CSS 制定者自己命名。如果一个标记具有 class 属性且 class 属性值为 classValue，那么该标记的呈现样式由该选择器指定。在定义类选择符时，需要在 classValue 前面加一个句点 “.”。</p><p>下面是一个具体案例：</p><pre><code class="html">&lt;style&gt;.aa{   color:blue;   font-size:20px;}&lt;/style&gt;&lt;p class=&quot;aa&quot;&gt;此处使用类选择器aa控制段落样式&lt;/p&gt;</code></pre><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>ID 选择器和类选择器类似，都是针对特定属性的属性值进行匹配的。ID 选择器定义的是某一个特定的 HTML 标记，一个网页文件中只能有一个标记使用某一 ID 的属性值。</p><p>定义ID选择器的基本语法格式如下：</p><pre><code class="css">#idValue{    property:value;}</code></pre><p>在正常情况下，id 属性值在文档中具有唯一性。在定义 ID 选择器时，需要在 idValue 前面加一个 “#” 符号。</p><blockquote><p>1）类选择器可以给任意数量的标记定义样式，但ID选择器在页面的标记中只能使用一次。</p><p>2）ID选择器比类选择器具有更高的优先级，即当ID选择器与类选择器发生冲突时，优先使用ID选择器定义的样式。</p></blockquote><p>由于 JavaScript 等脚本语言也能调用 HTML 中设置的 id，因此 ID 选择器一直被广泛使用。网页设计者在编写 HTML 代码时应该养成一个习惯，一个 id 只赋予一个 HTML 标记。</p><h3 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h3><p>如果想要一个页面中所有 HTML 标记使用同一种样式，就可以使用全局选择器。全局选择器，顾名思义就是对所有 HTML 标记起作用。其语法格式如下：</p><pre><code class="css">*{    property:value;}</code></pre><p>其中，“ * ” 表示对所有标记起作用。</p><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>将多种选择器进行搭配，可以构成一种复合选择器，也称为组合选择器，即将标记选择器、类选择器和 ID 选择器组合起来使用。</p><p>一般的组合方式是标记选择器和类选择器组合或标记选择器和ID选择器组合：</p><pre><code class="css">tagNme.classValue{property:value;}</code></pre><p>使用案例：</p><pre><code class="html">&lt;style&gt;p.firstPar{  color:blue}.firstPar{  color:green}&lt;/style&gt;&lt;p class=&quot;firstPar&quot;&gt;此处使用组合选择器&lt;/p&gt;&lt;h1 class=&quot;firstPar&quot;&gt;我是一个标题&lt;/h1&gt;</code></pre><style>p.firstPar{color:#00f}.firstPar{color:green}</style><p class="firstPar">此处使用组合选择器</p><span class="firstPar">我是一个标题</span><h3 id="继承选择器"><a href="#继承选择器" class="headerlink" title="继承选择器"></a>继承选择器</h3><p>继承选择器的规则是：子标记在没有定义的情况下所有的样式是继承父标记的；当子标记重新定义父标记已经定义过的声明时，子标记会执行后面的声明，其中与父标记不冲突的地方仍然沿用父标记的声明。</p><p>具体格式：</p><pre><code class="css">外层 内层 最内层{    property:value;} </code></pre><p>例如：</p><pre><code class="html">&lt;style&gt;#red p{    color:red;}&lt;/style&gt;&lt;div id=&quot;red&quot;&gt;    &lt;p&gt;hello&lt;/p&gt;    &lt;span&gt;hello&lt;hello&gt;&lt;/div&gt;</code></pre><style>#red p{color:red}</style><div id="red"><p>hello</p><span>hello<hello></hello></span></div><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类也是选择器的一种，但是用伪类定义的 CSS 样式并不是作用在标记上的，而是作用在标记的状态上。</p><p>其中有一组伪类是主流浏览器都支持的，就是超链接的伪类，包括 :link、:vistited、:hover和:active。</p><p>伪类选择器定义的样式经常应用在标记<a>上，它表示超链接4种不同的状态，即未访问超链接（link）、已访问超链接（visited）、鼠标停留在超链接上（hover）和激活超链接（active）。</a></p><p>示例代码：</p><pre><code class="html">&lt;style&gt;a:link {color: red}        /* 未访问的链接 */a:visited {color: green}    /* 已访问的链接 */a:hover {color:blue}    /* 鼠标移动到链接上 */a:active {color: orange}    /* 选定的链接 */&lt;/style&gt;&lt;a href=&quot;&quot;&gt;空的&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;锚点链接&lt;/a&gt;&lt;a href=&quot;https://coding.emptinessboy.com&quot;&gt;搜狐&lt;/a&gt;</code></pre><style>.a a:link{color:red}.a a:visited{color:green}.a a:hover{color:#00f}.a a:active{color:orange}</style><div class="a"><a href="">空的</a> <a href="#">锚点链接</a> <a href="https://coding.emptinessboy.com">URL</a></div><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>属性选择器根据某个属性是否存在属性值来寻找元素，因此能够实现某些非常有意思和强大的效果。</p><p>现在的CSS3标准共有7个属性选择器，它们共同构成了CSS功能强大的标记属性过滤体系。</p><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>[attribute]</td><td>用于选取带有指定属性的元素。</td></tr><tr><td>[attribute=value]</td><td>用于选取带有指定属性和值的元素。</td></tr><tr><td>[attribute~=value]</td><td>用于选取属性值中包含指定词汇的元素。</td></tr><tr><td>[attribute|=value]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td></tr><tr><td>[attribute^=value]</td><td>匹配属性值以指定值开头的每个元素。</td></tr><tr><td>[attribute$=value]</td><td>匹配属性值以指定值结尾的每个元素。</td></tr><tr><td>[attribute*=value]</td><td>匹配属性值中包含指定值的每个元素。</td></tr></tbody></table><p>下面是一个实际案例：</p><pre><code class="css">[align]{color:red}[align=&quot;left&quot;]{font-size:20px;font-weight:bolder;}[lang^=&quot;en&quot;]{color:blue;text-decoration:underline;}[src$=&quot;gif&quot;]{border-width:5px;boder-color:#ff9900}</code></pre><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><p>结构伪类选择器（Structural pseudo-classes）是 CSS3 新增的类型选择器。顾名思义，结构伪类就是利用文档结构树（DOM）实现元素过滤。也就是说，通过文档结构的相互关系来匹配特定的元素，从而减少文档内对class属性和id属性的定义，使得文档更加简洁。</p><h4 id="选择器第一类："><a href="#选择器第一类：" class="headerlink" title="选择器第一类："></a>选择器第一类：</h4><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child</td><td>选择父元素的第一个子元素</td></tr><tr><td>E:last-child</td><td>选择父元素的最后一个子元素</td></tr><tr><td>E:nth-child(n)</td><td>选择父元素下的第n个元素或奇偶元素，n的值为 “数字 | odd | even”</td></tr><tr><td>E:only-child</td><td>选择父元素中唯一的子元素（该父元素只有一个子元素）</td></tr></tbody></table><p>下面是具体案例：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;*{padding:0;margin:0;}ul{    display:inline-block;    width:200px;    list-style-type:none;}ul li{    height:20px;}ul li:first-child{background-color:red;}ul li:nth-child(2){background-color:orange;}ul li:nth-child(3){background-color:yellow;}ul li:nth-child(4){background-color:green;}ul li:last-child{background-color:blue;}&lt;/style&gt;&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><style type="text/css">.demo *{padding:0;margin:0}.demo ul{display:inline-block;width:200px;list-style-type:none}.demo ul li{height:20px}.demo ul li:first-child{background-color:red}.demo ul li:nth-child(2){background-color:orange}.demo ul li:nth-child(3){background-color:#ff0}.demo ul li:nth-child(4){background-color:green}.demo ul li:last-child{background-color:#00f}</style><div class="demo"><ul><li></li><li></li><li></li><li></li><li></li></ul></div><h4 id="隔行换色（no-js）"><a href="#隔行换色（no-js）" class="headerlink" title="隔行换色（no-js）"></a>隔行换色（no-js）</h4><pre><code class="css">ul li{    height:20px;    background-color:green;}/*设置偶数列颜色*/ul li:nth-child(even){    background-color:red;}</code></pre><style>.demo2 *{padding:0;margin:0}.demo2 ul{display:inline-block;width:200px;list-style-type:none}.demo2 ul li{height:20px;background-color:green}.demo2 ul li:nth-child(even){background-color:red}</style><div class="demo2"><ul><li></li><li></li><li></li><li></li><li></li></ul></div><h4 id="选择器第二类："><a href="#选择器第二类：" class="headerlink" title="选择器第二类："></a>选择器第二类：</h4><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>:first-of-type</td><td>选择同元素类型的第 1 个同级兄弟元素</td></tr><tr><td>:last-of-type</td><td>选择同元素类型的最后 1 个同级兄弟元素</td></tr><tr><td>:nth-of-type（n）</td><td>匹配同元素类型的第 n 个同级兄弟元素，n 的值为“数字 | odd | even”</td></tr><tr><td>:only-of-type</td><td>匹配父元素中特定类型的唯一子元素（该父元素可以有多个子元素）</td></tr></tbody></table><p>案例：</p><pre><code class="html">&lt;div&gt;    &lt;h1&gt;&lt;/h1&gt;    &lt;p&gt;&lt;/p&gt;    &lt;span&gt;&lt;/span&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;h1:first-child  选择的是 h1 元素，因为 h1 元素是 div 的第1个子元素。p:first-child   选择不到任何元素，因为 p 并不是 div 的第1个子元素，而是 div 的第2个子元素。h1: first-of-type   选择的是 h1 元素，因为 h1 元素是 div 中所有 h1 元素中的第1个 h1 元素，事实上也只有一个为 h1 的子元素；p: first-of-type    选择的是 p 元素，因为 p 元素是 div 中所有 p 元素中的第1个 p 元素，事实上也只有一个为 p 的子元素；</code></pre><h4 id="选择器第三类："><a href="#选择器第三类：" class="headerlink" title="选择器第三类："></a>选择器第三类：</h4><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>:root</td><td>选择文档的根元素。在HTML中，根元素永远是HTML</td></tr><tr><td>:not()</td><td>选择某个元素之外的所有元素</td></tr><tr><td>:empty</td><td>选择一个不包含任何子元素或内容的元素</td></tr><tr><td>:target</td><td>选取页面中的某个target元素</td></tr></tbody></table><h3 id="UI元素状态伪类选择器"><a href="#UI元素状态伪类选择器" class="headerlink" title="UI元素状态伪类选择器"></a>UI元素状态伪类选择器</h3><p>UI 元素的状态一般包括 可用、不可用、选中、未选中、获取焦点、失去焦点、锁定、待机等。CSS3定义了3种常用的状态伪类选择器：</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:enabled</td><td>选择E元素中所有“可用”元素</td></tr><tr><td>E:disabled</td><td>选择E元素中所有“不可用”元素</td></tr><tr><td>E:checked</td><td>选择E元素中所有被选中的元素</td></tr><tr><td>E:focus</td><td>指定元素获得光标焦点时使用的样式</td></tr><tr><td>E::selection</td><td>改变E元素中被选择的网页文本的显示效果</td></tr><tr><td>E:read-write</td><td>选择E元素中所有“可读写”元素</td></tr><tr><td>E:read-only</td><td>选择E元素中所有“只读”元素</td></tr><tr><td>E::before</td><td>在E元素之前插入内容</td></tr><tr><td>E::after</td><td>在E元素之后插入内容</td></tr></tbody></table><h4 id="enabled-与-disabled选择器"><a href="#enabled-与-disabled选择器" class="headerlink" title=":enabled 与 :disabled选择器"></a>:enabled 与 :disabled选择器</h4><p>在 Web 表单中，有些表单元素（如输入框、密码框、复选框等）有 “可用” 和 “不可用” 这2种状态。默认情况下，这些表单元素都处在可用状态。</p><p>下面是一段示例代码：</p><pre><code class="html">&lt;style&gt;.demo5 input:enabled {    border:1px dotted #666;    background:#ff9900;}input:disabled {    border:1px dotted #999;    background:#F2F2F2;}&lt;/style&gt;&lt;form class=&quot;demo5&quot; method=&quot;post&quot; action=&quot;&quot;&gt;用户名：&lt;input type=text name=name&gt;&lt;br&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=password name=pass disabled=&quot;disabled&quot;&gt;&lt;br&gt;&lt;/form&gt;</code></pre><style>.demo5 input:enabled{border:1px dotted #666;background:#f90}input:disabled{border:1px dotted #999;background:#F2F2F2}</style><form class="demo5" method="post" action="">用户名： <input type="text" name="name"><br>密&nbsp;&nbsp;&nbsp;&nbsp;码： <input type="password" name="pass" disabled><br></form><h4 id="focus-选择器"><a href="#focus-选择器" class="headerlink" title=":focus 选择器"></a>:focus 选择器</h4><p>下面是一段示例代码：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;input:focus{    outline:1px solid red;}&lt;/style&gt;&lt;p&gt;&lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;label for=&quot;email&quot;&gt;邮箱：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot;/&gt;&lt;/p&gt;</code></pre><style type="text/css">.demo3 input:focus{outline:3px solid red}</style><div class="demo3"><p><label for="name">姓名：</label><input type="text" name="name"></p><p><label for="email">邮箱：</label><input type="text" name="email"></p></div><p>:focus 选择器被用来指定 “表单元素” 获得光标焦点时使用的样式，主要在单行文本框 text、多行文本框 textarea 等表单元素获得焦点并输入文本时使用。</p><p>一般情况下，获取焦点和失去焦点是针对单行文本框 text、多行文本框 textarea 这2个表单元素而言。</p><h4 id="selection-选择器"><a href="#selection-选择器" class="headerlink" title="::selection 选择器"></a>::selection 选择器</h4><p>::selection 选择器，默认情况下，浏览器中用鼠标选择的网页文本都是 “深蓝的背景，白色的字体” 显示的。但是有些时候我们并不想要 “深蓝的背景，白色的字体” 这种显示效果。</p><p>下面是一段示例代码：</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;div::selection{    background-color:orange;    color:white;}&lt;/style&gt;&lt;div&gt;    &lt;div&gt;Hello，I am EmptinessBoy&lt;/div&gt;&lt;/div&gt;</code></pre><style type="text/css">.demo4 div::selection{background-color:orange;color:#fff}.demo4 span::selection{background-color:green;color:#fff}</style><div class="demo4"><p>Hello，I am EmptinessBoy（正常）</p><div>Hello，I am EmptinessBoy（橙）</div><span>Hello，He is 隔壁老王（被绿了）</span></div><h4 id="before-和-after选择器"><a href="#before-和-after选择器" class="headerlink" title="::before 和 ::after选择器"></a>::before 和 ::after选择器</h4><p>在 CSS3 中，我们可以使用 ::before 和 ::after 这两个选择器在元素前面或后面添加内容。这两个选择器常和 “content属性” 配合使用，使用的场景最多的就是清除浮动和创建小图标。</p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    p::before{content: &quot;隔壁老王&quot;;}    p::after{content: &quot;被绿了&quot;;color: green;}&lt;/style&gt;&lt;p&gt;有一天&lt;/p&gt;</code></pre><style type="text/css">.demo6 p::before{content:"隔壁老王"}.demo6 p::after{content:"被绿了";color:green}</style><span class="demo6"><p>有一天</p></span><h3 id="选择器声明"><a href="#选择器声明" class="headerlink" title="选择器声明"></a>选择器声明</h3><p>使用 CSS 选择器可以控制 HTML 标记样式，其中每个选择器属性可以一次声明多个，即创建多个 CSS 属性修饰 HTML 标记。实际上也可以将选择器声明多个，并且任何形式的选择器（如标记选择器、class类别选择器、ID选择器等）都是合法的。</p><h4 id="集体声明"><a href="#集体声明" class="headerlink" title="集体声明"></a>集体声明</h4><p>集体声明就是在声明各种CSS选择器时，如果某些选择器的风格是完全相同的或者部分相同，可以将风格相同的CSS选择器同时声明。</p><p>格式参考如下：</p><pre><code class="css">h1,h2,p {    color:red;              }</code></pre><h4 id="多重嵌套声明"><a href="#多重嵌套声明" class="headerlink" title="多重嵌套声明"></a>多重嵌套声明</h4><p>参见：<a href="http://localhost:40006/2020/04/CSS%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-01-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#%E7%BB%A7%E6%89%BF%E9%80%89%E6%8B%A9%E5%99%A8" target="_blank" rel="noopener">继承选择器</a></p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS:"></a>TIPS:</h2><h3 id="统一字体大小"><a href="#统一字体大小" class="headerlink" title="统一字体大小"></a>统一字体大小</h3><p>使用 font-size:14px 定义的宋体文字，在IE下实际高是16像素，下空白是3像素，Firefox 浏览器下实际高是17像素、上空1像素、下空3像素。</p><blockquote><p>其解决办法是在文字定义上设置 line-height，并确保所有文字都有默认的 line-height 值。</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> CSS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 项目视图导览和IED基本入门</title>
      <link href="/2020/04/Android-%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E5%AF%BC%E8%A7%88%E5%92%8CIED%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
      <url>/2020/04/Android-%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E5%AF%BC%E8%A7%88%E5%92%8CIED%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>Android Studio 包含用于构建 Android 应用所需的所有工具</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>Android Studio 提供了多种项目管理视图，项目窗口在 Gradle 同步完成后，默认显示的是 Android 视图</p><p><a href="https://up.media.everdo.cn/image/HlDM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/Android.jpg" alt="Android.jpg"></a></p><p>在点击切换按钮后，我们可以切换到 Project 项目视图获得更细致的内容：</p><p><a href="https://up.media.everdo.cn/image/HufY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/project.png" alt="project.png"></a></p><p>App目录展开细节如下：</p><p><a href="https://up.media.everdo.cn/image/J45a" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/app.png" alt="app.png"></a></p><h2 id="app-build-gradle文件"><a href="#app-build-gradle文件" class="headerlink" title="app/build.gradle文件"></a>app/build.gradle文件</h2><p>不用于 Eclipse，Android Studio 是采用 Gradle 来构建项目的。Gradle 是一个非常先进的项目构建工具，它使用了一种基于 Groovy 的领域特定语言（DSL）来声明项目设置，摒弃了传统基于 XML（如Ant和Maven）的各种繁琐的配置。</p><p>项目中有两个 build.gradle 文件，一个是在最外层目录下的，一个是在 app 目录下的。这两个文件对构建 Android Studio 项目都起到了至关重要的作用。</p><p>下面是 HELLO WORLD 项目下的内层APP目录下的 build.gradle文件：</p><pre><code class="json">apply plugin: &#39;com.android.application&#39;android {    compileSdkVersion 29    buildToolsVersion &quot;29.0.3&quot;  //编程所用的 API 版本    defaultConfig {        applicationId &quot;com.emptinessboy.helloworld&quot; //应用程序包名        minSdkVersion 21    //最低兼容的 API 版本        targetSdkVersion 29 //面向的 API 版本        versionCode 1   //当前软件版本号        versionName &quot;1.0&quot;   //当前软件版本名        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            minifyEnabled false //是否在编译时混淆代码（发布用）            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;        }    }}dependencies {  //指明项目中的第三方函数库    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation &#39;androidx.appcompat:appcompat:1.0.2&#39;    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;    testImplementation &#39;junit:junit:4.12&#39;    androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39;    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;}</code></pre><p>对于项目 API 版本的设置，按照下面的原则是比较推荐的：</p><blockquote><p>ompileSdkVersion ≥ targetSdkVersion ≥ minSdkVersion</p></blockquote><h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><blockquote><p>详细文档： <a href="https://developer.android.com/guide/topics/manifest/manifest-intro" target="_blank" rel="noopener">https://developer.android.com/guide/topics/manifest/manifest-intro</a></p></blockquote><p>此文件位于 app\src\main\AndroidManifest.xml</p><p>AndroidManifest.xml 文件可以理解为 Android 整个应用程序的配置清单文件，用于向Android系统提供关于应用程序的配置信息。（包含： 包名、组件、权限等信息。）</p><p>下面是 HELLO WORLD 项目下的 AndroidManifest.xml 文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.emptinessboy.helloworld&quot;&gt;  &lt;!--项目的包名--&gt;    &lt;application        android:allowBackup=&quot;true&quot;  /*是否允许备份应用的数*/        android:icon=&quot;@mipmap/ic_launcher&quot;  /*图标（方形）*/        android:label=&quot;@string/app_name&quot;    /*应用程序标题*/        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;   /*图标（圆形）*/        android:supportsRtl=&quot;true&quot;  /*支持从右到左布局*/        android:theme=&quot;@style/AppTheme&quot;&gt;    /*主题界面风格*/        &lt;activity android:name=&quot;.MainActivity&quot;&gt;  &lt;!--组件声明--&gt;            &lt;intent-filter&gt;     &lt;!--过滤器--&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h3><p>Android 四大组件：</p><ul><li>Activity（活动） <code>&lt;activity android:name=&quot;&quot;&gt;......&lt;/activity&gt;</code></li><li>Service（服务） <code>&lt;service android:name=&quot;&quot;&gt;......&lt;/service&gt;</code></li><li>ContentProvider（内容提供者） <code>&lt;provider android:name= &quot;&quot;&gt;......&lt;/provider&gt;</code></li><li>BroadcastReceiver（广播接收者） <code>&lt;receiver android:name=&quot;&quot;&gt;......&lt;/receiver&gt;</code></li></ul><blockquote><p>注意：启动一个没有在AndroidManifest.xml文件中声明过的组件，会抛出异常</p></blockquote><h3 id="权限标签"><a href="#权限标签" class="headerlink" title="权限标签"></a>权限标签</h3><blockquote><p>具体文档： <a href="https://developer.android.com/reference/android/Manifest.permission" target="_blank" rel="noopener">https://developer.android.com/reference/android/Manifest.permission</a></p></blockquote><pre><code class="xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;package=&quot;com.emptinessboy.helloworld&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;/manifest&gt;</code></pre><h2 id="IED-相关"><a href="#IED-相关" class="headerlink" title="IED 相关"></a>IED 相关</h2><h3 id="配置自动包导入：（实用）"><a href="#配置自动包导入：（实用）" class="headerlink" title="配置自动包导入：（实用）"></a>配置自动包导入：（实用）</h3><p><a href="https://up.media.everdo.cn/image/JJjs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/androidstudio-auto-import.jpg" alt="androidstudio-auto-import.jpg"></a></p><h3 id="配置文件字符显示"><a href="#配置文件字符显示" class="headerlink" title="配置文件字符显示"></a>配置文件字符显示</h3><p><a href="https://up.media.everdo.cn/image/JPN3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/androidstudio-uft8.jpg" alt="androidstudio-uft8.jpg"></a></p><h3 id="日志工具使用"><a href="#日志工具使用" class="headerlink" title="日志工具使用"></a>日志工具使用</h3><p>Log 是 Android 提供的用来输出日志的工具类 (android.util.Log)</p><p>Log 常用的方法：</p><ol><li>Verbose：最为繁琐、意义最小的信息</li><li>Debug：调试信息</li><li>Info：比较重要的数据</li><li>Warn：警告信息</li><li>Error：错误信息</li></ol><p>通过 Logcat 监视器，查看 Android 应用运行时输出的日志信息：</p><p><a href="https://up.media.everdo.cn/image/JIpG" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/logcat.jpg" alt="logcat.jpg"></a></p><p>可以在上方导航栏切换当前调试设备，日志输出的应用，日志级别，也可以针对性过滤隐藏日志。</p><h3 id="调试程序时输出-log-到-logcat"><a href="#调试程序时输出-log-到-logcat" class="headerlink" title="调试程序时输出 log 到 logcat"></a>调试程序时输出 log 到 logcat</h3><p>这一步操作效果等同于 java 语言的 System.out.print();</p><pre><code class="java">import android.util.Log;    //导入log包public class MainActivity extends AppCompatActivity {    private static final String TAG = &quot;MainActivity&quot;;   //声明标签变量（常用类名）    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Log.d(TAG, &quot;onCreate: 已经在运行&quot;);    //使用log打印输出    }}</code></pre><p><a href="https://up.media.everdo.cn/image/JnI9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/logcat-logd.jpg" alt="logcat-logd.jpg"></a></p><p>当日志过多时，可以用在搜索框用 Tag 进行过滤（支持正则）。</p><h4 id="快速生成日志代码"><a href="#快速生成日志代码" class="headerlink" title="快速生成日志代码"></a>快速生成日志代码</h4><pre><code>logt 声明标签 \ logd 打印输出</code></pre><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="提示和生成代码"><a href="#提示和生成代码" class="headerlink" title="提示和生成代码"></a><strong>提示和生成代码</strong></h4><ul><li><strong>Ctrl + Alt+ Space</strong> 代码提示</li><li><strong>Ctrl + P</strong> 提示参数</li><li><strong>Ctrl + J</strong> 快捷代码提示</li><li><strong>Ctrl + Alt + T</strong> 为选择的代码，添加 if 、for、try/catch 等语句</li><li><strong>Alt + Insert</strong> 弹出自动生成代码对话框</li><li><strong>Ctrl + O</strong> 弹出类中可重写的方法对话框</li><li><strong>Alt + 回车</strong> 可以触发代码联想</li></ul><h4 id="编辑代码快捷键"><a href="#编辑代码快捷键" class="headerlink" title="编辑代码快捷键"></a><strong>编辑代码快捷键</strong></h4><ul><li><strong>Ctrl + Shift + Up/Down</strong> 移动当前行代码</li><li><strong>Ctrl + D</strong> 复制当前行代码到下行</li><li><strong>Ctrl + W</strong> 选中代码，连续按会有不同的选中效果</li><li><strong>Ctrl + Alt + L</strong> 代码格式化</li></ul><h4 id="替换和查找"><a href="#替换和查找" class="headerlink" title="替换和查找"></a><strong>替换和查找</strong></h4><ul><li><strong>Ctrl + F</strong> 查找</li><li><strong>Ctrl + R</strong> 替换</li></ul><h4 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a><strong>查看代码</strong></h4><ul><li><strong>Ctrl + N</strong> 输入类名，快速打开—个指定的类</li><li><strong>Ctrl + H</strong> 查看父类层级</li><li><strong>Ctrl + U</strong> 查看当前类的父类</li><li><strong>Ctrl + Alt + Left/Right</strong> 光标返回上—次停留的位置</li><li><strong>Alt + Up/Down</strong> 光标在类方法间快速移动</li><li><strong>Ctrl + “+”</strong> 光标所在方法展开</li><li><strong>Ctrl + “-“</strong> 光标所在方法折叠收起</li><li><strong>Ctrl + Shift + “+”</strong> 当前类所有方法展开</li><li><strong>Ctrl + Shift + “-“</strong> 当前类所有方法折叠收起</li><li><strong>Ctrl + Shift +［或</strong> 选择大括号间的全部代码</li><li><strong>Ctrl + Alt + H</strong> 查看—个方法被调用的位置</li></ul><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio 入门之环境搭建和第一个程序</title>
      <link href="/2020/04/Android-Studio-%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/Android-Studio-%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>前言：开发安卓项目有许多不同的方式，不同语言，不同IED。</p><ol><li>Google App Inventor</li><li>ADT Bundle （Eclipse）</li><li>Android Studio</li></ol><p>面向入门者的 App Inventor 是由 Google 开发的一款可视化的 Android 开发工具。不需要掌握高深的语言基础就可以简单实现基本的 App。对于传统或者标准的安卓开发则是基于 Java 和 Kotlin 语言。</p><p>ADT Bundle 是一个已经打包好的开发套件，包含了 Eclipse、ADT插件 和 SDK Tools，是已经集成好的 IDE，只需安装好 Jdk即可开始开发，不用再折腾开发环境。</p><p>最后在 Google 的开发文档中，推荐用 Android Studio，（对于新手而言不友好）。本篇文章就开始从 Android Studio 开始到第一个 HelloWorldApp，一点点踩坑并记录笔记。</p><h2 id="安装-JAVA-开发环境-JDK"><a href="#安装-JAVA-开发环境-JDK" class="headerlink" title="安装 JAVA 开发环境 JDK"></a>安装 JAVA 开发环境 JDK</h2><p>在之前的文章里已经很详细的记录了如何在 Windows 环境下安装配置 JDK 13。可以参考下面的链接：</p><ul><li><a href="https://coding.emptinessboy.com/2020/02/JAVA%E5%AD%A6%E4%B9%A0%E4%B9%8BJDK%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">JAVA入坑之 JDK环境安装到 HelloWorld</a></li></ul><p>当然，Android 不需要那么高的 JDK 版本，常用的 1.8 就够用。</p><h2 id="下载-Android-Studio"><a href="#下载-Android-Studio" class="headerlink" title="下载 Android Studio"></a>下载 Android Studio</h2><p>在 Google 的安卓开发者官网，可以很轻松的下载到 Android Studio （不需要翻’wall） 而且速度很快。</p><ul><li><a href="https://developer.android.com/studio" target="_blank" rel="noopener">https://developer.android.com/studio</a></li></ul><p>这里直接下载默认的 exe 可执行文件就可以了。</p><p><a href="https://up.media.everdo.cn/image/HmM6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/androidstudio.jpg" alt="androidstudio.jpg"></a></p><p>下载完成后，直接双击运行。</p><h2 id="安装汉化-Android-Studio"><a href="#安装汉化-Android-Studio" class="headerlink" title="安装汉化 Android Studio"></a>安装汉化 Android Studio</h2><p>安装 Android Studio 的过程和我们安装其他软件没有太多的不同：在看到安装向导的时候一路 Next 就可以了。</p><p><a href="https://up.media.everdo.cn/image/HcAS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/AndroidStudio_1.jpg" alt="AndroidStudio_1.jpg"></a></p><p>选择标准一般不会出什么问题</p><p><a href="https://up.media.everdo.cn/image/HfcQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/AndroidStudio_2.jpg" alt="AndroidStudio_2.jpg"></a></p><p>选择主题（Android Studio 的 ui 非常棒，个人比较喜欢暗色）：</p><p><a href="https://up.media.everdo.cn/image/Hs5J" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/AndroidStudio_3.jpg" alt="AndroidStudio_3.jpg"></a></p><p>在下面系统会自动从网络下载所需要的包并自动完成安装。</p><h3 id="中文语言包"><a href="#中文语言包" class="headerlink" title="中文语言包"></a>中文语言包</h3><p>下载地址：<a href="https://github.com/pingfangx/TranslatorX" target="_blank" rel="noopener">来自pingfangX大佬</a> <a href="https://github.com/pingfangx/jetbrains-in-chinese/tree/master/AndroidStudio" target="_blank" rel="noopener">DriLink</a></p><p>下载汉化语言包 resources_zh_CN_AndroidStudio_3.5_r1.jar，</p><p>将 resources_zh_CN_<em>.jar ，放到 AndroidStudio 的 *</em>安装路径** 下的 <strong>lib</strong> 目录中，重启软件即可。</p><h2 id="启动并下载-SDK："><a href="#启动并下载-SDK：" class="headerlink" title="启动并下载 SDK："></a>启动并下载 SDK：</h2><p>安装完成后，双击桌面的 Android Studio 图标就可以启动了。</p><p>启动的第一步，就是安装我们所需要使用的安卓 SDK 版本，现在是 2020 年的 4 月，目前最新的 SDK 版本是 API-29 的 Android Q（安卓10）：</p><p><a href="https://up.media.everdo.cn/image/H16d" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/sdkmanager.jpg" alt="sdkmanager.jpg"></a></p><p>勾选完自己需要使用的 SDK 版本后，系统会自动进行下载和安装（如果因为网络原因失败，可以多尝试几次）。</p><h3 id="排错-01"><a href="#排错-01" class="headerlink" title="排错 01"></a>排错 01</h3><p>如果你和我一样，在第一次启动时遇到了下图那样的 Cannot lock system folder 的报错。</p><p><a href="https://up.media.everdo.cn/image/H9gn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/8634b7a20ac1f157b1833d4db5e15905.jpg" alt="8634b7a20ac1f157b1833d4db5e15905.jpg"></a></p><p>只需要在 PowerShell（管理员） 中执行一句命令然后重启电脑就可以了。</p><pre><code class="cmd">netsh winsock reset</code></pre><p><a href="https://up.media.everdo.cn/image/H0Ry" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/dc93347f197d483e08102401967cfecb.jpg" alt="dc93347f197d483e08102401967cfecb.jpg"></a></p><p>如果到这里，你和我后来遇到的一样，又出现这个问题了，恭喜你，下面的一定可以帮到你：</p><h4 id="4月6日补充："><a href="#4月6日补充：" class="headerlink" title="4月6日补充："></a><strong>4月6日补充：</strong></h4><p>在使用 Android Studio 几天后，发现经常性的还是会遇到这样的错误：</p><p><a href="https://up.media.everdo.cn/image/JtuO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/06/can-not-bind.jpg" alt="can-not-bind.jpg"></a></p><p>运行上面的重置 winsock 命令并重启后，马上运行 Android Studio 则正常，若等一段时间再运行开发工具就会弹出一样的错误。</p><p>开始的时候，以为是开发工具的 bug，在 百度 和 CSDN 下搜索也得不出有效答案。emm，开始想偷懒，打算就这么凑合用吧。可是当我打开 pyCharm 的时候，发现 IED 报了同样的错误。（这么多软件报错，那本宝宝不能忍呀！！</p><p>经过测试，发现在我的电脑上 JetBrains 家的全部软件均出现了这样的问题。更新 Android Studio 和 pyCharm 也还是问题复现。也考虑过会不会是 jdk 的问题，不过在进行更新 JDK 后发现问题依旧。</p><p>最后无比艰难的上 Google 一通搜索后，在 JetBrains 开发者社区找到了答案。下面让我借此做一个问题查找过程的回顾：</p><p>定位到我们启动 IED 时的报错：</p><pre><code class="java">nternal error. Please refer to https://code.google.com/p/android/issuesjava.util.concurrent.CompletionException: java.net.BindException: Address already in use: bind</code></pre><p>可以看到产生 winsock 报错的主要原因是 bind 失败了。</p><blockquote><p>来自论坛外国 dalao 的解释：</p><p>To lock folders IDE is starting a server on localhost, it tries to bind on the first available port between 6942 and 6991, this exception is thrown if IDE was not able to bind on any of the ports in this range. All 50 ports are unlikely to be already used on a machine, so it appears to be a networking issue or some security software which doesn’t permit IDE to bind on any port in this range even on localhost interface.</p></blockquote><p>看到这个我们就知道了，在 JetBrains 的 IED 启动的时候，会尝试监听 6942 到 6991 的任意端口。而现在我们遇到的情况是监听失败了。</p><p>而在这之前，我已经使用命令 <code>netstat -no | findstr</code> 排除了端口被占用的问题。根据老外的分析，则有可能是网络故障。</p><p>在继续搜索的时候，我看到 GitHub docker-for-win 下面的 issue 有人遇到和我一样的问题。</p><p><a href="https://github.com/docker/for-win/issues/3171" target="_blank" rel="noopener">https://github.com/docker/for-win/issues/3171</a></p><p>经过判断，初步定位问题可能是由 hyper-v 造成的，在使用命令 <code>dism.exe /Online /Disable-Feature:Microsoft-Hyper-V</code> 禁用 hyper-v 并重启后，一切都正常了！！</p><p>可是在我的笔记本电脑也启用了 hyper-v 服务，而且 Android Studio 在我的笔记本上，运行一切正常。（总不能简单粗暴阉 hyper-v 吧</p><p>继续浏览发现：出现这个问题的大多是在 Windows 开发者预览版系统上，而我，恰巧前阵子手贱，把系统升级到了预览版（手动狗头</p><p><a href="https://up.media.everdo.cn/image/JOY6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/07/yvlanban.jpg" alt="yvlanban.jpg"></a></p><p>那么为什么预览版系统的 hyper-v 会造成这个问题呢？其实这个并不是微软故意弄出来的 bug，而是预览版的 WSL （Windows下的Linux子系统）版本升级到了 WSL2。而 WSL2 是使用 hyper-v 运行 Linux 内核的。在 WSL2 上，hyperv 会将一些端口列入系统排除端口避免被其他进程使用。这就导致了明明端口没被占用却无法监听的问题了。</p><p>最后我是按照下面的解决方案解决的（来自 github @enashed）</p><blockquote><p>I ran <code>netsh int ipv4 show dynamicport tcp</code><br>Ran <code>netsh int ipv4 set dynamic tcp start=49152 num=1638</code> to reset it to something sane<br>Also ran <code>reg add HKLM\SYSTEM\CurrentControlSet\Services\hns\State /v EnableExcludedPortRange /d 0 /f</code> for good measure as netsh int ipv4 show excludedportrange protocol=tcp showed a lot of excluded ports</p></blockquote><p>在这样一波操作后，运行命令检查端口：</p><p><a href="https://up.media.everdo.cn/image/JUzn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/07/paichu-duankou.jpg" alt="paichu-duankou.jpg"></a></p><p>可以看到保留端口范围已经避开了 IED 使用的范围。添加的注册表项用于禁止 hyper-v 保留反射端口。</p><p>重启电脑，问题秒杀之。又可以开开心心撸代码了！！</p><p><em>其实，为了这个问题真的折腾了我一下午加一晚上。卸载杀毒软件，更新系统，升级IED，重置网络等等。。。原来到底还是 WSL 的锅。还是希望微软爸爸或者 JetBrains 哥哥可以体谅下我这样菜鸡的程序 <del>猿</del>，在后面的更新解决这个冲突（手动狗头。</em></p><p>参考文章： <a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004973960-Critical-Internal-Error-on-Startup-of-IntelliJ-IDEA-Cannot-Lock-System-Folders-" target="_blank" rel="noopener">01</a> / <a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206193909-Address-already-in-use" target="_blank" rel="noopener">02</a> / <a href="https://dandini.wordpress.com/tag/administered-port-exclusions/" target="_blank" rel="noopener">03</a></p><h2 id="AVD-虚拟机-和-环境变量"><a href="#AVD-虚拟机-和-环境变量" class="headerlink" title="AVD 虚拟机 和 环境变量"></a>AVD 虚拟机 和 环境变量</h2><p>下载完 SDK 后，我们还要为接下来的安卓项目调试做准备。要确保 AVD 虚拟机可以正常的工作。</p><p>点击 Configure ，进入 AVD manager。然后新建一个虚拟设备。在选择设备模板的页面我们可以根据需要选择安卓电视设备，手机，平板，可穿戴等等。</p><p><a href="https://up.media.everdo.cn/image/HMSl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/avd-select.jpg" alt="avd-select.jpg"></a></p><p>下一步，我们要为设备选择安卓的版本（SDK版本），然后系统会根据需要，下载系统镜像。</p><p><a href="https://up.media.everdo.cn/image/HyP0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/avd-selectimg.jpg" alt="avd-selectimg.jpg"></a></p><p>这里我已经下载好了安卓Q和安卓PIE两个镜像。准备完这一切，配置好具体参数，就可以正式启动模拟设备了。</p><p><a href="https://up.media.everdo.cn/image/HTiD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/acd-confirm.jpg" alt="acd-confirm.jpg"></a></p><p>这时，系统会在 “我的文档” 下的 .Android/AVD 里面存放虚拟系统的磁盘和系统配置文件。</p><p><a href="https://up.media.everdo.cn/image/HCgc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/avd-path.jpg" alt="avd-path.jpg"></a></p><p>最后，虚拟设备成功启动：</p><p><a href="https://up.media.everdo.cn/image/HXML" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/avd-success.jpg" alt="avd-success.jpg"></a></p><p>emm，AVD 系统自带 GooglePlay 全家桶，美妙又清新。（先上波 YouTube 看看 Tom &amp; Jerry</p><p><a href="https://up.media.everdo.cn/image/HtcZ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/avd-youtube.jpg" alt="avd-youtube.jpg"></a></p><h3 id="排错-02"><a href="#排错-02" class="headerlink" title="排错 02"></a>排错 02</h3><p>如果你又和我一样不幸，出现了下面这样令人尴尬的报错：</p><pre><code>Emulator: PANIC: Cannot find AVD system path. Please define ANDROID_SDK_ROOT或者：Broken AVD system path. Check your ANDROID_SDK_ROOT value</code></pre><p>这个问题多半出现在 Windows系统环境变量 上面，我这里所作的，就是删掉多余的无关变量，仅仅将 Android Home 指向 SDK 存放的路径。</p><p><a href="https://up.media.everdo.cn/image/HpD2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/windows-path.jpg" alt="windows-path.jpg"></a></p><h2 id="第一个安卓程序"><a href="#第一个安卓程序" class="headerlink" title="第一个安卓程序"></a>第一个安卓程序</h2><p>又到了令人兴奋的 Hello World 环节，不过好像又没那么容易，让我喝杯水冷静下。</p><h3 id="创建安卓项目"><a href="#创建安卓项目" class="headerlink" title="创建安卓项目"></a>创建安卓项目</h3><p>Hello World 大法的第一步当然是创建安卓项目了。点击加号 + Start a new Android Studio project</p><p>这里 Google 为我们提供了许多自带的 UI 模板，我们先选择最简单的 Empty Activity。</p><p><a href="https://up.media.everdo.cn/image/HUjB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/select-form.jpg" alt="select-form.jpg"></a></p><p>选择完成后，进入确认项目页面：</p><p><a href="https://up.media.everdo.cn/image/Hw5k" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/configure-project.jpg" alt="configure-project.jpg"></a></p><p>这里 Name 栏目表示应用程序名字，Package 包名一般是网址倒着写，因此这里包名就是 com.emptinessboy.com.helloworld</p><p>SelectLocation 栏目选择项目存放位置（实测存放在中文路径会报错）， Language 可以选择 Java 或者 kotlin。最小 SDK 选择兼容的最低安卓版本。</p><h3 id="进入编辑器"><a href="#进入编辑器" class="headerlink" title="进入编辑器"></a>进入编辑器</h3><p>如果一切顺利，（我是在经历99八十一难后），终于看到了 Android Studio 的编辑器：</p><p><a href="https://up.media.everdo.cn/image/HKII" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/into-editor.jpg" alt="into-editor.jpg"></a></p><p>可以看到 Android Studio 已经为控制布局的 activity_main.xml 自带了一个设计窗口，右边是自动打开的主函数文件 MainActivity.java</p><p>这里试着修改文字 HelloWorld,I am Emptiness Boy!</p><p><a href="https://up.media.everdo.cn/image/HLiX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/eitd-words.jpg" alt="eitd-words.jpg"></a></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h3><h4 id="模拟器调试"><a href="#模拟器调试" class="headerlink" title="模拟器调试"></a>模拟器调试</h4><p>然后点击绿色的运行按钮！</p><p><a href="https://up.media.everdo.cn/image/H8vi" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/android-helloworld.jpg" alt="android-helloworld.jpg"></a></p><p>可以看到 第一个HelloWorld应用 已经在模拟器中成功跑起来了。</p><h4 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h4><p>既然有模拟器了，为什么不试试物理机？果断抄起了我久经沙场的 OnePlus5，在手机上开启开发者模式后，投屏到电脑。</p><p><a href="https://up.media.everdo.cn/image/Hal4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/oneplus-helloworld.jpg" alt="oneplus-helloworld.jpg"></a></p><p>可以看到 AndroidStudio 已经成功识别我的手机，并通过 ADB 成功安装了 HelloWord 应用。</p><h3 id="排错-03"><a href="#排错-03" class="headerlink" title="排错 03"></a>排错 03</h3><p>今天真是运气太背了，已经是第三个坑了。在 Hello World 关键阶段出现的问题是 Gradle 一直在 sync ，并且好长时间后还是失败了。</p><p><a href="https://up.media.everdo.cn/image/HZ6t" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/Gradle-sync-fail.jpg" alt="Gradle-sync-fail.jpg"></a></p><p>一直以为是 qiang‘guo 的原因，所以折腾了好久路由器。可是最后却发现情况来的有点蹊跷。</p><p>经过一番检查，发现原来是 Gradle 下面的一个配置文件在做怂（果断抄起 notepad++ 干掉之）：</p><p><a href="https://up.media.everdo.cn/image/H5px" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/04/02/fix-gradle-sync.jpg" alt="fix-gradle-sync.jpg"></a></p><p>将里面的 HTTPproxy 都注释掉，再尝试重新 sync，问题解决之。</p><h3 id="排错-04"><a href="#排错-04" class="headerlink" title="排错 04"></a>排错 04</h3><p>这是今晚最后一个坑了。就是在调试时遇到的 Can’t bind to local 8600 for debugger 问题。</p><p>开始时查阅网上教程，以为是端口被其他程序占用的问题，如 Eclipse。可是通过命令行</p><pre><code class="cmd">netstat -aon|findstr 8600</code></pre><p>却一无所获，就更不要说什么 kill 掉占用进程了。</p><pre><code class="cmd">taskkill /pid ????-t -f</code></pre><p>最后惊讶的发现问题出在之前被我动过的系统 hosts，因为 hosts 里 localhost 栏被我注释掉了。因此 ADB 工具自然无法找到 localhost 的地址了。</p><p>打开 hosts 文件，补上下面一行</p><pre><code>127.0.0.1 localhost::1       localhost</code></pre><p>问题就这样消失了，WTF!!（小声BB</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 06事件处理</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-06%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-06%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>网页是由浏览器的内置对象组成的，如单选按钮、列表框、多选框等，事件是 JavaScript 与对象之间进行交互的桥梁，当某个事件发生时，通过它的处理函数执行相应的 JavaScript 代码，从而实现不同的功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>采用事件驱动是JavaScript 语言的一个最基本的特征。所谓的事件是指用户在访问页面时执行的操作。当浏览器探测到一个事件时，比如，单击鼠标或按键，它可以触发与这个事件相关联的 JavaScript 对象。</p><p>事件处理指的就是与事件关联的 JavaScript 对象，当与页面特定部分关联的事件发生时，事件处理器就会被调用。事件处理的过程通常分为三步，具体步骤如下：</p><ul><li>发生事件</li><li>启动事件处理程序</li><li>事件处理程序作出反应</li></ul><p>在上面的事件处理过程中，要想事件处理程序能够启动，必须调用事件处理程序。</p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>在 JavaScript 中，调用事件处理程序的方法有两种：</p><h3 id="JS-调用法"><a href="#JS-调用法" class="headerlink" title="JS 调用法"></a>JS 调用法</h3><p>在 JavaScript 中调用事件处理程序，首先需要获得处理对象的引用，然后将要执行的处理函数赋值给对应的事件。</p><p>下面是一个具体案例：</p><pre><code class="html">&lt;button id=&quot;but&quot;&gt;点击按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;var but = document.getElementById(&quot;but&quot;);but.onclick=function(){    alert(&quot;哼哼哼！&quot;);    }                    &lt;/script&gt;</code></pre><p><button id="but">点击按钮</button></p><script type="text/javascript">var but=document.getElementById("but");but.onclick=function(){alert("哼哼哼！")}</script><h3 id="HTML-调用法"><a href="#HTML-调用法" class="headerlink" title="HTML 调用法"></a>HTML 调用法</h3><p>在 HTML 中分配事件处理程序，只需要在 HTML 标记中添加相应的事件，并在其中执行要执行的代码或函数名即可</p><pre><code class="html">&lt;button onclick=&quot;alertHhh()&quot;&gt;点击按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;function alertHhh(){    alert(&quot;哼哼哼！&quot;);    }                    &lt;/script&gt;</code></pre><p><button onclick="alertHhh()">点击按钮</button></p><script type="text/javascript">function alertHhh(){alert("哼哼哼！")}</script><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>鼠标事件是指通过鼠标动作触发的事件，常用的如下：</p><table><thead><tr><th>事件</th><th>事件说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标单击时触发此事件</td></tr><tr><td>ondblcl1ck</td><td>鼠标双击时触发此事件</td></tr><tr><td>onmousedown</td><td>鼠标按下时触发此事件</td></tr><tr><td>onmouseup</td><td>鼠标弹起时触发此事件</td></tr><tr><td>onmouseover</td><td>鼠标移动到某个设置了此事件的元素上时触发此事件</td></tr><tr><td>onmousemove</td><td>鼠标移动时触发此事件</td></tr><tr><td>onmouseout</td><td>鼠标从某个设置了此事件的元素上离开时触发此事件</td></tr></tbody></table><p></p><div id="colorful" style="width:100px;height:50px;background-color:red"></div><p></p><script>var rect=document.getElementById("colorful");rect.onmousemove=function(){rect.style.backgroundColor="yellow"},rect.onmouseout=function(){rect.style.backgroundColor="green"},rect.onclick=function(){rect.style.backgroundColor="red"},rect.ondblclick=function(){rect.style.backgroundColor="purple"}</script><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>键盘事件是指通过键盘动作触发的事件，常用于检查用户向页面输入的内容。例如，用户在购物车输入商品数量时，可以使用 onkeyup 事件检查用户输入的数量信息是否合法。</p><table><thead><tr><th>事件</th><th>事件说明</th></tr></thead><tbody><tr><td>onkeydown</td><td>当键盘上的某个按键被按下时触发此事件</td></tr><tr><td>onkeyup</td><td>当键盘上的某个按键被按下后弹起时触发此事件</td></tr><tr><td>onkeypress</td><td>当输入有效的字符按键时触发此事件</td></tr></tbody></table><p>下面是一段校验键盘输入的示例代码：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;function checkNum(obj){     var num =  Number(obj.value);    //判断是否是数字    if(!num){        alert(&#39;请输入正确的数字&#39;);    }}&lt;/script&gt;&lt;div class=&quot;all&quot;&gt;    &lt;ul &gt;        &lt;li&gt;商品&lt;/li&gt;        &lt;li&gt;数量&lt;/li&gt;        &lt;li&gt;单位&lt;/li&gt;    &lt;/ul&gt;    &lt;ul&gt;        &lt;li&gt;图书&lt;/li&gt;        &lt;li&gt;&lt;input type=&quot;text&quot; id=&quot;num&quot; onkeyup=&quot;checkNum(this)&quot;&gt;&lt;/li&gt;        &lt;li&gt;册&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</code></pre><style type="text/css">.all{margin:20px auto!important;border:1px solid #000;background:#000;width:300px;height:100px;float:left}.all ul{height:50px;line-height:50px;padding:10px 0 10px 0!important;margin:0!important;list-style:none}.all li{text-align:center!important;float:left;width:30%}#num{width:50px}</style><script type="text/javascript">function checkNum(e){var u=Number(e.value);u||alert("请输入正确的数字")}</script><div class="all"><ul><li>商品</li><li>数量</li><li>单位</li></ul><ul><li>图书</li><li><input type="text" id="num" onkeyup="checkNum(this)"></li><li>册</li></ul></div><p style="clear:both"></p><h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><p>表单事件是指通过表单触发的事件。例如在用户注册的表单中可以通过表单事件完成用户名合法性检查、唯—性检查、用户密码合法性检查等。</p><table><thead><tr><th>事件</th><th>事件说明</th></tr></thead><tbody><tr><td>onblur</td><td>当前元素失去焦点时触发此事件</td></tr><tr><td>onchange</td><td>当前元素失去焦点并且元素内容发生改变时触发此事件</td></tr><tr><td>onfocus</td><td>当某个元素获得焦点时触发此事件</td></tr><tr><td>onreset</td><td>当表单被重置时触发此事件</td></tr><tr><td>onsubmit</td><td>当表单被提交时触发此事件</td></tr></tbody></table><p>下面是表单事件的示例代码：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    function txtfocus(obj){        obj.style.background=&quot;#ccc&quot;;    }    function txtblur(obj){        obj.style.background=&quot;&quot;;    }&lt;/script&gt;&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;用户名：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; onfocus=&quot;txtfocus(this)&quot; onBlur=&quot;txtblur(this)&quot;/&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;性别：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; onfocus=&quot;txtfocus(this)&quot; onBlur=&quot;txtblur(this)&quot;/&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;邮箱：&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; onfocus=&quot;txtfocus(this)&quot; onBlur=&quot;txtblur(this)&quot;/&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><script type="text/javascript">function txtfocus(c){c.style.background="#ccc"}function txtblur(c){c.style.background=""}</script><table><tr><td>用户名：</td><td><input type="text" onfocus="txtfocus(this)" onblur="txtblur(this)"></td></tr><tr><td>性别：</td><td><input type="text" onfocus="txtfocus(this)" onblur="txtblur(this)"></td></tr><tr><td>邮箱：</td><td><input type="text" onfocus="txtfocus(this)" onblur="txtblur(this)"></td></tr></table><p>上面的示例代码用于定义获取元素焦点后改变文本框的背景颜色，和失去焦点后文本框的背景颜色消失。</p><h2 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h2><p>页面事件是指通过页面触发的事件：</p><table><thead><tr><th>事件</th><th>事件说明</th></tr></thead><tbody><tr><td>onload</td><td>当页面加载完成时触发此事件</td></tr><tr><td>onunload</td><td>当页面卸载时触发此事件</td></tr></tbody></table><p>通常情况下，页面加载是从上到下依次进行的。那么如果JavaScript 脚本加载完成，并执行了一个方法，而该方法又操作了下面还未加载的某个元素对象，结果会导致报错。而使用 onload 方法可以很好解决这一点。</p><pre><code class="html">语法格式 A：&lt;script type=&quot;text/javascript&quot;&gt;function show(){    var con=document.getElementById(&#39;content&#39;)    alert(con.innerHTML);}window.onload=show;&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;hello&lt;/div&gt;</code></pre><pre><code class="html">语法格式 B：&lt;script type=&quot;text/javascript&quot;&gt;window.onload=function show(){    var con=document.getElementById(&#39;content&#39;)    alert(con.innerHTML);}&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;hello&lt;/div&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 05BOM与DOM对象</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-05BOM%E4%B8%8EDOM%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-05BOM%E4%B8%8EDOM%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>BOM 对象包括 window (窗口）、navigator (浏览器程序）、screen (屏幕）、location (地址）、history (历史）和 document (文档）等对象，<strong>主要用于操纵浏览器窗口的行为和特征。</strong></p><p>DOM 是处理 HTML 文档的标准技术，允许 JavaScript 程序动态访问、更新浏览页面的内容、结构和样式。</p><h2 id="BOM-对象"><a href="#BOM-对象" class="headerlink" title="BOM 对象"></a>BOM 对象</h2><p>浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。</p><p>其中 window 对象是浏览器的窗口，它是整个BOM 的核心，位于BOM 对象的最顶层。</p><p><a href="https://up.media.everdo.cn/image/HNPj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/30/window.jpg" alt="window.jpg"></a></p><h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><p>window 对象表示整个浏览器窗口，用千获取浏览器窗口的大小、位置，或设置定时器等。</p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>document 、history 、location 、navigator 、screen</td><td>返回相应对象的引用。例如 document 展性返回 document 对象的引用</td></tr><tr><td>parent 、self 、top</td><td>分别返回父窗口、当前窗口和最顶层窗口的对象引用</td></tr><tr><td>screen Left 、screenTop 、screenX 、screenY</td><td>返回窗口的左上角在屏幕上的 X 、Y 坐标。FireFox 不支持 screenLeft 、screenTop, IE8 及更早的IE 版本不支待 screenX 、screenY</td></tr><tr><td>innerWidth 、innerHeight</td><td>分别返回窗口的文档显示区域的宽度和高度</td></tr><tr><td>outerWidth 、outerHeight</td><td>分别返回窗口的外部宽度和高度</td></tr><tr><td>closed</td><td>返回窗口是否已被关闭</td></tr><tr><td>opener</td><td>返回对创建此窗口的面口引用</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>open()、close()</td><td>打开或关闭浏览器窗口</td></tr><tr><td>alert()、confirm() 、prompt()</td><td>分别表示弹出警告框、确认框、用户输入框</td></tr><tr><td>moveBy() 、moveTo()</td><td>以窗口左上角为基准移动窗口， moveBy() 是按偏移量移动， moveTo() 是移动到指定的屏幕坐标</td></tr><tr><td>scrollBy()、scrollTo()</td><td>scrollBy() 是按偏移量滚动内容，scrollTo() 是滚动到指定的坐标</td></tr><tr><td>setTimeout()、clearTimeout()</td><td>设置或清除普通定时器</td></tr><tr><td>setlnterval()、clearlnterval()</td><td>设嚣或清除周期定时器</td></tr></tbody></table><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><blockquote><p>因为 window 对象是最顶层的对象，所以调用它的属性或方法时可以省略 window 。</p></blockquote><pre><code class="html">&lt;button onclick=&quot;getSize()&quot;&gt;点我获取窗口尺寸&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getSize(){    var width = window.innerWidth;     //获取文档显示区域宽度    var height = innerHeight;          //获取文档显示区域高度（省略window）    window.alert(width+&quot;*&quot;+height);       //调用alert输出}&lt;/script&gt;</code></pre><p><button onclick="getSize()">点我获取窗口尺寸</button></p><script type="text/javascript">function getSize(){var i=window.innerWidth,n=innerHeight;window.alert(i+"*"+n)}</script><h4 id="打开和关闭窗口"><a href="#打开和关闭窗口" class="headerlink" title="打开和关闭窗口"></a>打开和关闭窗口</h4><p>window.open() 方法用于打开新窗口， window.close() 方法用于关闭窗口。其中打开的子窗口可以单独设置如下的属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>窗口的宽度</td></tr><tr><td>height</td><td>窗口的高度</td></tr><tr><td>scrollbars</td><td>是否显示滚动条，默认为yes</td></tr><tr><td>resizable</td><td>是否可洞节窗口大小，默认为yes</td></tr><tr><td>titlebar</td><td>是否显示标题栏，默认为yes</td></tr><tr><td>location</td><td>是否显示地址栏，默认为yes</td></tr><tr><td>menubar</td><td>是否显示菜单栏，默认为yes</td></tr><tr><td>toolbar</td><td>是否显示工具栏，默认为yes</td></tr><tr><td>status</td><td>是否显示状态栏，默认为yes</td></tr></tbody></table><p>下面是一个具体案例：</p><pre><code class="html">&lt;script language=&quot;javascript&quot;&gt;var myWindow;function openNewWin(){    //打开一个窗口    myWindow=window.open(&quot;https://huxiaofan.com/about/&quot;,&quot;myWindow&quot;,&quot;width=800,height=450,top=200,left=100&quot;);}function closeNewWin(){    //关闭一个窗口    myWindow.close();}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;javascript:openNewWin()&quot;&gt;点我打开新窗口&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;javascript:closeNewWin()&quot;&gt;点我关闭新窗口&lt;/a&gt;&lt;/p&gt;</code></pre><script language="javascript">function openNewWin(){myWindow=window.open("https://huxiaofan.com/about/","myWindow","width=800,height=450,top=200,left=100")}function closeNewWin(){myWindow.close()}var myWindow</script><body><p><a href="javascript:openNewWin()">点我打开新窗口</a></p><p><a href="javascript:closeNewWin()">点我关闭新窗口</a></p><h4 id="两种定时器使用"><a href="#两种定时器使用" class="headerlink" title="两种定时器使用"></a>两种定时器使用</h4><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h5><p>setTimeout() 定时器可以实现延时操作，即延时一段时间后执行指定的代码。其基本语法如下：</p><pre><code class="javascript">setTimeout(被执行的函数名, 毫秒) ;</code></pre><p>下面是一个具体案例：</p><pre><code class="html">&lt;button onclick=&quot;out()&quot;&gt;点我后等待三秒&lt;/button&gt;&lt;script&gt;function show(){alert(&quot;2.5 秒已经过去了&quot;);}function out(){    setTimeout(show, 2500);//2.5 秒后调用show 函数}&lt;/script&gt;</code></pre><p><button onclick="out()">点我后等待三秒</button></p><script>function show(){alert("2.5 秒已经过去了")}function out(){setTimeout(show,2500)}</script><p>当需要清除定时器时，可以使用 clearTimeout() 方法：</p><pre><code class="html">&lt;button onclick=&quot;clearTimeOutDemo()&quot;&gt;清除定时器示例代码&lt;/button&gt;&lt;script&gt;function showA () {alert( &quot; 定时器A &quot;);}function showB() {alert( &quot; 定时器B &quot;);}function clearTimeOutDemo(){    var t1 = setTimeout (showA, 2000 ); //设置定时器t1, 2 秒后调用showA 函数    var t2 = setTimeout (showB, 2000) ; //设置定时器t2 , 2 秒后调用showB 函数    clearTimeout(t1);}&lt;/script&gt;</code></pre><p><button onclick="clearTimeOutDemo()">清除定时器示例代码</button></p><script>function showA(){alert(" 定时器A ")}function showB(){alert(" 定时器B ")}function clearTimeOutDemo(){var e=setTimeout(showA,2e3);setTimeout(showB,2e3);clearTimeout(e)}</script><p>上述代码清除了 t1 定时器，所以只会执行 showB() 的代码。</p><h5 id="setlnterval"><a href="#setlnterval" class="headerlink" title="setlnterval()"></a>setlnterval()</h5><p>setlnterval() 定时器用于周期性执行脚本， 即每隔一段时间执行指定的代码，通常用于在网<br>页上显示时钟、实现网页动画、制作漂浮广告等。需要注意的是，如果不使用 clearInterval() 清<br>除定时器， 该方法会一直循环执行，直到页面关闭为止。</p><p>下面是一个具体案例：</p><pre><code class="html">&lt;script language=&quot;javascript&quot;&gt;function showTime(){    var now=new Date();    var dataTime=now.toLocaleTimeString();    time=document.getElementById(&quot;time&quot;);    time.innerHTML=dataTime;}var timer=window.setInterval(&quot;showTime()&quot;,1000);function clear(){    window.clearInterval(timer);    window.status=&quot;已取消定时器&quot;;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;time&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;javascript:clear()&quot;&gt;取消定时器&lt;/a&gt;&lt;/p&gt;</code></pre><script language="javascript">function showTime(){var e=new Date,t=e.toLocaleTimeString();time=document.getElementById("time"),time.innerHTML=t}function clear(){window.clearInterval(timer),window.status="已取消定时器"}var timer=window.setInterval("showTime()",1e3)</script><body><div id="time"></div><p><a href="javascript:clear()">取消定时器</a></p><h3 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h3><p>screen 对象用于获取用户计算机的屏幕信息，例如屏幕分辨率、颜色位数等。screen 对象的常用属性如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>width 、height</td><td>屏幕的宽度和高度</td></tr><tr><td>availWidth 、availHeight</td><td>屏幕的可用宽度和可用高度（不包括Windows 任务栏）</td></tr><tr><td>colorDepth</td><td>屏幕的颜色位数</td></tr></tbody></table><pre><code class="html">&lt;button onclick=&quot;isHdScreen()&quot;&gt;检测一下你的屏幕&lt;/button&gt;&lt;script&gt;function isHdScreen(){    //获取屏幕分辨率    var width= screen.width;    var height= screen.height;    //判断屏幕分辨率    if (width&lt;1920 || height&lt;1080)        alert(&quot;您的屏幕分辨率不足1920*1080, 不是高清屏幕&quot;);    else        alert(&quot;恭喜你的屏幕是分辨率大于等于 1080P 的高清屏幕&quot;);}&lt;/script&gt;</code></pre><script>function isHdScreen(){var e=screen.width,r=screen.height;1920>e||1080>r?alert("您的屏幕分辨率不足1920*1080, 不是高清屏幕"):alert("恭喜你的屏幕是分辨率大于等于 1080P 的高清屏幕")}</script><p><button onclick="isHdScreen()">检测一下你的屏幕</button> 尝试调整系统分辨率，看看是否有弹窗（嘻嘻</p><h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>location 对象用千获取和设置当前网页的URL 地址，其常用的属性和方法如下：</p><table><thead><tr><th>属性 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>获取或设置 URL 中的描点， 例如 “#top”</td></tr><tr><td>host</td><td>获取或设置 URL 中的主机名，例如 “itcast.cn”</td></tr><tr><td>port</td><td>获取或设嚣 URL 中的端口号，例如 “80”</td></tr><tr><td>href</td><td>获取或设置整个 URL, 例如 “<a href="https://coding.emptinessboy.com/&quot;">https://coding.emptinessboy.com/&quot;</a></td></tr><tr><td>pathname</td><td>获取或设置 URL 的路径部分，例如 “/2020/03/JS简单入门-05BOM与DOM对象/“</td></tr><tr><td>protocol</td><td>获取或设置 URL 的协议，例如 “http:”</td></tr><tr><td>search</td><td>获取或设置 URL 地址中的GET 请求部分，例如 “?name=EmptinessBoy&amp;age=19”</td></tr><tr><td>reload()</td><td>重新加载当前文档</td></tr></tbody></table><h4 id="·-跳转到新地址"><a href="#·-跳转到新地址" class="headerlink" title="· 跳转到新地址"></a>· 跳转到新地址</h4><pre><code class="javascript">location.href = &quot;https://coding.emptinessboy.com/&quot;;</code></pre><h4 id="·-进入到指定的描点"><a href="#·-进入到指定的描点" class="headerlink" title="· 进入到指定的描点"></a>· 进入到指定的描点</h4><pre><code class="javascript">location.hash= &quot;#属性和方法&quot;;</code></pre><p><button onclick='location.hash="#属性和方法"'>点我跳转锚点</button></p><h4 id="·-检测协议并提示用户"><a href="#·-检测协议并提示用户" class="headerlink" title="· 检测协议并提示用户"></a>· 检测协议并提示用户</h4><pre><code class="javascript">if (location.protocol == &quot;http:&quot;) {    if (confirm(&quot;您在使用不安全的 http 协议，是否切换到更安全的 https 协议?&quot;)) {        location.href = &quot;https://coding.emptinessboy.com/&quot;;    }}</code></pre><script>"http:"==location.protocol&&confirm("您在使用不安全的 http 协议，是否切换到更安全的 https 协议?")&&(location.href="https://coding.emptinessboy.com/")</script><p>上述代码实现了当页面打开后自动判断当前的协议。当用户以 http 协议访问时，会弹出一<br>个提示框提醒用户是否切换到 https 协议。</p><h4 id="·-history-对象"><a href="#·-history-对象" class="headerlink" title="· history 对象"></a>· history 对象</h4><p>history 对象最初的设计和浏览器的历史记录有关，但出于隐私方面的考虑，该对象不再被<br>允许获取用户访问过的 URL 历史。history 对象主要的作用是控制浏览器的前进和后退.</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>back()</td><td>加载历史记录中的前—个 URL （相当于后退）</td></tr><tr><td>forward()</td><td>加载历史记录中的后一个 URL （相当于前进）</td></tr><tr><td>go()</td><td>加载历史记录中的某个页面</td></tr></tbody></table><p>下面是一段示例代码：</p><pre><code class="html">&lt;button onclick=&quot;history.back()&quot;&gt;后退&lt;/button&gt;&lt;button onclick=&quot;history.go(-1)&quot;&gt;后退1页&lt;/button&gt;&lt;button onclick=&quot;history.forward()&quot;&gt;前进&lt;/button&gt;&lt;button onclick=&quot;history.go(1)&quot;&gt;前进1页&lt;/button&gt;&lt;button onclick=&quot;history.go(0)&quot;&gt;重新载入页面&lt;/button&gt;</code></pre><p><button onclick="history.back()">后退</button> <button onclick="history.go(-1)">后退1页</button> <button onclick="history.forward()">前进</button> <button onclick="history.go(1)">前进1页</button> <button onclick="history.go(0)">重新载入页面</button></p><blockquote><p>上述代码实现了浏览器前进与后退的控制。其中， history.go(-1) 与 history.back() 的作用相<br>同， history.go(1) 与 history.forward() 的作用相同。</p></blockquote><h3 id="document-对象"><a href="#document-对象" class="headerlink" title="document 对象"></a>document 对象</h3><blockquote><p>document 对象和 下面要展开的 DOM 对象是一回事（小声</p></blockquote><p>document 对象用于处理网页文档，通过该对象可以访问文档中所有的元素。document 对象的常用属性和方法。</p><table><thead><tr><th>属性／方法</th><th>说明</th></tr></thead><tbody><tr><td>body</td><td>访问<body>元素</body></td></tr><tr><td>lastModified</td><td>获得文档最后修改的日期和时间</td></tr><tr><td>referrer</td><td>获得该文档的来路 URL 地址，当文档通过超链接被访问时有效</td></tr><tr><td>title</td><td>获得当前文档的标题</td></tr><tr><td>write()</td><td>向文档写 HTML 或 JavaScript 代码</td></tr></tbody></table><p>在使用时，通过“document” 或“window . document” 即可表示该对</p><h2 id="DOM-对象"><a href="#DOM-对象" class="headerlink" title="DOM 对象"></a>DOM 对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。</p><p>DOM ( Document Object Model) 被称为文档对象模型，是一个表示和处理文档的应用程序接口(API ) ，可用千动态访问、更新文档的内容、结构和样式。DOM 将网页中文档的对象关系规划为节点层级，构成它们之间的等级关系，这种各对象间的层次结构被称为节点树：</p><p><a href="https://up.media.everdo.cn/image/HkeO" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/30/dom.jpg" alt="dom.jpg"></a></p><ul><li>每个节点树有—个根节点</li><li>除了根节点，每个节点都有一个父节点</li><li>每个节点都可以有许多的子节点</li><li>具有相同父节点的节点叫做 “兄弟节点”</li></ul><h3 id="节点的访问"><a href="#节点的访问" class="headerlink" title="节点的访问"></a>节点的访问</h3><p>在 DOM 中，每个节点都是—个对象，因此每个节点对象都具有一系列的属性、方法。JavaScript 通过使用节点的属性和方法可以访问指定元素和相关元素，从而得到文档中的各个元素对象。</p><h4 id="·-访问指定元素"><a href="#·-访问指定元素" class="headerlink" title="· 访问指定元素"></a>· 访问指定元素</h4><p>一个元素对象可以拥有元素节点、文本节点、子节点或其他类型的节点</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>open()</td><td>打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。</td></tr><tr><td>close()</td><td>关闭用 document.open() 方法打开的输出流，并显示选定的数据。</td></tr><tr><td>write()</td><td>向文档写 HTML 表达式 或 JavaScript 代码。</td></tr><tr><td>writeln()</td><td>等同于 write() 方法，不同的是在每个表达式之后写一个换行符。</td></tr><tr><td>getElementById()</td><td>返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td>getElementsByName()</td><td>返回带有指定名称的对象集合。</td></tr><tr><td>getElementsByTagName()</td><td>返回带有指定标签名的对象集合。</td></tr><tr><td>getElementsByClassName()</td><td>获取指定 class 的元素对象集合</td></tr></tbody></table><p>下面是一个访问元素的具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;function init(){    var one = document.getElementById(&quot;one&quot;);  //找到&lt;li id=&quot;one&quot;&gt;的元素    one.style.fontWeight = &quot;bold&quot;;   //将文本加粗    var lis = document.getElementsByTagName(&quot;li&quot;);  //找到所有li元素    lis[3].style.color = &quot;#8a2be2&quot;;   //将第四个li元素的字体颜色设置为 #8a2be2}&lt;/script&gt;&lt;body onload=&quot;init()&quot;&gt; &lt;!-- nload事件在页面或图像加载完成之后立即执行 --&gt;     &lt;ul&gt;         &lt;li id=&quot;one&quot;&gt;标题一&lt;/li&gt;         &lt;li id=&quot;two&quot;&gt;标题二&lt;/li&gt;         &lt;li id=&quot;three&quot;&gt;标题三&lt;/li&gt;         &lt;li id=&quot;four&quot;&gt;标题四&lt;/li&gt;     &lt;/ul&gt;&lt;/body&gt;</code></pre><script type="text/javascript">function init(){var e=document.getElementById("one");e.style.fontWeight="bold";var t=document.getElementById("uu").getElementsByTagName("li");t[3].style.color="#8a2be2"}</script><body onload="init()"><ul id="uu"><li id="one">标题一</li><li id="two">标题二</li><li id="three">标题三</li><li id="four">标题四</li></ul></body><h4 id="·-访问关联元素"><a href="#·-访问关联元素" class="headerlink" title="· 访问关联元素"></a>· 访问关联元素</h4><p>引用完成—个页面元素对象后，可以使用DOM 节点对象的 parentNode 、child Nodes 、firstChild 、lastChild 、previousSibling 或 nextS灿ng 属性访问相对于该页面元素的父、子或兄弟元素。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>parentNode</td><td>元素节点的父节点</td></tr><tr><td>childNodes</td><td>元素节点的子节点数组</td></tr><tr><td>firstChild</td><td>第一个子节点</td></tr><tr><td>lastChild</td><td>最后—个子节点</td></tr><tr><td>previousSibling</td><td>前一个兄弟节点</td></tr><tr><td>nextSibiling</td><td>后一个兄弟节点</td></tr></tbody></table><pre><code class="html">示例代码：&lt;script type=&quot;text/javascript&quot;&gt;function init2(){     var a = document.getElementById(&quot;bdy&quot;); //找到&lt;body&gt;元素     a = a.firstChild; //找到&lt;ul&gt;元素     a = a.childNodes[0]; //找到第一个&lt;li&gt;元素     a.style.color = &quot;red&quot;; //将字体颜色设为红色}&lt;/script&gt;&lt;div id=&quot;bdy&quot;&gt;&lt;ul&gt;&lt;li id=&quot;one&quot;&gt;标题一&lt;/li&gt;&lt;li id=&quot;two&quot;&gt;标题二&lt;/li&gt;&lt;li id=&quot;three&quot;&gt;标题三&lt;/li&gt;&lt;li id=&quot;four&quot;&gt;标题四&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;button onClick=&quot;init2()&quot;&gt;测试！&lt;/button&gt;</code></pre><script type="text/javascript">function init2(){var d=document.getElementById("bdy");d=d.firstChild,d=d.childNodes[0],d.style.color="red"}</script><div id="bdy"><ul><li id="one">标题一</li><li id="two">标题二</li><li id="three">标题三</li><li id="four">标题四</li></ul></div><p><button onclick="init2()">测试！</button></p><blockquote><p>需要注意的是，不同浏览器在对待元素标记之间的空白字符和换行符上有区别，一般浏览器会将它们当作文本节点，而 IE6 至 IE8 浏览器则会忽略。</p></blockquote><h3 id="元素对象常用操作"><a href="#元素对象常用操作" class="headerlink" title="元素对象常用操作"></a>元素对象常用操作</h3><p>由于 HTML DOM 将 HTML 文档表示为一棵 DOM 对象树，每个节点对象表示文档的特定部分，因此通过修改这些对象，就可以动态改变页面元素的属性。</p><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>createElement()</td><td>创建元素节点</td></tr><tr><td>createTextNode()</td><td>创建文本节点</td></tr></tbody></table><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>appendChild()</td><td>为当前节点增加一个子节点（作为最后一个子节点）</td></tr><tr><td>insertBefore()</td><td>为当前节点增加一个子节点（插入指定子节点之前）</td></tr><tr><td>removeChild()</td><td>删除当前节点的某个子节点</td></tr></tbody></table><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><pre><code class="html">&lt;p id=&quot;jdcz&quot;&gt;嘿嘿嘿&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;function init3(){    var text = document.createTextNode(&quot;I am EmptinessBoy！&quot;); //创建一个文本节点     var p = document.createElement(&quot;p&quot;); //创建一个&lt;p&gt;元素节点     p.appendChild(text); //为&lt;p&gt;元素追加文本节点     document.getElementById(&quot;jdcz&quot;).appendChild(p); //为&lt;p&gt;追加&lt;p&gt;元素}&lt;/script&gt;&lt;button onClick=&quot;init3()&quot;&gt;测试！&lt;/button&gt;</code></pre><p id="jdcz">嘿嘿嘿</p><script type="text/javascript">function init3(){var e=document.createTextNode("I am EmptinessBoy！"),t=document.createElement("p");t.appendChild(e),document.getElementById("jdcz").appendChild(t)}</script><button onclick="init3()">测试！</button><br><br><h3 id="元素属性与内容操作（高频）"><a href="#元素属性与内容操作（高频）" class="headerlink" title="元素属性与内容操作（高频）"></a>元素属性与内容操作（高频）</h3><p><strong>元素和样式：</strong></p><table><thead><tr><th>属性／方法</th><th>说明</th></tr></thead><tbody><tr><td>innerHTML</td><td>获取或设置元素的 HTML 内容</td></tr><tr><td>className</td><td>获取或设置元素的 class 屈性</td></tr><tr><td>style</td><td>获取或设置元素的 style 样式属性</td></tr></tbody></table><p><strong>关于位置：</strong></p><table><thead><tr><th>属性／方法</th><th>说明</th></tr></thead><tbody><tr><td>offsetWidth 、offsetHeight</td><td>获取或设嚣元素的宽和高（不含滚动条）</td></tr><tr><td>scrollWidth 、scrollHeight</td><td>获取或设置元素完整的宽和高（含滚动条）</td></tr><tr><td>offsetTop 、offsetLeft</td><td>获取或设嚣包含滚动条，距离上或左边滚动过的距离</td></tr><tr><td>scrollTop 、scrollLeft</td><td>获取或设置元素在网页中的坐标</td></tr></tbody></table><p><strong>内容操作：</strong></p><table><thead><tr><th>属性／方法</th><th>说明</th></tr></thead><tbody><tr><td>getAttribute()</td><td>获得元素指定属性的值</td></tr><tr><td>setAttribute()</td><td>为元素设驾新的属性</td></tr><tr><td>removeAttnbute()</td><td>为元素删除指定的属性</td></tr></tbody></table><p>下面是一个简单的 Demo：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;function init4() {     var test = document.getElementById(&quot;test&quot;);  //获取test元素对象     test.innerHTML = &quot;&lt;p&gt;I am EmptinessBoy&lt;/p&gt;&quot;;  //元素内容操作     test.setAttribute(&quot;style&quot;,&quot;color:red;font-weight:bold;font-size:18px;&quot;);  //设置元素的属性     test.className=&quot;top&quot;;}&lt;/script&gt;&lt;/head&gt;&lt;button onClick=&quot;init4()&quot;&gt;测试&lt;/button&gt;&lt;div id=&quot;test&quot; style=&quot;color:blue;&quot;&gt;嘿嘿嘿&lt;/div&gt;</code></pre><script type="text/javascript">function init4(){var t=document.getElementById("test");t.innerHTML="<p>I am EmptinessBoy</p>",t.setAttribute("style","color:red;font-weight:bold;font-size:18px;"),t.className="top"}</script><button onclick="init4()">测试</button><div id="test" style="color:#00f">嘿嘿嘿</div><br><h4 id="元素样式操作"><a href="#元素样式操作" class="headerlink" title="元素样式操作"></a>元素样式操作</h4><p>在操作元素属性时， style 属性可以修改元素的样式， className 属性可以修改元素的类名，<br>通过这两种方法即可完成元素的样式操作。</p><h5 id="className-操作元素类名"><a href="#className-操作元素类名" class="headerlink" title="className 操作元素类名"></a>className 操作元素类名</h5><pre><code class="html">使用改变 class 属性改变样式&lt;style type=&quot;text/css&quot;&gt;.textA{color:green;}.textB{color:blue;} /*定义两组样式用于切换*/&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;function init5() {     var test = document.getElementById(&quot;test1&quot;);  //获取test1元素对象     test.className = &quot;textB&quot;;  //切换类名}&lt;/script&gt;&lt;button onClick=&quot;init5()&quot;&gt;测试&lt;/button&gt;&lt;div id=&quot;test1&quot; class=&quot;textA&quot;&gt;I am EmptinessBoy&lt;/div&gt;</code></pre><style type="text/css">.textA{color:green}.textB{color:#00f}</style><script type="text/javascript">function init5(){var t=document.getElementById("test1");t.className="textB"}</script><p><button onclick="init5()">测试</button></p><div id="test1" class="textA">I am EmptinessBoy</div><br><h5 id="直接修改-style-属性"><a href="#直接修改-style-属性" class="headerlink" title="直接修改 style 属性"></a>直接修改 style 属性</h5><pre><code class="html">直接修改 style 属性&lt;script type=&quot;text/javascript&quot;&gt;function init6() {     var test = document.getElementById(&quot;test2&quot;);  //获取test1元素对象     test.style.color = &quot;#FFF&quot;;  //切换类名}&lt;/script&gt;&lt;button onClick=&quot;init6()&quot;&gt;测试&lt;/button&gt;&lt;div id=&quot;test2&quot; style=&quot;color:blue&quot;&gt;I am EmptinessBoy&lt;/div&gt;</code></pre><script type="text/javascript">function init6(){var t=document.getElementById("test2");t.style.color="#FFF"}</script><p><button onclick="init6()">测试</button></p><div id="test2" style="color:#00f">I am EmptinessBoy</div><br><h2 id="性能优化！！"><a href="#性能优化！！" class="headerlink" title="性能优化！！"></a>性能优化！！</h2><p>减少 DOM 访问：</p><blockquote><p>与其他 JavaScript 相比，访问 HTML DOM 非常缓慢。</p></blockquote><p>假如您期望访问某个 DOM 元素若干次，那么只访问一次，并把它作为本地变量来使用：</p><pre><code class="javascript">var obj;obj = document.getElementById(&quot;demo&quot;);obj.innerHTML = &quot;Hello&quot;;</code></pre><p>缩减 DOM 规模：</p><blockquote><p>请尽量保持 HTML DOM 中较少的元素数量。</p></blockquote><p>这么做总是会提高页面加载，并加快渲染（页面显示），尤其是在较小的设备上。</p><p>每一次试图搜索 DOM（比如 getElementsByTagName）都将受益于一个较小的 DOM。</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"></body></body><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 04面向对象的操作</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>在JavaScript 中“一切皆对象”，如字符串、数值、函数、数组等都是对象， JavaScript提供了自定义对象和内置对象。</p><h2 id="对象概述"><a href="#对象概述" class="headerlink" title="对象概述"></a>对象概述</h2><p>例如， 一个用户可以被看作一个对象，它包含用户名、用户密码等特性，也包含注册、注销等动作。一个Web 页可以看做—个对象，它包含背景色、段落文本、标题等特性，同时又包含打开、关闭和写入等动作。<strong><em>简单来讲，对象就是一组属性与方法的集合。</em></strong></p><h3 id="对象的属性和方法"><a href="#对象的属性和方法" class="headerlink" title="对象的属性和方法"></a>对象的属性和方法</h3><p>在 JavaScript 中，对象包含 <strong>属性</strong> 和 <strong>方法</strong> 两个要素。属性是作为对象成员的变量，表明对象的状态；而方法是作为对象成员的函数，表明对象所具有的行为，具体如下：</p><ul><li>属性：用来描述对象特性的数据，即若干变量。</li><li>方法：用来操作对象的若干动作，即若干函数。</li></ul><p>通过访问或设置对象的属性，并且调用对象的方法，就可以对对象进行各种操作，从而获得需要的功能。在程序中若要调用对象的属性或方法，则需要在对象后面加上一个句点 “.” （即点标记格式），继而在其后加上属性名或方法名即可。例如， screen.width 表示通过 screen 对象的 width 属性获取屏幕宽度； Math.sqrt(x) 表示通过 Math 对象的 sqrt() 方法获取 x 的平方根。</p><h3 id="创建和删除对象"><a href="#创建和删除对象" class="headerlink" title="创建和删除对象"></a>创建和删除对象</h3><h4 id="·-创建对象"><a href="#·-创建对象" class="headerlink" title="· 创建对象"></a>· 创建对象</h4><p>在 JavaScript 中，使用 new 运算符可以创建对象，将新建的对象赋值给一个变量后，就可以通过这个变量访问对象的属性和方法。值得一提的是， Object 对象是所有对象的顶层对象，所有对象均继承自 Object 对象。</p><p>使用new 运算符创建对象变量的格式如下：</p><pre><code class="javascript">变扯名 = new 对象名()</code></pre><p>下面是一个使用运算符 new 创建了一个 Date 对象的具体示例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var date;date=new Date();document.write(&quot;现在是：&quot;+date.getHours()+&quot;时&quot;+date.getMinutes()+&quot;分&quot;+date.getSeconds()+&quot;秒&quot;);&lt;/script&gt;</code></pre><script type="text/javascript">var date;date=new Date,document.write("现在是："+date.getHours()+"时"+date.getMinutes()+"分"+date.getSeconds()+"秒")</script><p>现在 Date 对象已经赋值给变量 date 。通过变量 date 就可调用 Date 对象的方法以获取当前系统的时间。</p><h4 id="·-删除属性"><a href="#·-删除属性" class="headerlink" title="· 删除属性"></a>· 删除属性</h4><p>delete 运算符可以删除对象的属性，它的操作数应当是一个属性访问表达式。其中需要注意的是，内置对象的属性及方法多数不能使用 delete 、对象继承于原型的属性和方法也不能使用 delete , 同时 delete 只是断开属性和对象之间的联系，从而使对象不再能操作属性。</p><p>下面是 delete 运算符的使用的具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var box;box=new Object();box.name=&quot;小王&quot;;box.age = 18;document.write(&quot;删除前：&quot;+box.name+&quot;的年龄是 &lt;b&gt;&quot;+box.age+&quot;&lt;/b&gt;&quot;);document.write(&quot;&lt;br&gt;删除 box 对象的 age 属性成功返回：&quot;+delete box.age);document.write(&quot;&lt;br&gt;删除后：&quot;+box.name+&quot;的年龄是 &lt;b&gt;&quot;+box.age+&quot;&lt;/b&gt;&quot;);&lt;/script&gt;</code></pre><script type="text/javascript">var box;box=new Object,box.name="小王",box.age=18,document.write("删除前："+box.name+"的年龄是 <b>"+box.age+"</b>"),document.write("<br>删除 box 对象的 age 属性成功返回："+delete box.age),document.write("<br>删除后："+box.name+"的年龄是 <b>"+box.age+"</b>")</script><p>成功删除对象的属性时，返回 true, 当再次调用时，则显示 undefined 未定义。其中需要注意的是，删除不存在的属性和属性访问表达式时，delete 同样返回 true。</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript 中提供了许多内置对象，如 Boolean 对象、Date 对象、Error 对象、Function 对象、Global 对象、Math 对象、Object 对象、String 对象等。</p><h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><p>Date 对象主要提供获取和设置日期与时间的方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getYear()</td><td>返回日期的年份，是 2 位或 4 位整数</td></tr><tr><td>setYear(x)</td><td>设置年份值 x</td></tr><tr><td>getFullYear()</td><td>返回日期的完整年份。例如：2013</td></tr><tr><td>setFullYear</td><td>(x) 设置完整的年份值 x</td></tr><tr><td>getMonth()</td><td>返回日期的月份值，介于 0 ~ 11, 分别表示 1 、2 . .12 月</td></tr><tr><td>setMonth(x)</td><td>设置月份值 x</td></tr><tr><td>getDate()</td><td>返回日期的日期值，介于 1 ~ 31</td></tr><tr><td>setDate(x)</td><td>设置日期值 x</td></tr><tr><td>getDay()</td><td>返回值是—个处于 0~6 的整数，代表一周中的某一天（ 即 0 表示星期天， 1 表示星期一，依次类推 ）</td></tr><tr><td>getHours()</td><td>返回时间的小时值，介于 0 ~23</td></tr><tr><td>setHours(x)</td><td>设置小时值 x</td></tr><tr><td>getMinutes()</td><td>返回时间的分钟值，介于 0 ~ 59</td></tr><tr><td>setMinutes(x)</td><td>设置分钟值 x</td></tr><tr><td>getSeconds()</td><td>返回时间的秒数值，介于 0~ 59</td></tr><tr><td>setSeconds(x)</td><td>设置秒数值 x</td></tr><tr><td>getMilliseconds()</td><td>返回时间的毫秒数值，介于 0 ~ 999</td></tr><tr><td>setMilliseconds(x)</td><td>设置毫秒数值 x</td></tr><tr><td>getTime()</td><td>返回 1970 年 1 月 1 日至今的亳秒数。负数代表 1970 年之前的日期</td></tr><tr><td>setTime(x)</td><td>使用毫秒数 x 设置日期和时间</td></tr><tr><td>tolocaleString()</td><td>根据本地时间格式，把 Date 对象转换为字符串</td></tr><tr><td>tolocaleTimeStnng()</td><td>根据本地时间格式，把 Date 对象的时间部分转换为字符串</td></tr><tr><td>tolocaleDateStnng()</td><td>根据本地时间格式，把 Date 对象的日期部分转换为字符串</td></tr><tr><td>toGMTString()</td><td>返回时间对应的格林尼治标准时间的字符串</td></tr></tbody></table><p>要使用Date 对象，必须先使用new 关键字创建它，其中常见创建Date 对象的方式有如下3 种。</p><p>a)不带参数，其创建方式如下所示：</p><pre><code class="javascript">var d = new Date();</code></pre><p>在上述代码中，创建了一个含有系统当前日期和时间的Date 对象。</p><p>b) 创建一个指定日期的Date 对象，其创建方式如下所示：</p><pre><code class="javascript">var d = new Date(2020,1,1);</code></pre><p>在上述代码中，创建了一个日期是 2020 年 1 月 1 日的 Date 对象，而且这个对象中的小时、分钟、秒、毫秒值都为 0 。需要注意的是，月份的返回值是从 0 到11, 即 0 表示 1 月。</p><p>c) 创建—个指定时间的Date 对象，其创建方式如下所示：</p><pre><code class="javascript">var d = newDate (2020, 3 , 3 , 10 , 20 , 30 , 50);</code></pre><p>在上述代码中，创建—个包含确切日期和时间的Date 对象，即2020 年 3 月 3 日10 点 20分 30 秒 50 毫秒。</p><p>下面是一个获取系统日期的具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var date=new Date();var year=date.getFullYear();var month=date.getMonth();month=month+1;var day=date.getDate();document.write(&quot;当前日期为:&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;); &lt;/script&gt;</code></pre><script type="text/javascript">var date=new Date,year=date.getFullYear(),month=date.getMonth();month+=1;var day=date.getDate();document.write("当前日期为： "+year+" 年 "+month+" 月 "+day+" 日 ")</script><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><p>Math 对象的属性是数学中常用的常量，方法是—些数学函数：</p><table><thead><tr><th>展性</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td>自然对数的底，对应值为2.718281828459045</td></tr><tr><td>LN10</td><td>10 的自然对数</td></tr><tr><td>LN2</td><td>2 的自然对数</td></tr><tr><td>PI</td><td>圆周率pai</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回 x 的绝对值</td></tr><tr><td>ceil(x)</td><td>返回大于等于 x 的最小整数</td></tr><tr><td>floor(x)</td><td>返回小于等于 x 的最大整数</td></tr><tr><td>max(x,y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>min(x,y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>pow(x,y)</td><td>返回 x 的 y 次幕</td></tr><tr><td>random()</td><td>返回一个 0 ~ 1 的随机数</td></tr><tr><td>round(x)</td><td>返回 x 四舍五入的取整数</td></tr><tr><td>sqrt(x)</td><td>返回 x 的平方根</td></tr></tbody></table><p>下面是一个获取 10 到 20 之间随机数的案例：</p><pre><code class="html">&lt;button onclick=&quot;getRandom(10,20)&quot;&gt;获取一个随机数&lt;/button&gt;&lt;p id=&quot;random&quot;&gt;请点一下上面的按钮来获取随机数&lt;/p&gt;&lt;script&gt;function getRandom(min,max){    var num=Math.random();    num=Math.floor(num*(max-min)+min);    document.getElementById(&quot;random&quot;).innerHTML=&quot;您获取的随机数是&quot;+num;}&lt;/script&gt;</code></pre><p><button onclick="getRandom(10,20)">获取一个随机数</button></p><p id="random">请点一下上面的按钮来获取随机数</p><script>function getRandom(n,o){var t=Math.random();t=Math.floor(t*(o-n+1)+n),document.getElementById("random").innerHTML="您获取的随机数是 "+t}</script><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><p>String 对象是 JavaScript 提供的字符串处理对象，它提供了对字符串进行处理的属性和方法:</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>返回字符串中字符的个数。注：一个汉字也是一个字符</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>charAt(index)</td><td>返回指定索引 (index) 位置处的字符，第 1 个字符的索引为 0,第 2 个字符的索引为 1 以此类推.</td></tr><tr><td>indexOf(“abc”)</td><td>从前向后检索字符串</td></tr><tr><td>lastIndexOf(“abc”)</td><td>从后向前搜索字符串</td></tr><tr><td>substr(startIndex，length)</td><td>返回从起始索引号提取字符串中指定数目的字符</td></tr><tr><td>substring(startIndex,endIndex)</td><td>返回字符串中两个指定的索引号之间的字符</td></tr><tr><td>split(“分隔符”)</td><td>把字符串分割为字符串数组</td></tr><tr><td>search(“substr”)</td><td>检索字符串中指定子字符串或与正则表达式相匹配的值</td></tr><tr><td>replace(substr,replacement)</td><td>替换与正则表达式匹配的子串</td></tr><tr><td>tolowerCase()</td><td>把字符串转换为小写</td></tr><tr><td>toUpperCase()</td><td>把字符串转换为大写</td></tr><tr><td>localeCompare()</td><td>用本地特定的顺序来比较两个字符串</td></tr></tbody></table><p>下面是一个使用的具体案例：</p><pre><code class="html">&lt;button onclick=&quot;zfcff()&quot;&gt;点击输入字符串&lt;/button&gt;&lt;p id=&quot;zfcff&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;function zfcff(){    var a,b,i,c=&quot;&quot;;    a=prompt(&quot;请输入一行文字：&quot;,&quot;&quot;);    b=a.toUpperCase();    for(i=b.length-1;i&gt;=0;i--) {        c=c.concat(b.charAt(i));    }    document.getElementById(&quot;zfcff&quot;).innerHTML=(c);}&lt;/script&gt;</code></pre><p><button onclick="zfcff()">点击输入字符串</button></p><p id="zfcff"></p><script type="text/javascript">function zfcff(){var t,e,f,n="";for(t=prompt("请输入一行文字：",""),e=t.toUpperCase(),f=e.length-1;f>=0;f--)n=n.concat(e.charAt(f));document.getElementById("zfcff").innerHTML=n}</script><h3 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array 数组对象"></a>Array 数组对象</h3><p>数组是 JavaScript 中唯—用来存储和操作有序数据集的数据结构。</p><p>数组中的每个值叫作—个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript 数组是无类型的，也就是说数组元素可以是任意类型，并且同—个数组中的不同元素也可以有不同的类型，甚至可以是对象或其他数组。</p><h4 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h4><p>在 JavaScript 中创建数组有两种方式，一种是直接使用方式创建：</p><pre><code class="javascript">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</code></pre><p>另—种是使用new 关键字，结合构造函数 Array() 来创建数组：</p><pre><code class="javascript">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);</code></pre><blockquote><p>出于简洁、可读性和执行速度的考虑，不推荐使用 new 关键字方法。</p></blockquote><p>下面是一个简单的创建和访问数组的案例：</p><pre><code class="html">&lt;p id=&quot;arrays1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;arrays2&quot;&gt;&lt;/p&gt;&lt;p id=&quot;arrays3&quot;&gt;&lt;/p&gt;&lt;script&gt;var s1 = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];var s2 = new Array(&quot;Saab1&quot;, &quot;Volvo1&quot;, &quot;BMW1&quot;);var s3 = new Array(3);s3=[&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;]s3[1]=&quot;HELLO&quot;;document.getElementById(&quot;arrays1&quot;).innerHTML = s1;document.getElementById(&quot;arrays2&quot;).innerHTML = s2;document.getElementById(&quot;arrays3&quot;).innerHTML = s3;&lt;/script&gt;</code></pre><p id="arrays1"></p><p id="arrays2"></p><p id="arrays3"></p><script>var s1=["Audi","BMW","porsche"],s2=new Array("Saab1","Volvo1","BMW1"),s3=new Array(3);s3=["AA","BB","CC"],s3[1]="HELLO",document.getElementById("arrays1").innerHTML=s1,document.getElementById("arrays2").innerHTML=s2,document.getElementById("arrays3").innerHTML=s3</script><blockquote><p>如果创建数组的时候指定了数组长度，而后添加的数组元素个数又超出了指定的数组长度，数组仍会保存全部元素</p></blockquote><h4 id="数组的常用属性和方法"><a href="#数组的常用属性和方法" class="headerlink" title="数组的常用属性和方法"></a>数组的常用属性和方法</h4><table><thead><tr><th>属性 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>返回数组中数组元素的个数，即数组长度</td></tr><tr><td>toString()</td><td>返回一个字符串，该字符串包含数组中的所有元素，各个元素间用逗号隔开</td></tr><tr><td>pop()</td><td>此方法从数组中删除最后一个元素，并返回“被弹出”的值</td></tr><tr><td>push()</td><td>方法（在数组结尾处）向数组添加一个新的元素，并返回新数组的长度</td></tr><tr><td>splice()</td><td>此方法可以在数组中不留“空洞”的情况下移除元素：第一个参数定义新元素应该被添加（接入）的位置，第二个参数定义应该删除多少个元素。</td></tr><tr><td>sort()</td><td>此方法以字母顺序对数组进行排序</td></tr><tr><td>reverse()</td><td>此方法反转数组中的元素</td></tr></tbody></table><p>下面是一个 toString 方法的案例</p><pre><code class="html">&lt;p id=&quot;toString&quot;&gt;&lt;/p&gt;&lt;script&gt;var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];document.getElementById(&quot;toString&quot;).innerHTML = fruits.toString();&lt;/script&gt;</code></pre><p id="toString"></p><script>var fruits=["Banana","Orange","Apple","Mango"];document.getElementById("toString").innerHTML=fruits.toString()</script><p><strong>TIPS 01</strong></p><blockquote><p>关于 sort 排序，如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。正因如此，sort() 方法在对数值排序时会产生不正确的结果。我们通过一个比值函数来修正此问题：</p></blockquote><pre><code class="javascript">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b){return a - b}); </code></pre><p>当 sort() 函数比较两个值时，会将值发送到比较函数，并根据所返回的值（负、零或正值）对这些值进行排序。</p><p><strong>TIPS 02</strong></p><blockquote><p>可以使用 Math.max.apply 来查找数组中的最高值,使用 Math.min.apply 来查找数组中的最低值：</p></blockquote><pre><code class="javascript">function myArrayMax(arr) {    return Math.max.    apply(null, arr);}</code></pre><pre><code class="javascript">Math.max.apply([1, 2, 3]) 等于 Math.max(1, 2, 3)</code></pre><p><strong>TIPS 03</strong></p><blockquote><p>和 java 一样，JS 支持增强 for 循环,只不过两者语法略有不同：</p></blockquote><pre><code class="html">&lt;script&gt;var s1=[1,2,3,4,5,6,7,8,9,10];var sum = 0;for(var b in s1){    sum++;}document.write(sum);&lt;/script&gt;</code></pre><script>var s1=[1,2,3,4,5,6,7,8,9,10],sum=0;for(var b in s1)sum++;document.write(sum)</script><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>对于复杂的业务逻辑，有时简单的—维数组不能够满足需求，需要使用二维数组。当数组中所有的数组元素也是数组时，就形成了二维数组。下面是三种具体方式：</p><pre><code class="html">不推荐这种方式：&lt;script type=&quot;text/javascript&quot;&gt;var students,i,j;students=new Array();students[0]=new Array(&quot;张三&quot;,76,90,80);students[1]=new Array(&quot;李四&quot;,89,97,86);students[2]=new Array(&quot;王五&quot;,90,78,88);for(i in students){            for(j in students[i]){            document.write(students[i][j] +&quot;\t&quot;);    }    document.write(&quot;&lt;br/&gt;&quot;);}&lt;/script&gt;</code></pre><script type="text/javascript">var students,i,j;students=new Array,students[0]=new Array("张三",76,90,80),students[1]=new Array("李四",89,97,86),students[2]=new Array("王五",90,78,88);for(i in students){for(j in students[i])document.write(students[i][j]+"");document.write("<br/>")}</script><pre><code class="html">方式二：&lt;script type=&quot;text/javascript&quot;&gt;var students,i,j;students[0]=[&quot;张三&quot;,76,90,80];students[1]=[&quot;李四&quot;,89,97,86];students[2]=[&quot;王五&quot;,90,78,88];for(i in students){            for(j in students[i]){            document.write(students[i][j] +&quot;\t&quot;);    }    document.write(&quot;&lt;br/&gt;&quot;);}&lt;/script&gt;</code></pre><script type="text/javascript">var students,i,j;students[0]=["张三",76,90,80],students[1]=["李四",89,97,86],students[2]=["王五",90,78,88];for(i in students){for(j in students[i])document.write(students[i][j]+"");document.write("<br/>")}</script><pre><code class="html">方式三&lt;script type=&quot;text/javascript&quot;&gt;var students,i,j;students=[[&quot;张三&quot;,76,90,80],[&quot;李四&quot;,89,97,86],[&quot;王五&quot;,90,78,88]];for(i in students){            for(j in students[i]){            document.write(students[i][j] +&quot;\t&quot;);    }    document.write(&quot;&lt;br/&gt;&quot;);}&lt;/script&gt;</code></pre><script type="text/javascript">var students,i,j;students=[["张三",76,90,80],["李四",89,97,86],["王五",90,78,88]];for(i in students){for(j in students[i])document.write(students[i][j]+"");document.write("<br/>")}</script><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 03流程控制和函数</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-03%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-03%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>在程序中需要相应的控制语句来控制程序的执行流程。在 Javascript 中主要的流程控制语句有条件语句、循环语句和跳转语句等。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h4><p>if 条件语句是最基本、最常用的条件控制语句。通过判断条件表达式的值为 true 或者 false,来确定是否执行某— 条语句。主要包括单向判断语句、双向判断语句和多向判断语句，具体如下:</p><pre><code class="javascript">if （执行条件1) {    执行语句1}else if （执行条件2) {    执行语句2}else if （执行条件3){    执行语句3}else {    执行语句3}</code></pre><p>在多向判断语句的语法中，通过else if 语句可以对多个条件进行判断，并且根据判断的结果执行相关事件。下面是一个具体运行时的 DEMO：</p><pre><code class="html">&lt;button onclick=&quot;jiangpin()&quot;&gt;奖品是？&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;function jiangpin(){     var jiangpin = &#39;二等奖&#39; ;     if (jiangpin == &#39;一等奖&#39;){        alert (&#39;恭喜获得一辆跑车&#39;);     }     else if (jiangpin ==&#39;二等奖&#39;){        alert (&#39;恭喜获得一部手机&#39;);     }     else {        alert(&#39;恭喜获得一台空气净化器&#39;);     }}&lt;/script&gt;</code></pre><p><button onclick="jiangpin()">奖品是？</button></p><script type="text/javascript">function jiangpin(){var a="二等奖";"一等奖"==a?alert("恭喜获得一辆跑车"):"二等奖"==a?alert("恭喜获得一部手机"):alert("恭喜获得一台空气净化器")}</script><h4 id="switch-条件语句"><a href="#switch-条件语句" class="headerlink" title="switch 条件语句"></a>switch 条件语句</h4><p>switch 条件语句是典型的多路分支语句，其作用与if 语句类似， 但 switch 条件语句比 if 语句更具有可读性。switch 条件语句的基本语法格式如下：</p><pre><code class="javascript">switch (表达式){    case 目标值1:执行语句1;break;    case 目标值2:执行语句2;break;    ···    case 目标值n:执行语句n;break;    default:执行语句n+l;break;}</code></pre><p>在上面的语法结构中， switch 语句将表达式的值与每个 case 中的目标值进行匹配，如果找到了匹配的值，会执行对应 case 后的执行语句，如果没找到任何匹配的值，就会执行 default 后的执行语句。下面是一个具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;     var day=6;     switch (day) {     case 1:document.write(&quot;星期一&quot;);break;     case 2:document.write(&quot;星期二&quot;);break;     case 3:document.write(&quot;星期三&quot;);break;     case 4:document.write(&quot;星期四&quot;);break;     case 5:document.write(&quot;星期五&quot;);break;     case 6:document.write(&quot;星期六&quot;);break;     default:document.write(&quot;星期日&quot;);break;     }&lt;/script&gt;</code></pre><script type="text/javascript">var day=6;switch(day){case 1:document.write("星期一");break;case 2:document.write("星期二");break;case 3:document.write("星期三");break;case 4:document.write("星期四");break;case 5:document.write("星期五");break;case 6:document.write("星期六");break;default:document.write("星期日")}</script><p>在上述代码中，首先定义了一个变量，并对其赋值，然后应用 switch 条件语句获取变量值，并判断变量值与 case 标签的目标值是否匹配，匹配则输出相应的执行语句并跳出循环，否则继续判断下一个 case 标签。如果 case 标签均不匹配，则执行 “default” 标签下的执行语句。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环语句分为 while 循环语句、do … while 循环语句和 for 循环语句三种。</p><h4 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h4><p>while 语句是最基本的循环语句，其基本语法格式如下：</p><pre><code class="javascript">while (循环条件) {    执行语句;    ···}</code></pre><p>在上面的语法结构中，｛｝中的执行语句被称作循环体，循环体是否执行取决千循环条件。当循环条件为 true 时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为 true 则会继续执行，直到循环条件为 false 时，整个循环过程才会结束。下面是一个具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var i=1;   //定义一个变量a, 设置初始值为1var sum=i;document.write(&quot;累加和不大于10 的所有自然数：&lt;br&gt;&quot;);while (sum&lt;10) {    sum=sum+i;    document.write(i+&#39;&lt;br&gt;&#39;);   //输出符合条件的自然数    i++;    //累加 i 的值}&lt;/script&gt;</code></pre><script type="text/javascript">var i=1,sum=i;for(document.write("累加和不大于10 的所有自然数：<br>");10>sum;)sum+=i,document.write(i+"<br>"),i++</script><h4 id="do…-while-循环语句"><a href="#do…-while-循环语句" class="headerlink" title="do… while 循环语句"></a>do… while 循环语句</h4><p>do… while 循环语句也称为后测试循环语句，它也是利用一个条件来控制是否要继续执行该<br>语句，其基本语法格式如下：</p><pre><code class="javascript">do{    执行语旬;} while(循环条件);</code></pre><p>在上面的语法结构中，关键字 do 后面 {} 中的执行语句是循环体。do…while 循环语句将循环条件放在了循环体的后面。这也就意味着，循环体会无条件执行—次，然后再根据循环条件来决定是否继续执行。下面是一个具体案例：</p><script type="text/javascript">var i=95;do i++,document.write(i+" ");while(100>i)</script><blockquote><p>do … while 循环语句结尾处的 while 语句括号后面有一个分号 “;”,在书写过程中一定不要漏掉、<br>否则 JavaScript 会认为循环是一个空语句。</p></blockquote><h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><p>for 循环语句也被称为计次循环语句，一般用于循环次数已知的情况，其基本语法格式如下：</p><pre><code class="javascript">for (初始化表达式;循环条件;操作表达式){    执行语句;}</code></pre><p>下面，是—个计算 50 以内所有奇数和的案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var sum=0;for(var i=1;i&lt;=50;i+=2){    if(i%2!=0)       sum+=i;}document.write(sum);&lt;/script&gt;</code></pre><script type="text/javascript">for(var sum=0,i=1;50>=i;i+=2)i%2!=0&&(sum+=i);document.write(sum)</script><p>在上述代码中，首先定义 sum, 用于记住累加的和，然后设置 for 循环的初始化表达式为 “var i= 1” ，循环条件为 “i&lt;=50”，并让变量 i 以加 2 的方式自增，这样就可以得到 100 以内的所有奇数。最后通过 “sum=sum+i” 累加求和，并输出计算结果。</p><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句用千实现循环执行过程中程序流程的跳转。在 Javascript 中，跳转语句包括break 语句和 continue 语句。</p><blockquote><p>continue 语句只是结束本次循环｀而不是终止整个循环语句的执行。break 语旬则是结束整个循环<br>过程，不再判断执行循环的条件是否成立n</p></blockquote><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p>在 switch 条件语句和循环语句中都可以使用 break 语句， 当它出现在 switch 条件语句中时，<br>作用是终止某个 case 并跳出 switch 结构。break 语句的基本语法格式如下：</p><pre><code class="javascript">break;</code></pre><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p>continue 语句的作用是终止本次循环，执行下一次循环，其基本语法格式如下：</p><pre><code class="javascript">continue;</code></pre><p>下面，是一个具体案例：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var sum=0;xh:for(var i=1;i&lt;10;i++){    if(i%2==0)        continue xh;    sum+=i;}document.write(sum);&lt;/script&gt;</code></pre><script type="text/javascript">for(var sum=0,i=1;10>i;i++)i%2!=0&&(sum+=i);document.write(sum)</script><p>这个案例中，对循环进行了标记，这样可以使用 continue 或 break 语句精确控制 继续/终止 哪一层循环。（和 java 一样）</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 Javascript 中，经常会遇到程序需要多次重复操作的情况，这时就需要重复书写相同的代码，这样不仅加重了开发人员的工作量，而且对于代码的后期维护也是相当困难的。为此，Javascript 提供了函数，它可以将程序中烦琐的代码模块化，提高程序的可读性，并且便于后期维护。</p><h3 id="函数基本语法"><a href="#函数基本语法" class="headerlink" title="函数基本语法"></a>函数基本语法</h3><p>函数使用关键字 function 来定义，其语法格式如下所示：</p><pre><code class="html">&lt;script type= &quot;text/javascript&quot; &gt;function 函数名(参数1,参数2,……) {    函数体;}&lt;/script&gt;</code></pre><p>从上述语法格式可以看出，函数的定义由关键字 “function” “函数名” “参数” 和 “函数体” 四部分组成，关于这四部分的相关讲解具体如下。</p><ul><li>function: 在声明函数时必须使用的关键字。</li><li>函数名：创建函数的名称，函数名是唯一的。</li><li>参数：外界传递给函数的值，它是可选的， 当有多个参数时，各参数用 “,” 分隔。</li><li>函数体：函数定义的主体，专门用于实现特定的功能。</li></ul><p>下面是一个具体样例：</p><pre><code class="html">&lt;script type= &quot;text/javascript&quot;&gt;function show() {alert (&quot;I am EmptinessBoy!&quot;) ;}&lt;/script&gt;&lt;button onclick=&quot;show()&quot;&gt;我是谁？&lt;/button&gt;</code></pre><script type="text/javascript">function show(){alert("I am EmptinessBoy!")}</script><p><button onclick="show()">我是谁？</button></p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>当函数定义完成后，要想在程序中发挥函数的作用，必须得调用这个函数。函数的调用非常<br>简单，只需引用函数名，并传入相应的参数即可。函数调用的语法格式如下：</p><pre><code class="javascript">函数名称 (参数1,参数2,……)</code></pre><p>基本函数的调用，使用 onclick 事件的案例已经在上方函数基本语法小结演示过了，此处省略。</p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>变量需要在它的作用范围内才可以被使用，这个作用范围被称为变量的作用域。变量的作用域取<br>决于这个变量是哪一种变量，在 Javascript 中，变量—般分为全局变量和局部变量，对它们的具<br>体解释如下。</p><ul><li>全局变量：在所有函数之外定义，其作用域范围是同一个页面文件中的所有脚本。</li><li>局部变量：是定义在函数体之内，只对该函数是可见的，而对其他函数则是不可见的。</li></ul><p>下面，通过一个输出 1 ~ 100 中所有素数的案例来理解函数中变量的作用域。</p><pre><code class="html">&lt;script type=&quot;text/javascript &quot;&gt;function isPrime(n){    if(n&lt;1) return false;    var i;  //此处变量i 为局部变量    for(i=2;i&lt;n;i++)        if(n%i==0) return false;    return true;}&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;var i,n=0;  //i,n声明为全局变蜇document.write(&quot;1-100 之间的所有素数：&lt;br&gt;&quot;);for(i=1;i&lt;=100;i++){    if(isPrime(i)){   //判断是否为素数    n++   //累计素数个数    document.write(i+&quot;&amp;emsp;&amp;emsp;&quot;);   //使用制表符\t,使输出上下对齐    if(n%6==0) document.write(&quot;&lt;br&gt;&quot;);     //换行，6个素数一行    }}&lt;/script&gt;</code></pre><script type="text/javascript">function isPrime(r){if(1>r)return!1;var i;for(i=2;r>i;i++)if(r%i==0)return!1;return!0}</script><script type="text/javascript">var i,n=0;for(document.write("1-100 之间的所有素数：<br>"),i=1;100>=i;i++)isPrime(i)&&(n++,document.write(i+"&emsp;&emsp;"),n%6==0&&document.write("<br>"))</script><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 02语法基础</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-02%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-02%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>每一种语言都有自己的基本语法，JS 的基本语法使用如下：</p><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p>在计算机语言的使用规范中，关键字是不能作为变量名和函数名使用的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>JavaScript 关键字或称（保留字 Reversed Words），是指在 JavaScript 语言中被事先定义好并赋予特殊含义的单词。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>delete</td><td>goto</td><td>null</td><td>throws</td></tr><tr><td>as</td><td>do</td><td>if</td><td>package</td><td>transient</td></tr><tr><td>boolean</td><td>double</td><td>implements</td><td>private</td><td>true</td></tr><tr><td>break</td><td>else</td><td>import</td><td>protected</td><td>try</td></tr><tr><td>byte</td><td>enum</td><td>in</td><td>public</td><td>typeof</td></tr><tr><td>case</td><td>export</td><td>instanceof</td><td>return</td><td>use</td></tr><tr><td>catch</td><td>extends</td><td>int</td><td>short</td><td>var</td></tr><tr><td>char</td><td>false</td><td>interface</td><td>static</td><td>void</td></tr><tr><td>class</td><td>final</td><td>is</td><td>super</td><td>volatile</td></tr><tr><td>continue</td><td>finally</td><td>long</td><td>switch</td><td>while</td></tr><tr><td>const</td><td>float</td><td>namespace</td><td>synchronized</td><td>with</td></tr><tr><td>debugger</td><td>for</td><td>native</td><td>this</td><td></td></tr><tr><td>default</td><td>function</td><td>new</td><td>throw</td><td></td></tr></tbody></table><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符（Identifier）就是一个名字，用来对变量、函数、属性、参数进行命名，或者用做某些循环语句中的跳转位置的标记。</p><p>javascript 标识符名允许包含字母、数字、美元符号和下划线（但第一个字符不允许是数字），对于不同的数据类型，javascript 有约定俗成的标识符名命名规则。一般来说，变量的命名要使用名词，而函数应该是动词+名称的形式：</p><pre><code class="javascript">合法标识符示例：imy_name_name$strnl</code></pre><pre><code class="javascript">var count = 10;var myName=&quot;xiaohuochai&quot;;var found = true;function getName(){  return 123;  }</code></pre><p>通常驼峰格式是标识符命名的首选格式，第一个字母小写，剩下的每个单词的首字母大写</p><pre><code class="javascript">var myMoodToday = &#39;happy&#39;;</code></pre><blockquote><p>注意：数字不允许作为首字符出现，这样 JavaScript 可以轻易区别标识符和数字。此外，标识符不能和 JavaScript 用于其他目的的关键词同名。</p></blockquote><h2 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h2><p>变量就是程序中一个已经命名的存储单元，它的主要作用就是为数据操作提供存放信息的容器。</p><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>在编译的过程中，经常需要定义一些符号来编辑某些名称。变量属于标识符的一种，命名规则可以参考上文标识符章节。</p><h3 id="变量的声明和赋值"><a href="#变量的声明和赋值" class="headerlink" title="变量的声明和赋值"></a>变量的声明和赋值</h3><p>在 JavaScript 中，使用变量前需要先对其进行声明。所有的 JavaScript 变量都由关键词 <strong>var</strong> 声明，其语法如下：</p><pre><code class="javascript">var 变量名;</code></pre><p>在声明变量的同时，也可以对变量进行赋值：</p><pre><code class="javascript">var abc=1;</code></pre><p>如果只是声明了变量，未对其赋值，则其默认值为 undefined。声明变量时，需要遵循的规则如下：</p><p><strong>01</strong> 同时声明多个变量</p><pre><code class="javascript">var a,b,c,d,e;</code></pre><p>声明多个同时初始化：</p><pre><code class="javascript">var a=1,b=2,c=3,d=4,e=5;</code></pre><p><strong>02</strong> var 语句可以成为循环体一部分</p><p><strong>03</strong> var 语句多次声明一个变量，如果重复声明的变量已经有初始值，那么此时声明相当于重新赋值</p><blockquote><p>JavaScript 使用弱类型变量，因此可以不用理会变量的输一局类型，把任意类型数据赋值变量。</p></blockquote><p>编程语言分为动态类型语言和静态类型语言两种。 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。javascript就是动态类型语言的代表.</p><p>在javascript中，可以在修改变量值的同时修改值的类型</p><pre><code class="javascript">var message = &#39;hi&#39;;message = 100;  //这个语句修改变量类型；有效，但不推荐</code></pre><p>变量松散类型的特性总结起来有两点：一是声明时不用给变量指定数据类型；二是赋值时可以修改数据类型</p><h3 id="具体数据类型"><a href="#具体数据类型" class="headerlink" title="具体数据类型"></a>具体数据类型</h3><h4 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h4><p>在 JavaScript 中，所有的数字都是数值型，JS 可以表示标准定义的64位浮点格式数字。（IEEE754）</p><p>当一个数字直接出现在 JavaScript 中时，我们称它为数值直接两。JS 中的数值直接量包括：</p><pre><code>整型数据：123十六进制：0x5C八进制：023浮点型：3.14</code></pre><h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><p>字符串类型是由 Unicode 字符、数字、标点符号组成的序列，JS 中的字符串类型数据包含在单引号或者双引号中，由单引号定界的字符串中可以包含双引号，同理双引号定界的字符串中也可以包含单引号。</p><pre><code class="javascript">&#39;Hi,&#39;&#39;I am &quot;EmptinessBoy&quot;&#39;&quot;Hi,&quot;&quot;I am &#39;EmptinessBoy&#39;&quot;</code></pre><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>在 JavaScript 程序中，布尔值通常用来比较所得的结果。</p><pre><code class="javascript">n==1</code></pre><p>上面这行代码的返回值用于比较变量 n 的值是否等于 1，若相等则返回 true，不相等返回 false。</p><p>布尔值通常用于控制 Js 的循环结构，例如：</p><pre><code class="javascript">if(n==1)    m=n+1;else    n=n+1;</code></pre><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="转义列表"><a href="#转义列表" class="headerlink" title="转义列表"></a>转义列表</h4><p>以反斜杠开头的，不可显示的特殊字符通常被称为转义字符。下面是常用的转义字符表格：</p><table><thead><tr><th>转义字符</th><th>描 述</th><th>转义字符</th><th>描 述</th></tr></thead><tbody><tr><td>\b</td><td>退格</td><td>\v</td><td>跳格（Tab、水平）</td></tr><tr><td>\n</td><td>回车换行</td><td>\r</td><td>换行</td></tr><tr><td>\t</td><td>水平制表符</td><td>\\</td><td>反斜杠</td></tr><tr><td>\f</td><td>换页</td><td>\ooo</td><td>八进制整数，000~777</td></tr><tr><td>\‘</td><td>单引号</td><td>\xHH</td><td>十六进制整数，00~FF</td></tr><tr><td>\“</td><td>双引号</td><td>\uhhhh</td><td>十六进制 Unicode 字符</td></tr></tbody></table><h4 id="扩展（换行转义符的不同）："><a href="#扩展（换行转义符的不同）：" class="headerlink" title="扩展（换行转义符的不同）："></a>扩展（换行转义符的不同）：</h4><p>在Windows中：</p><p>‘\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；</p><p>‘\n’ 换行，换到当前位置的下一行，而不会回到行首；</p><p>Unix 系统里，每行结尾只有 “&lt;换行&gt;”，即 “\n”；Windows 系统里面，每行结尾是 “&lt;回车&gt;&lt;换行&gt;”，即 “\r\n”；Mac系统里，每行结尾是 “&lt;回车&gt;”，即 “\r”；。一个直接后果是，Unix / Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac下打开的话，在每行的结尾可能会多出一个 ^M 符号。</p><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是程序执行特定算数或逻辑操作的符号，用于执行程序代码运算。JS 中运算符主要包括算数运算符，比较运算符，赋值运算符，条件运算符这五种。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算术运算符用于连接运算表达式，主要包括加（ ＋ ） 、减（ － ）、乘（ ＊ ）、除 ( I )、取模 ( % ) 、<br>自增 （ ++ ）、自减（ －－ ） 等运算符，</p><pre><code class="html">算数运算符 DEMO:&lt;p id=&quot;demo1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo2&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo3&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo4&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo5&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo6&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo7&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo8&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var num1=100,num2=25;  document.getElementById(&#39;demo1&#39;).innerHTML=(&quot;100+25=&quot;+(num1+num2)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demo2&#39;).innerHTML=(&quot;100-25=&quot;+(num1-num2)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demo3&#39;).innerHTML=(&quot;100*25=&quot;+(num1*num2)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demo4&#39;).innerHTML=(&quot;100/25=&quot;+(num1/num2)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demo5&#39;).innerHTML=(&quot;(100++)=&quot;+(num1++)+&quot;&lt;br&gt;&quot;);  num1=100;num1++;  document.getElementById(&#39;demo6&#39;).innerHTML=(&quot;(num1)=&quot;+(num1)+&quot;&lt;br&gt;&quot;);  num1=100;  document.getElementById(&#39;demo7&#39;).innerHTML=(&quot;(++100)=&quot;+(++num1)+&quot;&lt;br&gt;&quot;);  num1=100;++num1;  document.getElementById(&#39;demo8&#39;).innerHTML=(&quot;(num1)=&quot;+(num1)+&quot;&lt;br&gt;&quot;);&lt;/script&gt;</code></pre><p id="demo1"></p><p id="demo2"></p><p id="demo3"></p><p id="demo4"></p><p id="demo5"></p><p id="demo6"></p><p id="demo7"></p><p id="demo8"></p><script type="text/javascript">var num1=100,num2=25;document.getElementById("demo1").innerHTML="100+25="+(num1+num2)+"<br>",document.getElementById("demo2").innerHTML="100-25="+(num1-num2)+"<br>",document.getElementById("demo3").innerHTML="100*25="+num1*num2+"<br>",document.getElementById("demo4").innerHTML="100/25="+num1/num2+"<br>",document.getElementById("demo5").innerHTML="(100++)="+num1++ +"<br>",num1=100,num1++,document.getElementById("demo6").innerHTML="(num1)="+num1+"<br>",num1=100,document.getElementById("demo7").innerHTML="(++100)="+ ++num1+"<br>",num1=100,++num1,document.getElementById("demo8").innerHTML="(num1)="+num1+"<br>"</script><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符在逻辑语句中使用，用于判断变量或值是否相等。其运<br>算过程需要首先对操作数进行比较，然后返回—个布尔值true 或false 。<br>常用的比较运算符如下：</p><table><thead><tr><th>比较运算符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等千</td></tr><tr><td>==</td><td>等于。只根据表面值进行判断，不涉及数据类型。</td></tr><tr><td>===</td><td>绝对等千。同时根据表面值和数据类型进行判断。</td></tr><tr><td>!=</td><td>不等于。只根据表面值进行判断，不涉及数据类型</td></tr><tr><td>!===</td><td>不绝对等于。同时根据表面值和数据类型进行判断。</td></tr></tbody></table><pre><code class="HTML">比较运算符DEMO:&lt;p id=&quot;demoB1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demoB2&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demoB3&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demoB4&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demoB5&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var age=25;  document.getElementById(&#39;demoB1&#39;).innerHTML=(&quot;age变量的值为：&quot;+age+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demoB2&#39;).innerHTML=(&quot;age&gt;=20：&quot;+(age&gt;=20) +&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demoB3&#39;).innerHTML=(&quot;age&lt;20：&quot;+(age&lt;20)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demoB4&#39;).innerHTML=(&quot;age!=20：&quot;+(age!=20)+&quot;&lt;br&gt;&quot;);  document.getElementById(&#39;demoB5&#39;).innerHTML=(&quot;age&gt;20：&quot;+(age&gt;20)+&quot; &lt;br&gt;&quot; );&lt;/script&gt;</code></pre><p id="demoB1"></p><p id="demoB2"></p><p id="demoB3"></p><p id="demoB4"></p><p id="demoB5"></p><script type="text/javascript">var age=25;document.getElementById("demoB1").innerHTML="age变量的值为："+age+"<br>",document.getElementById("demoB2").innerHTML="age>=20："+(age>=20)+"<br>",document.getElementById("demoB3").innerHTML="age<20："+(20>age)+"<br>",document.getElementById("demoB4").innerHTML="age!=20："+(20!=age)+"<br>",document.getElementById("demoB5").innerHTML="age>20："+(age>20)+" <br>"</script><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>逻辑运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与，只有当两个操作数 a、b 的值都为 true 时， a &amp;&amp; b 的值才为 true;否则为 false</td></tr><tr><td>||</td><td>逻辖或，只有当两个操作数 a、b 的值都为 false 时， a || b 的值才为 false</td></tr><tr><td>!</td><td>逻辑非，!true 的值为 false, 而 !false 的值为 true</td></tr></tbody></table><pre><code class="html">&lt;pre&gt;&lt;script type=&quot;text/javascript&quot;&gt;   var a=2,b=3,result;   document.writeln(&quot;a=2,b=3&quot;);   document.write(&quot;a&amp;lt;b&amp;&amp;a&amp;lt;=b :&quot;); result=a&lt;b&amp;&amp;a&lt;=b; document.writeln(result);   document.write(&quot;a&amp;lt;b&amp;&amp;a&amp;gt;b :&quot;); result=a&lt;b&amp;&amp;a&gt;b; document.writeln(result);   document.write (&quot;a&amp;lt;b||a&amp;gt;b: &quot;); result=a&lt;b||a&gt;b; document.writeln(result);   document.write (&quot;a&amp;gt;b&amp;&amp;a&amp;gt;=b :&quot;); result=a&gt;b||a&gt;=b; document.writeln(result);   document.write (&quot;!(a&amp;lt;b):&quot;); result=!(a&lt;b); document.writeln(result);   document.write (&quot;!(a&amp;gt;b): &quot;) ; result=!(a&gt;b); document.writeln(result);&lt;/script&gt;&lt;/pre&gt;</code></pre><pre><script type="text/javascript">var a=2,b=3,result;document.writeln("a=2,b=3"),document.write("a&lt;b&&a&lt;=b :"),result=b>a&&b>=a,document.writeln(result),document.write("a&lt;b&&a&gt;b :"),result=b>a&&a>b,document.writeln(result),document.write("a&lt;b||a&gt;b: "),result=b>a||a>b,document.writeln(result),document.write("a&gt;b&&a&gt;=b :"),result=a>b||a>=b,document.writeln(result),document.write("!(a&lt;b):"),result=!(b>a),document.writeln(result),document.write("!(a&gt;b): "),result=!(a>b),document.writeln(result)</script></pre><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>最基本的赋值运算符是等千号 “=” ，用于对变量进行赋值。其他运算符可以和赋值运算符 “=”<br>联合使用，构成组合赋值运算符。</p><pre><code class="html">&lt;script&gt;    var a=3,b=2;    document.write(&quot;a+b=&quot;);a+=b;document.wirte(a+&quot;&lt;br&gt;&quot;);    document.write(&quot;a-=b=&quot;);a-=b;document.wirte(a+&quot;&lt;br&gt;&quot;);&lt;/script&gt;</code></pre><script>var a=3,b=2;document.write("a+b="),a+=b,document.write(a+"<br>"),a=3,b=2,document.write("a-=b="),a-=b,document.write(a+"<br>"),a=3,b=2,document.write("a*=b="),a*=b,document.write(a+"<br>"),a=3,b=2,document.write("a*=b="),a++,document.write(a+"<br>")</script><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><pre><code class="html">&lt;button onclick=&quot;tjysf()&quot;&gt;试一试&lt;/button&gt;&lt;script type=&quot;text/javascript &quot;&gt;function tjysf(){   var i=3,j=4;   alert((++i==j++)?true:false);}&lt;/script&gt;</code></pre><p><button onclick="tjysf()">试一试</button></p><script type="text/javascript">function tjysf(){var t=3,a=4;alert(++t==a++?!0:!1)}</script><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简单入门 01基础篇</title>
      <link href="/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-01%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2020/03/JS%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-01%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 是属于 HTML 和 Web 的编程语言。用于开发交互式的 WEB 页面，JS不需要进行编译，而是直接嵌入在 HTML 中。</p><ul><li>HTML 定义网页的内容</li><li>CSS 规定网页的布局</li><li>JavaScript 对网页行为进行编程</li></ul><blockquote><p>JavaScript 和 Java 是完全不同的语言，不论是概念还是设计。JavaScript 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。ECMA-262 是其官方名称。ECMAScript 6 （发布于 2015 年）是最新的 JavaScript 版本。</p></blockquote><p>JavaScript 在 1995 年由 Netscape 公司的 Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为 Netscape 与 Sun 合作，Netscape 管理层希望它外观看起来像 Java，因此取名为 JavaScript。但实际上它的语法风格与 Self 及 Scheme 较为接近。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>JavaScript 是一种基于对象和事件驱动并具有安全性能的解释性脚本语言：</p><ul><li>解释性：JavaScript 不同于编译性语言，JS直接在浏览器中执行</li><li>基于对象：JavaScript 是一种基于对象的语言，它的许多功能来自于脚本环境中对象的方法和脚本的互相作用。在 JS 中，既可以使用预定义对象，也可以使用自定义对象。</li><li>事件驱动：JavaScript 可以直接对用户或客户的输入输出做出响应，无需经过 WEB 服务程序，而是以事件驱动的方式进行的。如按下鼠标，移动窗口，选择菜单等事件发生后，可以引起事件的响应。</li><li>跨平台行：JS 的运行依赖于浏览器本身，与操作环境无关。</li><li>安全性：JS 是一种安全性语言，它不允许访问本地硬盘，也不能对网络文档进行修改删除，而只能通过浏览器实现信息浏览或动态交互。</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>以 WEB 为例，以下是几种常见的应用：</p><ul><li>验证用户输入的内容</li><li>网页动画效果</li><li>窗口的应用（浮窗，广告等）</li><li>文字特效</li><li>……</li></ul><h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><p>JavaScript 有两种引入方式，一种是在 HTML 文档中直接嵌入 JavaScript，称为内嵌式，另外一种是链接外部的 JavaScript 脚本文件。</p><h3 id="内嵌式"><a href="#内嵌式" class="headerlink" title="内嵌式"></a>内嵌式</h3><p>该语法中，TYPE 属性用来指定 HTML 文档引用的脚本语言类型，当 TYPE 属性值为 text/javascript 时，表示 script 标签内引用的是 JS 脚本。</p><p>通常，script 标签会放在 head 标签内，称为头脚本，在 body 标签内的，称为体脚本。</p><pre><code class="html">标准格式：&lt;head&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    document.write(&quot;把JS代码写在&lt;script&gt;标签内！&quot;)    &lt;/script&gt;&lt;/head&gt;</code></pre><head><script type="text/javascript">document.write("把JS代码写在&#60;script&#62;标签内！")</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/feed.xml" title="帆的自留地" type="application/atom+xml"></head><h3 id="外链式"><a href="#外链式" class="headerlink" title="外链式"></a>外链式</h3><p>当脚本代码比较复杂，或者同一段代码需要被多个网页引用的时候，可以将这些脚本代码放置在一个扩展名为 .js 的文件里。然后通过外链式引入该 js 文件。</p><pre><code class="html">标准格式：&lt;script type=&quot;text/javascript&quot; src=&quot;https://填写路径/666.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>JavaScript 程序按照在 HTML 文件中出现的先后次序逐行执行。如果某些代码（函数，全局变量等）要在整个 HTML 文件中使用的，最好将其放在 head 标签中。函数体内的代码只有所在函数被被其他语句调用的时候，才会运行。</p><h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><p>在输入关键字，函数名，变量名和其他标识符的时候，必须区分大小写。（变量 username 和 变量 UserName 是两个不同的变量）。</p><h3 id="每行结尾分号可以省略"><a href="#每行结尾分号可以省略" class="headerlink" title="每行结尾分号可以省略"></a>每行结尾分号可以省略</h3><p>但通常建议添加分号以保证程序的严谨性。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code class="javascript">单行注释：// 使用双斜杠表示单行注释</code></pre><pre><code class="javascript">多行注释：/* 使用斜杠表和星号表示多行注释 */</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 07-定位，离线和WEB存储</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-07-%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%A6%BB%E7%BA%BF%E5%92%8CWEB%E5%AD%98%E5%82%A8/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-07-%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%A6%BB%E7%BA%BF%E5%92%8CWEB%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>在HTML5网页代码中，通过一些有用的API，可以查找访问者当前的位置。若要体验本文里所有的案例，请务必在浏览器授权本站使用你的地理信息位置，否则将无法定位。</p><h2 id="地理定位的函数"><a href="#地理定位的函数" class="headerlink" title="地理定位的函数"></a>地理定位的函数</h2><p>通过地理定位可以确定用户的当前位置，并能获取用户地理位置的变化情况。其中，比较常用的就是 API 中的 getCurrentpositong() 函数。</p><blockquote><p>API 是应用程序的编程接口，是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件以访问一组例程的能力。</p></blockquote><p>getCurrentpositong() 函数的语法格式如下：</p><pre><code class="javascript">navigator.geolocation.getCurrentPosition( successCallback, errorCallback, options)</code></pre><blockquote><p>Navigator 对象包含有关浏览器的信息。注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。</p></blockquote><p>其中 successCallback 参数是指在位置成功获取时用户想要调用的函数名称；errorCallback 参数是指在位置获取失败时用户想要调用的函数名称；options 参数指出地理定位时的属性设置。访问用户位置是耗时的操作，同时出于隐私问题，还要取得用户的同意。</p><h3 id="successCallback"><a href="#successCallback" class="headerlink" title="successCallback:"></a>successCallback:</h3><p>该对象包含两个属性：coords 和 timestamp。</p><p>若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>coords.latitude</td><td>（始终）十进制数的纬度</td></tr><tr><td>coords.longitude</td><td>（始终）十进制数的经度</td></tr><tr><td>coords.accuracy</td><td>（始终）位置精度</td></tr><tr><td>coords.altitude</td><td>海拔，海平面以上以米计</td></tr><tr><td>coords.altitudeAccuracy</td><td>位置的海拔精度</td></tr><tr><td>coords.heading</td><td>方向，从正北开始以度计</td></tr><tr><td>coords.speed</td><td>速度，以米/每秒计</td></tr><tr><td>timestamp</td><td>响应的日期/时间</td></tr></tbody></table><h3 id="errorCallback"><a href="#errorCallback" class="headerlink" title="errorCallback:"></a>errorCallback:</h3><p>返回的错误代码包含两个属性：message：错误信息；code：错误代码</p><p>错误代码包含四个值：unknow_error: 表示不包括在其他错误代码中的错误，可以在 message 中查找信息。permission_denied: 表示用户拒绝浏览器获取位置信息的请求。position unavalablf: 表示网络不可用或者连接不到卫星。timeout: 表示获取超时时。必须在 options 中指定了 timeout 值时才有可能发生这种错误。</p><h3 id="PositionOptions"><a href="#PositionOptions" class="headerlink" title="PositionOptions:"></a>PositionOptions:</h3><p>数据格式为 json，有3个属性：</p><p>enableHighAcuracy：布尔值，表示是否启用高精确度模式，如果启用这个模式，浏览器在获取位置信息时可能需要耗费更多的时间。Timeout: 整数，表示浏览器需要在指定的时间内获取位置信息，否则触发 errorCallback。maximumAge: 整数/常量，表示浏览器重新获取位置信息的时间间隔。</p><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>通过上面的 API 说明，就可以用下面的 <strong>displayOnMap函数</strong> 来调用经纬度坐标：</p><pre><code class="javascript">function displayOnMap(position){    var latitude=position.coords.latitude;    //经度    var longitude=position.coords.longitude;    //纬度}</code></pre><p>下面是定位 API 的一些具体使用案例：</p><h4 id="最基本使用"><a href="#最基本使用" class="headerlink" title="最基本使用"></a>最基本使用</h4><pre><code class="html">01 直接输出样例：&lt;p id=&quot;demo&quot;&gt;暂未获取地理位置&lt;/p&gt;&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);navigator.geolocation.getCurrentPosition(    function showPosition(position)      {          x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +           &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;          });&lt;/script&gt;</code></pre><p id="demo">暂未获取地理位置</p><script>var x=document.getElementById("demo");navigator.geolocation.getCurrentPosition(function(o){x.innerHTML="Latitude: "+o.coords.latitude+"<br />Longitude: "+o.coords.longitude})</script><blockquote><p>上面展示的是一个最基本的案例，我对此解读如下：首先创建一个 id 为 demo 的段落，然后编写 JavaScript 脚本。脚本中声明变量 x 指向 id 为 demo 的段落。</p><p>接下来调用 getCurrentPosition() 的 API，因为 API 需要配合回调的函数，因此这里新建了一个 showPosition 的函数，并新建一个名为 position 的变量。变量 position 的值会在 getCurrentPosition() 函数执行时，被传递参数，因此接下来只要输出 position 被传参后的的信息即可。</p></blockquote><p>因此，现在 position.coords.latitude 和 position.coords.longitude 里的值，就是精度纬度了。使用 x.innerHTML 就改变了前面段落 <code>&lt;p id=&quot;demo&quot;&gt; &lt;/p&gt;</code> 里的值了！</p><h4 id="使用按钮并检查浏览器"><a href="#使用按钮并检查浏览器" class="headerlink" title="使用按钮并检查浏览器"></a>使用按钮并检查浏览器</h4><pre><code class="html">02 按钮输出并执行浏览器兼容检查：&lt;p id=&quot;demoA&quot;&gt;点击这个按钮，获得您的坐标：&lt;/p&gt;&lt;button onclick=&quot;getLocationOne()&quot;&gt;试一下&lt;/button&gt;&lt;script&gt;var a=document.getElementById(&quot;demoA&quot;);function getLocationOne()  {  if (navigator.geolocation)    {    navigator.geolocation.getCurrentPosition(showPositionOne);    }  else{a.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}  }function showPositionOne(positionA)  {  a.innerHTML=&quot;Latitude: &quot; + positionA.coords.latitude +   &quot;&lt;br /&gt;Longitude: &quot; + positionA.coords.longitude;      }&lt;/script&gt;</code></pre><p id="demoA">点击这个按钮，获得您的坐标：</p><button onclick="getLocationOne()">试一下</button><script>function getLocationOne(){navigator.geolocation?navigator.geolocation.getCurrentPosition(showPositionOne):a.innerHTML="Geolocation is not supported by this browser."}function showPositionOne(o){a.innerHTML="Latitude: "+o.coords.latitude+"<br />Longitude: "+o.coords.longitude}var a=document.getElementById("demoA")</script><blockquote><p>在这段代码中，为了实现点击按钮显示经纬度，因此为按钮点击添加了 onclick=”getLocationOne()” 事件。点击后触发 getLocationOne() 函数，该函数使用一个 if 语句对浏览器是否能对 navigator.geolocation 返回值进行了判断。如果有返回值，就执行后面的函数调用。</p><p>此处为 getLocationOne() 指定了回调函数 showPositionOne() 并使用 positionA 变量来传递参数。</p></blockquote><pre><code>判断浏览器是否支持地理位置服务：if (&quot;geolocation&quot; in navigator) {  /* 地理位置服务可用 */} else {  /* 地理位置服务不可用 */}</code></pre><p>在 mozilla 官方文档中,如果 geolocation 对象存在，那么地理位置服务可用。</p><h4 id="输出报错"><a href="#输出报错" class="headerlink" title="输出报错"></a>输出报错</h4><pre><code class="html">03 异常时输出错误信息：&lt;p id=&quot;demoB&quot;&gt;点击这个按钮，获得您的坐标：&lt;/p&gt;&lt;button onclick=&quot;getLocationTwo()&quot;&gt;试一下&lt;/button&gt;&lt;script&gt;var b=document.getElementById(&quot;demoB&quot;);function getLocationTwo()  {  if (navigator.geolocation)    {    navigator.geolocation.getCurrentPosition(showPositionTwo,showError);    }  else{b.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}  }function showPositionTwo(positionB)  {  b.innerHTML=&quot;Latitude: &quot; + positionB.coords.latitude +   &quot;&lt;br /&gt;Longitude: &quot; + positionB.coords.longitude;      }function showError(error)  {  switch(error.code)     {    case error.PERMISSION_DENIED:      b.innerHTML=&quot;User denied the request for Geolocation.&quot;      break;    case error.POSITION_UNAVAILABLE:      b.innerHTML=&quot;Location information is unavailable.&quot;      break;    case error.TIMEOUT:      b.innerHTML=&quot;The request to get user location timed out.&quot;      break;    case error.UNKNOWN_ERROR:      b.innerHTML=&quot;An unknown error occurred.&quot;      break;    }  }&lt;/script&gt;</code></pre><p id="demoB">点击这个按钮，获得您的坐标：</p><button onclick="getLocationTwo()">试一下</button><script>function getLocationTwo(){navigator.geolocation?navigator.geolocation.getCurrentPosition(showPositionTwo,showError):b.innerHTML="Geolocation is not supported by this browser."}function showPositionTwo(o){b.innerHTML="Latitude: "+o.coords.latitude+"<br />Longitude: "+o.coords.longitude}function showError(o){switch(o.code){case o.PERMISSION_DENIED:b.innerHTML="User denied the request for Geolocation.";break;case o.POSITION_UNAVAILABLE:b.innerHTML="Location information is unavailable.";break;case o.TIMEOUT:b.innerHTML="The request to get user location timed out.";break;case o.UNKNOWN_ERROR:b.innerHTML="An unknown error occurred."}}var b=document.getElementById("demoB")</script><blockquote><p>这里创建了一个 showError(error) 的函数作为 getCurrentPosition() 执行错误时的回调对象。 errorCallback 的参数传递到 error 变量中。</p></blockquote><h4 id="其他有趣的方法"><a href="#其他有趣的方法" class="headerlink" title="其他有趣的方法"></a>其他有趣的方法</h4><ul><li>watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。</li><li>clearWatch() - 停止 watchPosition() 方法</li></ul><p>下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）：</p><pre><code class="html">&lt;p id=&quot;demoC&quot;&gt;点击这个按钮，获得您的坐标：&lt;/p&gt;&lt;button onclick=&quot;getLocationThree()&quot;&gt;试一下&lt;/button&gt;&lt;script&gt;var c=document.getElementById(&quot;demoC&quot;);function getLocationThree()  {  if (navigator.geolocation)    {    navigator.geolocation.watchPosition(showPositionThree);    }  else{c.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}  }function showPositionThree(positionC)  {  c.innerHTML=&quot;Latitude: &quot; + positionC.coords.latitude +   &quot;&lt;br /&gt;Longitude: &quot; + positionC.coords.longitude;      }&lt;/script&gt;</code></pre><p id="demoC">点击这个按钮，获得您的坐标：</p><button onclick="getLocationThree()">试一下</button><script>function getLocationThree(){navigator.geolocation?navigator.geolocation.watchPosition(showPositionThree):c.innerHTML="Geolocation is not supported by this browser."}function showPositionThree(o){c.innerHTML="Latitude: "+o.coords.latitude+"<br />Longitude: "+o.coords.longitude}var c=document.getElementById("demoC")</script><blockquote><p>watchPosition() 和 上面提到的 getCurrentPosition() 方法完全一致，可以直接套用。但却能实时跟踪位置变化。</p></blockquote><h3 id="使用地图-API"><a href="#使用地图-API" class="headerlink" title="使用地图 API"></a>使用地图 API</h3><p>为了在地图上显示用户的具体位置，可以利用地图网站的API。下面以使用百度地图为例，需要使用Baidu Maps Javascript API。</p><p>在使用此API前，需要在HTML5页面中添加一个引用，具体代码如下；</p><pre><code class="html">标准引入（适用于多数情况）：&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?type=webgl&amp;v=1.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="html">异步调用（进阶优化选项）：&lt;script type=&quot;text/javascript&quot;&gt; //异步加载js返回callback函数function loadScript() {     var script = document.createElement(&quot;script&quot;);     script.src = &quot;https://api.map.baidu.com/api?v=1.0&amp;type=webgl&amp;ak=这个要自己申请哦&amp;callback=hxfmapint&quot;;    document.body.appendChild(script); } window.onload = loadScript;&lt;/script&gt;</code></pre><p>其中*号代码注册到 key。注册 key 的方法为：在 <a href="http://lbsyun.baidu.com/index.php?title=jspopular" target="_blank" rel="noopener">百度地图开放平台</a> 网页中注册百度地图API，然后输入需要内置百度地图页面的URL地址生成API密钥，最后将key文件复制保存。</p><p>其中百度地图的更细致的使用文档需要参考百度官方文档：<a href="http://lbs.baidu.com/" target="_blank" rel="noopener">lbs.baidu.com</a></p><pre><code class="html">完整的带定位的异步调用接口使用实例：&lt;style type=&quot;text/css&quot;&gt;    #hxfmap {width: 100%;height: 400px;overflow: hidden;margin:0;font-family:&quot;微软雅黑&quot;;}&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt; //异步加载js返回callback函数function loadScript() {     var script = document.createElement(&quot;script&quot;);     script.src = &quot;https://api.map.baidu.com/api?v=1.0&amp;type=webgl&amp;ak=这个要自己申请哦&amp;callback=hxfmapint&quot;;    document.body.appendChild(script); } window.onload = loadScript; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;function hxfmapint() {     // 按住鼠标右键，修改倾斜角和角度    // GL版命名空间为BMapGL    var map = new BMapGL.Map(&quot;allmap&quot;);    // 创建Map实例    var point = new BMapGL.Point(121.548899, 29.870192);    map.centerAndZoom(point,19);    map.enableScrollWheelZoom(true);     //开启鼠标滚轮缩放    map.addEventListener(&#39;click&#39;, function(e) {        alert(&#39;点击的经纬度：&#39; + e.latlng.lng + &#39;, &#39; + e.latlng.lat);        var mercator = map.lnglatToMercator(e.latlng.lng, e.latlng.lat);        alert(&#39;点的墨卡托坐标：&#39; + mercator[0] + &#39;, &#39; + mercator[1]);    });    // 实现定位功能    var geolocation = new BMapGL.Geolocation();    geolocation.getCurrentPosition(function(r){        if(this.getStatus() == BMAP_STATUS_SUCCESS){            var mk = new BMapGL.Marker(r.point);            map.addOverlay(mk);            map.panTo(r.point);            alert(&#39;您的位置：&#39;+r.point.lng+&#39;,&#39;+r.point.lat);        }        else {            alert(&#39;failed&#39;+this.getStatus());        }            },{enableHighAccuracy: true})}&lt;/script&gt;&lt;div id=&quot;hxfmap&quot;&gt;这里将显示地图&lt;/div&gt;</code></pre><style type="text/css">#hxfmap{width:100%;height:400px;overflow:hidden;margin:0;font-family:"微软雅黑"}</style><script type="text/javascript">function loadScript(){var a=document.createElement("script");a.src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=tegOOlMnipQTOgHLwFtzHukBKNjIHzUp&callback=hxfmapint",document.body.appendChild(a)}window.onload=loadScript</script><script type="text/javascript">function hxfmapint(t){var t,a=new BMapGL.Map("hxfmap"),e=new BMapGL.Point(121.548899,29.870192);a.centerAndZoom(e,19),a.enableScrollWheelZoom(!0),a.addEventListener("click",function(t){alert("点击的经纬度："+t.latlng.lng+", "+t.latlng.lat);var e=a.lnglatToMercator(t.latlng.lng,t.latlng.lat);alert("点的墨卡托坐标："+e[0]+", "+e[1])});var n=new BMapGL.ScaleControl;a.addControl(n);var l=new BMapGL.ZoomControl;a.addControl(l),a.setHeading(64.5),a.setTilt(40);var o={position:e,offset:new BMapGL.Size(30,-30)},i=new BMapGL.Label("喵喵喵，我是 Emptinessboy",o);if(i.setStyle({color:"#555",fontSize:"12px",height:"20px",lineHeight:"20px",fontFamily:"微软雅黑"}),a.addOverlay(i),1==t){var r=new BMapGL.Geolocation;r.getCurrentPosition(function(t){if(this.getStatus()==BMAP_STATUS_SUCCESS){var e=new BMapGL.Marker(t.point);a.addOverlay(e),a.panTo(t.point),alert("您的位置："+t.point.lng+","+t.point.lat)}else alert("failed"+this.getStatus())},{enableHighAccuracy:!0})}}</script><p><button onclick="hxfmapint(!0)">展示我的定位</button></p><div id="hxfmap"></div><p>哈哈哈，上述案例中，可以给地图设一个初始经纬度坐标点，比如我设置的我高中的坐标 (121.548899, 29.870192)</p><h3 id="为什么无法定位？"><a href="#为什么无法定位？" class="headerlink" title="为什么无法定位？"></a>为什么无法定位？</h3><blockquote><p>Secure context：This feature is available only in secure contexts (HTTPS), in some or all supporting browsers.（只有网站升级到 HTTPS 才能使用地理位置 API）</p></blockquote><blockquote><p>注意: 出于安全考虑，当网页请求获取用户位置信息时，用户会被提示进行授权。注意不同浏览器在请求权限时有不同的策略和方式。Windows10在未开启定位的情况下无法获取位置</p></blockquote><h2 id="H5-离线-Web-应用"><a href="#H5-离线-Web-应用" class="headerlink" title="H5 离线 Web 应用"></a>H5 离线 Web 应用</h2><p>为了能在离线的情况下访问网站，可以采用HTML5的离线Web功能。应用程序缓存为应用带来三个优势：</p><ol><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ol><p>在 HTML5 中新增了本地缓存（也就是 HTML 离线 Web 应用），主要是通过应用程序缓存整个离线网站的 HTML、CSS、Javascript、网站图像和资源。当服务器没有和 Internet 建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。另外，如果网站发生了变化，则应用程序缓存将重新加载变化的数据文件。</p><h3 id="应用程序缓存-manifest"><a href="#应用程序缓存-manifest" class="headerlink" title="应用程序缓存 manifest"></a>应用程序缓存 manifest</h3><p>manifest 文件是一个简单文本文件，在该文件中以清单的形式列举了需要被缓存或不需要被缓存的资源文件的文件名称，以及这些资源文件的访问路径。</p><p>Manifest 文件把指定的资源文件类型分为三类，分别是 “CACHE” “NETWORK” 和 “FALLBACK”。这三类的含义分别如下：</p><p>（1）CACHE 类别：该类别指定需要被缓存在本地的资源文件。这里需要特别注意的是，在为某个页面指定需要本地缓存的资源文件时，不需要把这个页面本身指定在 CACHE 类型中，因为如果一个页面具有 manifest 文件，则浏览器会自动对这个页面进行本地缓存。</p><p>（2）NETWORK 类别：该类别为不进行本地缓存的资源文件，这些资源文件只有当客户端与服务器端建立连接的时候才能访问。</p><p>（3）FALLBACK 类别：该类别中指定两个资源文件，其中一个资源文件为能够在线访问时使用的资源文件，另一个资源文件为不能在线访问时使用的备用资源文件。</p><h4 id="Manifest-基础"><a href="#Manifest-基础" class="headerlink" title="Manifest 基础"></a>Manifest 基础</h4><p>如需启用应用程序缓存，需要在文档的 <code>&lt;html&gt;</code> 标签中包含 manifest 属性：</p><pre><code class="html">&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt;...&lt;/html&gt;</code></pre><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p><p>manifest 文件的建议的文件扩展名是：”.appcache”。</p><blockquote><p>注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p></blockquote><h4 id="Manifest-语法"><a href="#Manifest-语法" class="headerlink" title="Manifest 语法"></a>Manifest 语法</h4><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p><p>文章的前面部分已经提及，manifest 文件可分为三个部分：</p><ul><li>CACHE MANIFEST</li><li>NETWORK</li><li>FALLBACK</li></ul><p><strong><em>CACHE MANIFEST</em></strong></p><p>第一行，CACHE MANIFEST，是必需的：</p><pre><code>CACHE MANIFEST/theme.css/logo.gif/main.js</code></pre><p>上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。</p><p><strong><em>NETWORK</em></strong></p><p>下面的 NETWORK 小节规定文件 “login.asp” 永远不会被缓存，且离线时是不可用的：</p><pre><code>NETWORK:login.asp</code></pre><p>可以使用星号来指示所有其他资源/文件都需要因特网连接：</p><pre><code>NETWORK:*</code></pre><p><strong><em>FALLBACK</em></strong><br>下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件：</p><pre><code>FALLBACK:/html5/ /404.html</code></pre><p>其中第一个 URI 是资源，第二个是替补。</p><h4 id="完整的-Manifest-文件"><a href="#完整的-Manifest-文件" class="headerlink" title="完整的 Manifest 文件"></a>完整的 Manifest 文件</h4><pre><code>CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html5/ /404.html</code></pre><p>重要的提示：以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。</p><h4 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h4><p>用户可以为每一个页面单独指定一个mainifest文件，也可以对整个Web应用程序指定一个总的manifest文件。</p><p>一旦应用被缓存，它就会保持缓存直到发生下列情况：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改（通过注释修改版本号）</li><li>由程序来更新应用缓存</li></ul><p>一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使已经修改了服务器上的文件。为了确保浏览器更新缓存，则需要更新 manifest 文件。</p><blockquote><p>注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p></blockquote><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><pre><code class="html">这里是样例的 HTML&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;http-manifest.appcache&quot;&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;body&gt;&lt;script src=&quot;demo_time.js&quot;&gt;&lt;/script&gt;&lt;p id=&quot;timePara&quot;&gt;&lt;button onclick=&quot;getDateTime()&quot;&gt;获得日期和事件&lt;/button&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;logo.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;首次访问后尝试切断网络，此页面可以被离线访问&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://coding.emptinessboy.com/&quot;&gt;回文章&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>这里是样例的 manifestCACHE MANIFESTdemo_time.jslogo.png</code></pre><p><a href="https://huxiaofan.com/doc/http-manicache/" target="_blank" rel="noopener">演示地址-点我打开</a></p><blockquote><p>第一次访问演示地址后，脱机仍然可以访问</p></blockquote><p><a href="https://up.media.everdo.cn/image/HqR3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/17/html-manifest.md.jpg" alt="html-manifest.md.jpg"></a></p><h2 id="Web-存储"><a href="#Web-存储" class="headerlink" title="Web 存储"></a>Web 存储</h2><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><p>在 HTML5 中，数据不是由 HTTP 请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。</p><p>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。本地存储和 Cookies 扮演着类似的角色，但是它们有以下的区别。</p><p>（1）本地存储是仅存储在用户的硬盘上并等待用户读取，而 Cookies 是在服务器上读取。</p><p>（2）本地存储仅供客户端使用，如果需要服务器端根据存储数值作出反映，就应该使用 Cookies。</p><p>（3）读取本地存储不会影响到网络带宽，但是使用 Cookies 将会发送到服务器，这样会影响到网络带宽，无形中增加了成本。</p><p>（4）从存储容量上看，本地存储可存储多达 5MB 的数据，而 Cookies 最多只能存储 4KB 的数据信息。</p><p>对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。HTML5 使用 JavaScript 来存储和访问数据。</p><h3 id="sessionStorage-函数"><a href="#sessionStorage-函数" class="headerlink" title="sessionStorage 函数"></a>sessionStorage 函数</h3><p>sessionStorage 函数针对一个 session 进行数据存储。如果用户关闭浏览器窗口，则数据会被自动删除。创建一个 sessionStorage 函数的基本语法格式如下：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;sessionStorage.abc=&quot; &quot;;&lt;/script&gt;</code></pre><p>一个最简单的使用 sessionStorage 存放并读取变量例子：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;sessionStorage.name=&quot;HELLO，我是 Emptinessboy&quot;;document.write(sessionStorage.name);&lt;/script&gt;</code></pre><p><script type="text/javascript">sessionStorage.name="HELLO，我是 Emptinessboy",document.write(sessionStorage.name)</script></p><p>下面一个计数器案例，刷新页面会看到计数器在增长，关闭浏览器或标签页，然后再试一次，计数器会清零。</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;if (sessionStorage.pagecount)    {    sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;    }else    {    sessionStorage.pagecount=1;    }document.write(&quot;当前页面会话访问了 &quot; + sessionStorage.pagecount + &quot; 次！&quot;);&lt;/script&gt; </code></pre><p><script type="text/javascript">sessionStorage.pagecount?sessionStorage.pagecount=Number(sessionStorage.pagecount)+1:sessionStorage.pagecount=1,document.write("当前页面会话访问了 "+sessionStorage.pagecount+" 次！")</script></p><h3 id="localStorage-函数"><a href="#localStorage-函数" class="headerlink" title="localStorage 函数"></a>localStorage 函数</h3><p>与 seessionStorage 函数不同，localStorage 函数存储的数据没有时间限制。也就是说网页浏览者关闭网页很长一段时间后，再次打开此网页时，数据依然可用。</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;localStorage.abc=&quot; &quot;;&lt;/script&gt;</code></pre><p>一个最简单的使用 localStorage 存放并读取变量例子：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;sessionStorage.name=&quot;HELLO，我是 Emptinessboy&quot;;document.write(localStorage.name);&lt;/script&gt;</code></pre><p><script type="text/javascript">localStorage.name="HELLO，我是 Emptinessboy",document.write(localStorage.name)</script></p><p>下面一个计数器案例，刷新页面会看到计数器在增长，关闭浏览器窗口，然后再试一次，计数器会继续计数。</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;if (localStorage.pagecount)    {    localStorage.pagecount=Number(localStorage.pagecount) +1;    }else    {    localStorage.pagecount=1;    }document.write(&quot;你一共访问这个页面 &quot; + localStorage.pagecount + &quot; 次了！&quot;);&lt;/script&gt;</code></pre><p><script type="text/javascript">localStorage.pagecount?localStorage.pagecount=Number(localStorage.pagecount)+1:localStorage.pagecount=1,document.write("你一共访问这个页面 "+localStorage.pagecount+" 次了！")</script></p><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ol><li><p>不同的浏览器 Web 存储是独立的</p></li><li><p>主流浏览器都支持 localStorage 和 sessionStorage</p></li></ol><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 06-音频和视频</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-06-%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-06-%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>目前，在网页上没有关于音频和视频的标准，多数音频和视频都是通过插件来播放的，为此，HTML5新增了音频和视频的标记。</p><h2 id="lt-audio-gt-标记"><a href="#lt-audio-gt-标记" class="headerlink" title="&lt;audio&gt; 标记"></a><code>&lt;audio&gt;</code> 标记</h2><p>与 HTML4 相比，HTML5 新增了 <code>&lt;audio&gt;</code> 标记，规定了一种包含音频的标准方法。</p><h3 id="audio-概述"><a href="#audio-概述" class="headerlink" title="audio 概述"></a>audio 概述</h3><p><code>&lt;audio&gt;</code> 标记主要是定义播放声音文件或音频流的标准。支持3种音频格式，分别为ogg、mp3和wav。如果需要在HTML5网页中播放音频，则输入的基本格式如下：</p><blockquote><p>翻车警告！！下方音频为本人蜜汁鬼畜录音，谨慎播放！！由于播放下方音频导致的，双耳失聪，精神失常等等后果与本站无关！！</p></blockquote><pre><code class="html">&lt;audio src=&quot;https://media.everdo.cn/tank/xiaofan/audio/2019/ksong_moumou.mp3&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持新型播放控件&lt;/audio&gt;</code></pre><p><audio src="https://media.everdo.cn/tank/xiaofan/audio/2019/ksong_moumou.mp3" controls>您的浏览器不支持新型播放控件</audio></p><p>其中src属性是规定要播放的音频地址，controls属性是提供添加播放、暂停和音量的控件。在 <code>&lt;audio&gt;</code> 与 <code>&lt;/audio&gt;</code> 之间插入的内容是供不支持 audio 元素的浏览器显示的。</p><h3 id="audio-标记的属性"><a href="#audio-标记的属性" class="headerlink" title="audio 标记的属性"></a>audio 标记的属性</h3><p><code>&lt;audio&gt;</code> 标记的常见属性和含义如下表所示。</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>url</td><td>要播放的音频的 URL。</td></tr><tr><td>controls</td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>preload</td><td>preload</td><td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td>autoplay</td><td>autoplay</td><td>如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td>loop</td><td>loop</td><td>如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td>muted</td><td>muted</td><td>规定视频输出应该被静音。</td></tr></tbody></table><p>另外，<code>&lt;audio&gt;</code>标记可以通过source属性添加多个音频文件。具体格式如下：</p><pre><code class="html">&lt;audio controls=&quot;controls&quot;&gt;    &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt;    &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;    您的浏览器不支持新型播放控件&lt;/audio&gt;</code></pre><h3 id="音频解码器"><a href="#音频解码器" class="headerlink" title="音频解码器"></a>音频解码器</h3><p>现代浏览器对音频的兼容问题已经很少遇见</p><h2 id="lt-video-gt-标记"><a href="#lt-video-gt-标记" class="headerlink" title="&lt;video&gt; 标记"></a><code>&lt;video&gt;</code> 标记</h2><p><code>&lt;video&gt;</code> 是一种统一的包含视频的标准方法。与 HTML4 相比，HTML5 新增了 <code>&lt;video&gt;</code> 标记。</p><h3 id="video-概述"><a href="#video-概述" class="headerlink" title="video 概述"></a>video 概述</h3><p>video 标记主要是定义播放视频文件或视频流的标准。支持3种视频格式，分别为 Ogg、WebM 和 MPEG4。</p><p>如果需要在 HTML5 网页中播放视频，输入的基本格式如下：</p><blockquote><p>翻车警告！！下方视频为本人不知道咋剪出来的旅行短片，谨慎播放！！由于播放下方视频导致的，双耳失聪，精神失常等等后果与本站无关！！</p></blockquote><p>视频博客链接： <a href="https://huxiaofan.com/travel/vlog-zhoushan/" target="_blank" rel="noopener">Blog</a> / 视频B站链接： <a href="https://huxiaofan.com/go/?url=https://www.bilibili.com/video/av57628004" target="_blank" rel="noopener">av57628004</a></p><pre><code class="html">&lt;video src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持新型播放控件&lt;/video&gt;</code></pre><p><video src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" width="100%" controls>您的浏览器不支持新型播放控件</video></p><p>另外，在 <code>&lt;video&gt;</code> 与 <code>&lt;/video&gt;</code> 之间插入的内容是供不支持video元素的浏览器显示的。</p><h3 id="video-标记的属性"><a href="#video-标记的属性" class="headerlink" title="video 标记的属性"></a>video 标记的属性</h3><p><code>&lt;video&gt;</code> 标记的常见属性和含义如下表所示：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>url</td><td>要播放的视频的 URL。</td></tr><tr><td>poster</td><td>URL</td><td>规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</td></tr><tr><td>controls</td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>preload</td><td>preload</td><td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td>autoplay</td><td>autoplay</td><td>如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td>width</td><td>pixels</td><td>设置视频播放器的宽度。</td></tr><tr><td>height</td><td>pixels</td><td>设置视频播放器的高度。</td></tr><tr><td>loop</td><td>loop</td><td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td>muted</td><td>muted</td><td>规定视频的音频输出应该被静音。</td></tr></tbody></table><p>由上表可知，用户可以自定义视频文件显示的大小。例如，如果想让视频以320×240像素大小显示，就可以加入width和height属性。具体格式如下：[插图]</p><pre><code class="html">&lt;video width=&quot;300&quot; height=&quot;200&quot; src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持新型播放控件&lt;/video&gt;</code></pre><p><video width="300" height="200" src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" controls>您的浏览器不支持新型播放控件</video></p><p>另外，<code>&lt;video&gt;</code> 标记可以通过 source 属性添加多个视频文件，具体格式如下：</p><pre><code class="html">&lt;video controls=&quot;controls&quot;&gt;    &lt;source src=&quot;h264.mp4&quot; type=&quot;video/mpeg&quot; /&gt;    &lt;source src=&quot;h264.ogg&quot; type=&quot;video/ogg&quot; /&gt;    您的浏览器不支持新型播放控件&lt;/video&gt;</code></pre><h3 id="视频解码器"><a href="#视频解码器" class="headerlink" title="视频解码器"></a>视频解码器</h3><p>目前，在 HTML5 中，使用比较多的视频解码文件是 Theora、H.264 和 VP8。（截止文章截稿前 H.265 还不能被 chrome 浏览器支持，但已经可以被微软 Chromium 内核的新版 edge 浏览器所支持！！！ 老款 edge 并不支持）</p><blockquote><p>这里提供一个 H.265 视频测试链接，可以看到如下图 chrome 是只有声音没有画面的<br><a href="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h265.mp4" target="_blank" rel="noopener">https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h265.mp4</a></p></blockquote><p><a href="https://up.media.everdo.cn/image/HrZs" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/15/html-h265.jpg" alt="html-h265.jpg"></a></p><h2 id="音频和视频中的属性"><a href="#音频和视频中的属性" class="headerlink" title="音频和视频中的属性"></a>音频和视频中的属性</h2><p>在HTML5网页中，关于音频和视频的属性非常多，本节收录几个常用的属性。</p><h3 id="autoplay-属性"><a href="#autoplay-属性" class="headerlink" title="autoplay 属性"></a>autoplay 属性</h3><p>autoplay 控制音频或视频是否在加载后立即开始播放。 其中，autoplay属性的取值包括true和false。设置 autoplay 属性的语法格式如下：</p><pre><code>audio|video.autoplay=true|false</code></pre><p>返回autoplay属性的语法格式如下：</p><pre><code>audio|video.autoplay</code></pre><p>下面是一个具体使用的例子,单击【启动自动播放】按钮，然后单击【检查自动播放状态】按钮，即可看到此时 autoplay 属性为 true。:</p><pre><code class="html">&lt;button onclick=&quot;enableAutoplay()&quot; type=&quot;button&quot;&gt;启动自动播放&lt;/button&gt;&lt;button onclick=&quot;disableAutoplay()&quot; type=&quot;button&quot;&gt;禁用自动播放&lt;/button&gt;&lt;button onclick=&quot;checkAutoplay()&quot; type=&quot;button&quot;&gt;检查自动播放状态&lt;/button&gt;&lt;video id=&quot;video1&quot; controls=&quot;controls&quot;&gt;  &lt;source src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video标签。&lt;/video&gt;&lt;script&gt;myVid=document.getElementById(&quot;video1&quot;);function enableAutoplay(){   myVid.autoplay=true;  myVid.load();} function disableAutoplay(){   myVid.autoplay=false;  myVid.load();} function checkAutoplay(){   alert(myVid.autoplay);} &lt;/script&gt; </code></pre><p><button onclick="enableAutoplay()" type="button">启动自动播放</button><br><button onclick="disableAutoplay()" type="button">禁用自动播放</button><br><button onclick="checkAutoplay()" type="button">检查自动播放状态</button></p><video id="video1" width="100%" controls><source src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video标签。</video><script>function enableAutoplay(){myVidone.autoplay=!0,myVidone.load()}function disableAutoplay(){myVidone.autoplay=!1,myVidone.load()}function checkAutoplay(){alert(myVidone.autoplay)}myVidone=document.getElementById("video1")</script><h3 id="controls-属性"><a href="#controls-属性" class="headerlink" title="controls 属性"></a>controls 属性</h3><p>controls 属性设置或返回浏览器应当显示标准的音频或视频控件。</p><p>标准的音频或视频控件包括播放、暂停、进度条、音量、全屏切换、字幕和轨道。</p><p>设置controls属性的语法格式如下：</p><pre><code>audio|video.controls=true|false</code></pre><p>返回controls属性的语法格式如下：</p><pre><code>audio|video.controls</code></pre><p>下面是一个具体使用的例子,单击【启动控件】按钮，然后单击【检查控件状态】按钮，即可看到此时 controls 属性为 true。:</p><pre><code class="html">&lt;button onclick=&quot;enableControls()&quot; type=&quot;button&quot;&gt;启动控件&lt;/button&gt;&lt;button onclick=&quot;disableControls()&quot; type=&quot;button&quot;&gt;禁用控件&lt;/button&gt;&lt;button onclick=&quot;checkControls()&quot; type=&quot;button&quot;&gt;检查控件状态&lt;/button&gt;&lt;video id=&quot;video2&quot;&gt;  &lt;source src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video 标签。&lt;/video&gt;&lt;script&gt;myVid=document.getElementById(&quot;video2&quot;);function enableControls(){   myVid.controls=true;  myVid.load();} function disableControls(){   myVid.controls=false;  myVid.load();} function checkControls(){   alert(myVid.controls);} &lt;/script&gt; </code></pre><p><button onclick="enableControls()" type="button">启动控件</button><br><button onclick="disableControls()" type="button">禁用控件</button><br><button onclick="checkControls()" type="button">检查控件状态</button></p><video id="video2" width="100%"><source src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video 标签。</video><script>function enableControls(){myVidtwo.controls=!0,myVidtwo.load()}function disableControls(){myVidtwo.controls=!1,myVidtwo.load()}function checkControls(){alert(myVidtwo.controls)}myVidtwo=document.getElementById("video2")</script><h2 id="高级-音频和视频中的方法"><a href="#高级-音频和视频中的方法" class="headerlink" title="(高级) 音频和视频中的方法"></a>(高级) 音频和视频中的方法</h2><p>在 HTML5 网页中，操作音频或视频文件的常用方法包括 canPlayType()方法、load()方法、play()方法 和 pause()方法。</p><h3 id="canPlayType-方法"><a href="#canPlayType-方法" class="headerlink" title="canPlayType() 方法"></a>canPlayType() 方法</h3><p>canPlayType() 方法用于检测浏览器是否能播放指定的音频或视频类型。</p><p>canPlayType() 方法返回值包含如下：</p><ul><li>probably：浏览器全面支持指定的音频或视频类型。</li><li>maybe：浏览器可能支持指定的音频或视频类型。</li><li>“ “（空字符串）：浏览器不支持指定的音频或视频类型。</li></ul><p>注意，目前所有主流浏览器都支持 canPlayType() 方法。InternetExplorer 8 及之前的版本不支持该方法。</p><pre><code class="html">&lt;p&gt;浏览器可以播放 MP4视频吗?&lt;span&gt;    &lt;button onclick=&quot;supportType(event,&#39;video/mp4&#39;,&#39;avc1.42E01E, mp4a.40.2&#39;)&quot; type=&quot;button&quot;&gt;检查&lt;/button&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;浏览器可以播放 OGG 音频吗?&lt;span&gt;    &lt;button onclick=&quot;supportType(event,&#39;audio/ogg&#39;,&#39;theora, vorbis&#39;)&quot; type=&quot;button&quot;&gt;检查&lt;/button&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt;function supportType(e,vidType,codType){  myVid=document.createElement(&#39;video&#39;);  isSupp=myVid.canPlayType(vidType+&#39;;codecs=&quot;&#39;+codType+&#39;&quot;&#39;);  if (isSupp==&quot;&quot;)  {    isSupp=&quot;不支持&quot;;  }  e.target.parentNode.innerHTML=&quot;检查结果: &quot; + isSupp;}&lt;/script&gt;</code></pre><p>浏览器可以播放 MP4视频吗? <span><button onclick='supportType(event,"video/mp4","avc1.42E01E, mp4a.40.2")' type="button">检查</button></span></p><p>浏览器可以播放 OGG 音频吗? <span><button onclick='supportType(event,"audio/ogg","theora, vorbis")' type="button">检查</button></span></p><script>function supportType(e,p,i){myVid=document.createElement("video"),isSupp=myVid.canPlayType(p+';codecs="'+i+'"'),""==isSupp&&(isSupp="不支持"),e.target.parentNode.innerHTML="检查结果: "+isSupp}</script><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load() 方法"></a>load() 方法</h3><p>load() 方法用于重新加载音频或视频文件。load()方法的语法格式如下：</p><pre><code class="javascript">audio|video.load()</code></pre><p>下面是一个具体使用的例子,单击【更改加载视频】按钮，即可切换到下一个视频：</p><pre><code class="html">&lt;button onclick=&quot;changeSource()&quot; type=&quot;button&quot;&gt;更改加载视频&lt;/button&gt;&lt;video id=&quot;video3&quot; controls=&quot;controls&quot;&gt;  &lt;source id=&quot;mp4_src&quot; src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video  标签。&lt;/video&gt;&lt;script&gt; function changeSource(){   document.getElementById(&quot;mp4_src&quot;).src=&quot;https://media.everdo.cn/tank/xiaofan/video/2018/nbez304-h264-hd_raw.mp4&quot;;  document.getElementById(&quot;video3&quot;).load();} &lt;/script&gt;</code></pre><p><button onclick="changeSource()" type="button">更改加载视频</button></p><video id="video3" controls width="100%"><source id="mp4_src" src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video 标签。</video><script>function changeSource(){document.getElementById("mp4_src").src="https://media.everdo.cn/tank/xiaofan/video/2018/nbez304-h264-hd_raw.mp4",document.getElementById("video3").load()}</script><h3 id="play-和-pause-方法"><a href="#play-和-pause-方法" class="headerlink" title="play() 和 pause() 方法"></a>play() 和 pause() 方法</h3><p>play() 方法用于开始播放音频或视频文件。pause() 方法用于暂停当前播放的音频或视频文件。</p><p>下面是一个具体使用的例子,为了更好体现效果，这里禁用了浏览器自带的播放控件。在案例中单击【播放视频】按钮，则视频开始播放；单击【暂停视频】按钮，则视频暂停播放：</p><pre><code class="html">&lt;button onclick=&quot;playVid()&quot; type=&quot;button&quot;&gt;播放视频&lt;/button&gt;&lt;button onclick=&quot;pauseVid()&quot; type=&quot;button&quot;&gt;暂停视频&lt;/button&gt;&lt;video id=&quot;video4&quot;&gt;  &lt;source src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video  标签。&lt;/video&gt;&lt;script&gt;var myVideo=document.getElementById(&quot;video4&quot;); function playVid(){   myVideo.play(); } function pauseVid(){   myVideo.pause(); } &lt;/script&gt; </code></pre><p><button onclick="playVid()" type="button">播放视频</button><br><button onclick="pauseVid()" type="button">暂停视频</button></p><video id="video4" width="100%"><source src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video 标签。</video><script>function playVid(){myVideo.play()}function pauseVid(){myVideo.pause()}var myVideo=document.getElementById("video4")</script><h3 id="buffered-属性-JS"><a href="#buffered-属性-JS" class="headerlink" title="buffered 属性 (JS)"></a>buffered 属性 (JS)</h3><p>buffered 属性返回 TimeRanges 对象。TimeRanges 对象表示用户的音频或视频缓冲范围。缓冲范围指的是已缓冲音频或视频的时间范围。如果用户在音频或视频中跳跃播放，就会得到多个缓冲范围。</p><p>返回buffered属性的语法格式如下：</p><pre><code class="html">audio|video.buffered</code></pre><p>下面是一个具体使用的例子,单击【获得视频的第一段缓冲范围】按钮，即可看到此时视频的缓冲范围:</p><pre><code class="html">&lt;button onclick=&quot;getFirstBuffRange()&quot; type=&quot;button&quot;&gt;获得视频的第一段缓冲范围&lt;/button&gt;&lt;video id=&quot;video5&quot; controls=&quot;controls&quot;&gt;  &lt;source src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video  标签。&lt;/video&gt;&lt;script&gt;myVid=document.getElementById(&quot;video5&quot;);function getFirstBuffRange(){   alert(&quot;开始: &quot; + myVid.buffered.start(0) + &quot; 结束: &quot;  + myVid.buffered.end(0));} &lt;/script&gt;</code></pre><p><button onclick="getFirstBuffRange()" type="button">获得视频的第一段缓冲范围</button></p><video id="video5" controls width="100%"><source src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video 标签。</video><script>function getFirstBuffRange(){alert("开始: "+myVidtime.buffered.start(0)+" 结束: "+myVidtime.buffered.end(0))}myVidtime=document.getElementById("video5")</script><h3 id="currentSrc-属性-JS"><a href="#currentSrc-属性-JS" class="headerlink" title="currentSrc 属性 (JS)"></a>currentSrc 属性 (JS)</h3><p>currentSrc 属性返回当前音频或视频的 URL。如果未设置音频或视频，则返回空字符串。返回currentSrc 属性的语法格式如下：</p><pre><code class="html">audio|video.currentSrc</code></pre><p>下面是一个具体使用的例子,单击【获得当前视频的URL】按钮，即可看到当前视频的 URL 路径:</p><pre><code class="html">&lt;button onclick=&quot;getVid()&quot; type=&quot;button&quot;&gt;获得当前视频的URL：&lt;/button&gt;&lt;video id=&quot;video6&quot; controls=&quot;controls&quot;&gt;  &lt;source src=&quot;https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持 HTML5 video  标签。&lt;/video&gt;&lt;script&gt;myVid=document.getElementById(&quot;video6&quot;);function getVid(){  alert(myVid.currentSrc);}&lt;/script&gt;</code></pre><p><button onclick="getVid()" type="button">获得当前视频的URL：</button></p><video id="video6" controls width="100%"><source src="https://media.everdo.cn/tank/xiaofan/video/2019/vlog-19-07-zhoushan_h264.mp4" type="video/mp4">您的浏览器不支持 HTML5 video 标签。</video><script>function getVid(){alert(myVidurl.currentSrc)}myVidurl=document.getElementById("video6")</script><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 05-表单元素</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-05-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-05-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>在网页中，表单主要是用于负责采集浏览者的相关数据，如常见的注册表、调查表和留言表等。在HTML5中，表单拥有多个新的表单输入类型，这些新特性提供了更好的输入控制和验证。</p><h2 id="表单概述"><a href="#表单概述" class="headerlink" title="表单概述"></a>表单概述</h2><p>表单主要用于收集网页上浏览者的相关信息，其标记为</p><form></form>。表单的基本语法格式如下：<p></p><a id="more"></a><pre><code class="html">&lt;form action=&quot;url&quot; mothod=&quot;get|post&quot; enctype=&quot;mime&quot;&gt;&lt;/form&gt;</code></pre><p>其中，action 指定处理提交表单的格式，它可以是一个 URL 地址或一个电子邮件地址；method 指明提交表单的 HTTP 方法。enctype 指明用来把表单提交给服务器时的互联网媒体形式。表单是一个能够包含表单元素的区域，通过添加不同的表单元素，将显示不同的效果</p><p>下面是一个基本表单的实例：</p><pre><code class="html">&lt;form&gt;    用户名称    &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;br /&gt;    用户密码    &lt;input type=&quot;password&quot; name=&quot;user&quot; /&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;</code></pre><p></p><form>用户名称 <input type="text" name="user"><br>用户密码 <input type="password" name="user"><br><input type="submit" value="登录"></form><p></p><h3 id="required-必填项"><a href="#required-必填项" class="headerlink" title="required 必填项"></a>required 必填项</h3><p>required 属性规定必须在提交之前填写输入域（不能为空）。required 属性适用于以下类型的输入属性：text、search、url、email、password、date、pickers、number、checkbox、radio 等。</p><pre><code class="html">required=&quot;required&quot;</code></pre><h3 id="lt-input-gt-相关属性"><a href="#lt-input-gt-相关属性" class="headerlink" title="&lt;input&gt; 相关属性"></a><code>&lt;input&gt;</code> 相关属性</h3><p>由于 <code>&lt;input /&gt;</code> 在 HTML 表单操作中是一个非常基本的操作，这里先将该标签的属性做成列表来方便下面查找</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</td></tr><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>file</td><td>定义输入字段和 “浏览”按钮，供文件上传。</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮。</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</td></tr></tbody></table><h2 id="使用表单基本元素"><a href="#使用表单基本元素" class="headerlink" title="使用表单基本元素"></a>使用表单基本元素</h2><p>表单元素是能够让用户在表单中输入信息的元素，常见的有文本框、密码框、下拉菜单、单选按钮、复选框等。</p><h3 id="单行文本输入框-text"><a href="#单行文本输入框-text" class="headerlink" title="单行文本输入框 text"></a>单行文本输入框 <code>text</code></h3><p>文本框是一种让访问者自行输入内容的表单对象，通常被用来填写单个字或简短的回答，如用户姓名和地址。代码格式如下：</p><pre><code class="html">&lt;form&gt;    自定义文字：    &lt;input type=&quot;text&quot; name=&quot;user&quot; size=&quot;30&quot; maxlength=&quot;25&quot; value=&quot;i@my.huxiaofan.com&quot;/&gt;    &lt;!--textarea 标签内的内容可以直接用于编辑，和 placeholder 属性不同--&gt;&lt;/form&gt;</code></pre><form>自定义文字： <input type="text" name="user" size="30" maxlength="25" value="i@my.huxiaofan.com"></form><blockquote><p>其中，type=”text” 定义单行文本输入框；name 属性定义文本框的名称，要保证数据的准确采集，必须定义一个独一无二的名称；size 属性定义文本框的宽度，单位是单个字符宽度；maxlength 属性定义最多输入的字符数；value 属性定义文本框的初始值。</p></blockquote><h3 id="密码域-password"><a href="#密码域-password" class="headerlink" title="密码域 password"></a>密码域 password</h3><p>密码输入框是一种特殊的文本域，主要用于输入一些保密信息。当网页浏览者输入文本时，显示的是黑点或其他符号，这样就增加了输入文本的安全性。</p><pre><code class="html">&lt;form&gt;    请输入密码：    &lt;input type=&quot;password&quot; name=&quot;user&quot; size=&quot;30&quot; maxlength=&quot;25&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form>请输入密码： <input type="password" name="user" size="30" maxlength="25"></form><p></p><h3 id="多行文本框标记-lt-textarea-gt"><a href="#多行文本框标记-lt-textarea-gt" class="headerlink" title="多行文本框标记 &lt;textarea&gt;"></a>多行文本框标记 <code>&lt;textarea&gt;</code></h3><p>其中，name 属性定义多行文本框的名称，要保证数据的准确采集，必须定义一个独一无二的名称；cols 属性定义多行文本框的宽度，单位是单个字符宽度；rows 属性定义多行文本框的高度，单位是单个字符高度；wrap 属性定义输入内容大于文本域时显示的方式。</p><pre><code class="html">&lt;textarea name=&quot;cantent&quot; cols=&quot;50&quot; row=&quot;5&quot; warp=&quot;true&quot; placeholder=&quot;请输入...&quot;&gt;&lt;/textarea&gt;</code></pre><p><textarea name="cantent" cols="50" row="5" warp="true" placeholder="请输入..."></textarea></p><pre><code class="html">&lt;form action=&quot;/404.php&quot; id=&quot;usrform&quot;&gt;    用户名:     &lt;input type=&quot;text&quot; name=&quot;usrname&quot; value=&quot;Emptinessboy&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;textarea name=&quot;comment&quot; form=&quot;usrform&quot;&gt;本宝宝最帅！&lt;/textarea&gt;&lt;!--textarea 标签内的内容可以直接用于编辑，和 placeholder 属性不同--&gt;</code></pre><form action="/404.php" id="usrform">用户名: <input type="text" name="usrname" value="Emptinessboy"> <input type="submit"></form><p><textarea name="comment" form="usrform">本宝宝最帅！</textarea></p><p>一般情况下，textarea 是嵌套在 form 标签里的。当 textarea 在表单外时，基于 id 的绑定就为 HTML 布局提供了更多的可能和灵活性。这里演示代码的 textarea 绑定了 formid 为 usrform 的表单，因此点击表单的提交窗口会同时把 textarea 的值提交上去！</p><p><a href="https://up.media.everdo.cn/image/HVei" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html-textarea.jpg" alt="html-textarea.jpg"></a></p><p>下面整理了一些 textarea 常用的属性和方法：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>name_of_textarea</td><td>规定文本区的名称。</td></tr><tr><td>cols</td><td>number</td><td>规定文本区内的可见宽度。</td></tr><tr><td>rows</td><td>number</td><td>规定文本区内的可见行数。</td></tr><tr><td>autofocus</td><td>autofocus</td><td>规定在页面加载后文本区域自动获得焦点。</td></tr><tr><td>disabled</td><td>disabled</td><td>规定禁用该文本区的编辑功能。且显示灰色</td></tr><tr><td>form</td><td>form_id</td><td>规定文本区域所属的一个或多个表单。可以用于关联提交按钮。</td></tr><tr><td>maxlength</td><td>number</td><td>规定文本区域的最大字符数，超出后不能输入。</td></tr><tr><td>placeholder</td><td>text</td><td>规定描述文本区域预期值的简短提示。</td></tr><tr><td>readonly</td><td>readonly</td><td>规定文本区为只读。</td></tr><tr><td>required</td><td>required</td><td>规定文本区域是必填的。</td></tr><tr><td>wrap</td><td>hard / soft</td><td>当提交表单时，wrap=”hard” 的文本区域中的文本会包含换行符</td></tr></tbody></table><h3 id="单选按钮-radio"><a href="#单选按钮-radio" class="headerlink" title="单选按钮 radio"></a>单选按钮 radio</h3><p>单选按钮主要是让网页浏览者在一组选项里只能选其一。</p><pre><code class="html">&lt;form&gt;    请选择选项：    &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;A&quot; /&gt;选项A     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;B&quot; /&gt;选项B     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;C&quot; /&gt;选项C     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;D&quot; /&gt;选项D &lt;/form&gt;</code></pre><p></p><form>请选择选项： <input type="radio" name="answer" value="A">选项A <input type="radio" name="answer" value="B">选项B <input type="radio" name="answer" value="C">选项C <input type="radio" name="answer" value="D">选项D</form><p></p><h3 id="复选框-checkbox"><a href="#复选框-checkbox" class="headerlink" title="复选框 checkbox"></a>复选框 checkbox</h3><p>复选框主要是让网页浏览者在一组选项里可以同时选择多个选项。每个复选框都是一个独立的元素，必须有一个唯一的名称。</p><p>其中，type=”checkbox” 定义复选框；name 属性定义复选框的名称，<strong>在同一组中的复选框都必须用同一个名称</strong>；value 属性定义复选框的值。</p><pre><code class="html">&lt;form&gt;    多项选择：    &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;A&quot; checked /&gt;选项A     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;B&quot; /&gt;选项B     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;C&quot; /&gt;选项C     &lt;input type=&quot;radio&quot; name=&quot;answer&quot; value=&quot;D&quot; /&gt;选项D &lt;/form&gt;</code></pre><form>多项选择： <input type="checkbox" name="answer" value="A" checked>选项A <input type="checkbox" name="answer" value="B">选项B <input type="checkbox" name="answer" value="C">选项C <input type="checkbox" name="answer" value="D">选项D</form><blockquote><p>技巧提示：checked属性主要用来设置默认选中项,本案例中选项 A 默认被选中</p></blockquote><h3 id="选择列表标记-lt-select-gt"><a href="#选择列表标记-lt-select-gt" class="headerlink" title="选择列表标记 &lt;select&gt;"></a>选择列表标记 <code>&lt;select&gt;</code></h3><p>下拉列表主要用于在有限的空间里设置多个选项，它既可以用作单选，也可以用作多选。</p><p>其中，name 属性定义选择列表的名称；size 属性定义选择列表的行数；multiple 属性表示可以多选，如果不设置该属性，则只能单选；value 属性定义选择项的值；selected 属性表示默认已经选择本选项。</p><p>单项选择列表</p><pre><code class="html">&lt;form&gt;&lt;select name=&quot;answer&quot;&gt;    &lt;option value=&quot;A&quot; selected&gt;选项A&lt;/option&gt;    &lt;option value=&quot;B&quot;&gt;选项B&lt;/option&gt;    &lt;option value=&quot;D&quot;&gt;选项C&lt;/option&gt;    &lt;option value=&quot;D&quot;&gt;选项D&lt;/option&gt;&lt;/select&gt;&lt;form&gt;</code></pre><form><select name="answer"><option value="A" selected>选项A</option><option value="B">选项B</option><option value="D">选项C</option><option value="D">选项D</option></select><form><p>多项选择列表</p><pre><code class="html">&lt;form&gt;&lt;select name=&quot;answer&quot; size=&quot;2&quot; multiple&gt;    &lt;option value=&quot;A&quot; selected&gt;选项A&lt;/option&gt;    &lt;option value=&quot;B&quot;&gt;选项B&lt;/option&gt;    &lt;option value=&quot;D&quot;&gt;选项C&lt;/option&gt;    &lt;option value=&quot;D&quot;&gt;选项D&lt;/option&gt;&lt;/select&gt;&lt;form&gt;</code></pre><form><select name="answer" size="2" multiple><option value="A" selected>选项A</option><option value="B">选项B</option><option value="D">选项C</option><option value="D">选项D</option></select><form><p>列表内显示了4个选项，用户可以按住 Ctrl 键选择多个选项。</p><h3 id="普通按钮-button"><a href="#普通按钮-button" class="headerlink" title="普通按钮 button"></a>普通按钮 button</h3><p><code>&lt;input type=&quot;button&quot; /&gt;</code> 定义可点击的按钮，但没有任何行为。button 类型常用于在用户点击按钮时启动 JavaScript 程序。代码格式如下：</p><pre><code class="html">&lt;form&gt;    &lt;input type=&quot;button&quot; name=&quot;try&quot; value=&quot;尝试&quot; onclick=&quot;&quot; /&gt;&lt;/form&gt;</code></pre><form><input type="button" name="try" value="尝试"></form><p>下面是一个进阶示例，使用 javascript 将文本框1的内容复制到文本框2中：(由于是文本中嵌入 js 代码，可能会被浏览器或 IDE 安全策略拦截)</p><pre><code class="html">&lt;form&gt;    &lt;p&gt;        &lt;input type=&quot;text&quot; id=&quot;field_1&quot; value=&quot;吼吼吼吼&quot;&gt;        &lt;br&gt;        &lt;input type=&quot;text&quot; id=&quot;filed_2&quot; value=&quot;嘎嘎嘎嘎&quot;&gt;        &lt;br&gt;    &lt;/p&gt;    &lt;input type=&quot;button&quot; name=&quot;copy&quot; value=&quot;点我试试&quot; onclick=&quot;document.getElementById(&#39;filed_2&#39;).value=document.getElementById(&#39;field_1&#39;).value&quot; &gt;&lt;/form&gt;</code></pre><p></p><form><p><input type="text" id="field_1" value="吼吼吼吼"><br><input type="text" id="filed_2" value="嘎嘎嘎嘎"><br></p><input type="button" name="copy" value="点我试试" onclick='document.getElementById("filed_2").value=document.getElementById("field_1").value'></form><p></p><h3 id="提交按钮-submit"><a href="#提交按钮-submit" class="headerlink" title="提交按钮 submit"></a>提交按钮 submit</h3><p><code>&lt;input type=&quot;submit&quot; /&gt;</code> 定义提交按钮。提交按钮用于向服务器发送表单数据。数据会发送到表单的 action 属性中指定的页面。</p><pre><code class="html">GET 方式发送请求，若需要 POST 则修改 form.method&lt;form action=&quot;/404.php&quot; method=&quot;get&quot;&gt;  &lt;p&gt;邮箱: &lt;input type=&quot;text&quot; name=&quot;email&quot; placeholder=&quot;请输入邮箱地址...&quot;/&gt;&lt;/p&gt;  &lt;p&gt;昵称: &lt;input type=&quot;text&quot; name=&quot;nickname&quot; maxlength=&quot;18&quot; placeholder=&quot;想一个昵称吧&quot;/&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</code></pre><form action="/404.php" method="get"><p>邮箱: <input type="text" name="email" placeholder="请输入邮箱地址..."></p><p>昵称: <input type="text" name="nickname" maxlength="18" placeholder="想一个昵称吧"></p><input type="submit" value="提交"></form><p>单击确认按钮，输入会发送到服务器上名为 “404.php” 的页面。:-D 当然本服务器上这个 php 是不存在的</p><p>这里，我们研究下 GET 方式和 POST 方式在浏览器执行过程中的区别。</p><p><a href="https://up.media.everdo.cn/image/HYM4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html-submitget.jpg" alt="html-submitget.jpg"></a></p><blockquote><p>可以很明显看到，上图中 GET 方式为从服务器拉取数据，但是通过改变 URL 使得通过 URL 进行参数传递。而下图 POST 方式，则是与之不同。</p></blockquote><p><a href="https://up.media.everdo.cn/image/HbaM" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html-submitpost.jpg" alt="html-submitpost.jpg"></a></p><h3 id="重置按钮-reset"><a href="#重置按钮-reset" class="headerlink" title="重置按钮 reset"></a>重置按钮 reset</h3><p><code>&lt;input type=&quot;reset&quot; /&gt;</code> 定义重置按钮。重置按钮会清除表单中的所有数据。代码格式如下：</p><pre><code class="html">&lt;form&gt;  &lt;p&gt;随便瞎写: &lt;input type=&quot;text&quot; name=&quot;text&quot; value=&quot;&quot;/&gt;&lt;/p&gt;  &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;一键清除&quot;/&gt;&lt;/form&gt;</code></pre><form><p>随便瞎写: <input type="text" name="text"></p><input type="reset" name="" value="一键清除"></form><h2 id="表单高级元素的使用"><a href="#表单高级元素的使用" class="headerlink" title="表单高级元素的使用"></a>表单高级元素的使用</h2><p>除了上述基本属性外，HTML5中还有一些高级属性，包括url、eamil、time、range、search等。对于部分高级属性。其中有些效果IE 浏览器暂时还不支持</p><h3 id="url-属性"><a href="#url-属性" class="headerlink" title="url 属性"></a>url 属性</h3><p>url属性用于说明网站网址，显示为在一个文本框中输入URL地址，在提交表单时会自动验证url的值。</p><p>用户可以使用 max 属性设置其最大值、min 属性设置其最小值、step 属性设置合法的数字间隔、value 属性规定其默认值。</p><p>可以在文本框中输入相应的网址。如果输入的 url 格式不准确，按Enter键后就会弹出报错信息。</p><pre><code class="html">&lt;form&gt;  &lt;p&gt;请输入网址: &lt;input type=&quot;url&quot; name=&quot;wangzhi&quot; value=&quot;&quot;/&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;GO&quot;/&gt;&lt;/form&gt;</code></pre><p></p><form><p>请输入网址: <input type="url" name="wangzhi"></p><input type="submit" name="" value="GO"></form><p></p><blockquote><p>增强用户体验：iPhone 的 Safari 浏览器会识别 url 输入类型，然后改变触摸屏的键盘来适应它（添加 .com 选项）。</p></blockquote><h3 id="Email-属性"><a href="#Email-属性" class="headerlink" title="Email 属性"></a>Email 属性</h3><p>与url属性类似，email 属性用于让浏览者输入 E-mail 地址，在提交表单时会自动验证 email 域的值</p><pre><code class="html">&lt;form&gt;  &lt;p&gt;请输入邮箱: &lt;input type=&quot;email&quot; name=&quot;email&quot; value=&quot;&quot;/&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;GO&quot;/&gt;&lt;/form&gt;</code></pre><p></p><form><p>请输入邮箱: <input type="email" name="email"></p><input type="submit" name="" value="GO"></form><p></p><h3 id="Tel-和-Search-属性"><a href="#Tel-和-Search-属性" class="headerlink" title="Tel 和 Search 属性"></a>Tel 和 Search 属性</h3><p>tel 输入类型用于应该包含电话号码的输入字段。但现阶段浏览器并不支持对 Tel 属性进行校验，使用这个属性视同于使用普通文本提交属性。</p><p>search 输入类型用于搜索字段，比如站内搜索或谷歌搜索等。搜索字段的外观与常规的文本字段无异。</p><blockquote><p>也就是说这两个属性实际使用简单根据需要应用就行，可能在某些客户端可以触发增强的交互，反正也没太大用 （dog</p></blockquote><h3 id="number-属性"><a href="#number-属性" class="headerlink" title="number 属性"></a>number 属性</h3><p>number 输入类型用于包含数字值的输入字段。可以对 number 设置可接受数字的限制。</p><ul><li>max 规定允许的最大值。</li><li>min 规定允许的最小值。</li><li>step 规定合法数字间隔（如果 step=”3”，则合法的数字是 -3,0,3,6, 以此类推）</li><li>value 规定默认值。</li></ul><pre><code class="html">&lt;form&gt;    &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; value=&quot;5&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form><input type="number" name="points" min="1" max="10" value="5"></form><p></p><h3 id="Range-属性"><a href="#Range-属性" class="headerlink" title="Range 属性"></a>Range 属性</h3><p>range属性可以显示一个滚动的控件，用户可以使用max、min和step属性设置控件的范围。代码格式如下：（其中高级属性和上面的 number 相同）</p><pre><code class="html">&lt;form&gt;    拖动滑块:     &lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form>拖动滑块: <input type="range" name="points" min="1" max="10"></form><p></p><blockquote><p>默认情况下，滑块位于滚珠的中间位置。如果用户指定的最大值小于最小值，则允许使用反向滚动轴，目前浏览器对这一属性还不能很好地支持。</p></blockquote><h3 id="Date-和-Times"><a href="#Date-和-Times" class="headerlink" title="Date 和 Times"></a>Date 和 Times</h3><p>HTML5 拥有多个供选择日期和时间的新的输入类型：(IE 不支持)</p><ul><li>date - 选择日、月、年</li><li>month - 选择月、年</li><li>week - 选择周、年</li><li>time - 选择时间（时、分）</li><li>datetime - 选择时间、日期、月、年（UTC 时间）貌似 Chrome 不行</li><li>datetime-local - 选择时间、日期、月、年（本地时间）</li></ul><p>下面的例子允许您从日历选取一个日期：</p><pre><code class="html">&lt;form&gt;    &lt;input type=&quot;date&quot; name=&quot;user_date&quot; /&gt;    &lt;input type=&quot;month&quot; name=&quot;user_date&quot; /&gt;    &lt;input type=&quot;week&quot; name=&quot;user_date&quot; /&gt;    &lt;input type=&quot;time&quot; name=&quot;user_date&quot; /&gt;    &lt;input type=&quot;datetime&quot; name=&quot;user_date&quot; /&gt;    &lt;input type=&quot;datetime-local&quot; name=&quot;user_date&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form><input type="date" name="user_date">&ensp; <input type="month" name="user_date">&ensp; <input type="week" name="user_date">&ensp; <input type="time" name="user_date">&ensp; <input type="datetime" name="user_date">&ensp; <input type="datetime-local" name="user_date"></form><p></p><h3 id="color-属性"><a href="#color-属性" class="headerlink" title="color 属性"></a>color 属性</h3><p>color 输入类型用于规定颜色。该输入类型允许你从拾色器中选取颜色：</p><pre><code class="html">&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;    选择颜色:     &lt;input type=&quot;color&quot; name=&quot;user_color&quot; /&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form action="/example/html5/demo_form.asp" method="get">选择颜色: <input type="color" name="user_color"><br><input type="submit"></form><p></p><h3 id="file-属性"><a href="#file-属性" class="headerlink" title="file 属性"></a>file 属性</h3><p>file 输入类型用于文件上传。</p><pre><code class="html">&lt;form action=&quot;404.php&quot; method=&quot;get&quot;&gt;    请选择图片：    &lt;input type=&quot;file&quot; name=&quot;img&quot; /&gt;    &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p></p><form action="404.php" method="get">请选择图片： <input type="file" name="img"> <input type="submit"></form><p></p><h3 id="图形化按钮-image"><a href="#图形化按钮-image" class="headerlink" title="图形化按钮 image"></a>图形化按钮 image</h3><p>image 输入类型将提交按钮显示为一个自定义图像。</p><p>对于 <code>&lt;input type=&quot;image&quot;&gt;</code>，src 和 alt 属性是必需的。</p><pre><code class="html">&lt;form&gt;    姓名:     &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;输入名字&quot; /&gt;&lt;br /&gt;    &lt;input type=&quot;image&quot; src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/15/eg_submit.th.jpg&quot; alt=&quot;Submit&quot; width=&quot;28&quot; height=&quot;28&quot;/&gt;&lt;/form&gt;</code></pre><p></p><form>姓名: <input type="text" name="name" placeholder="输入名字"><br><input type="image" src="https://media.everdo.cn/tank/pic-bed/2020/03/15/eg_submit.th.jpg" alt="Submit" width="28" height="28"></form><p></p><h2 id="Tips：关于表单默认值"><a href="#Tips：关于表单默认值" class="headerlink" title="Tips：关于表单默认值"></a>Tips：关于表单默认值</h2><p>hidden 输入类型定义隐藏字段。隐藏字段对于用户是不可见的。隐藏字段常常存储默认值，或者由 JavaScript 改变它们的值。</p><pre><code class="html">&lt;form action=&quot;/404.php&quot; method=&quot;get&quot;&gt;  &lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;&lt;br /&gt;  &lt;input type=&quot;hidden&quot; name=&quot;shuaige&quot; value=&quot;Emptinessboy&quot; /&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</code></pre><form action="/404.php" method="get"><input type="text" name="text"><br><input type="hidden" name="shuaige" value="Emptinessboy"> <input type="submit" value="提交"></form><p>在这个案例中，一旦点击提交按钮，就会把 shuaige 值 Emptinessboy 给上传到服务器！就像下图那样：</p><p><a href="https://up.media.everdo.cn/image/HeAY" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/15/html-texthidden.jpg" alt="html-texthidden.jpg"></a></p><p>写文档好累啊！</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"></form></form></form></form><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 04-创建表格</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-04-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-04-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="表格基本结构"><a href="#表格基本结构" class="headerlink" title="表格基本结构"></a>表格基本结构</h2><p>使用表格显示数据，可以更直观和清晰。在HTML文档中表格主要用于显示数据，虽然可以使用表格布局，但是不建议使用，它有很多弊端。</p><p><code>&lt;table&gt;</code> 标记用于标识一个表格对象的开始，<code>&lt;/table&gt;</code> 标记用于标识一个表格对象的结束。<a id="more"></a><strong>一个表格中，只允许出现一对 <code>&lt;table&gt;</code> 标记</strong>。</p><p><code>&lt;tr&gt;</code> 标记用于标识表格一行的开始，<code>&lt;/tr&gt;</code> 标记用于标识表格一行的结束。表格内有多少对 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标记，就表示表格中有多少行。<code>&lt;td&gt;</code> 标记用于标识表格某行中的一个单元格开始，<code>&lt;/td&gt;</code> 标记用于标识表格某行中的一个单元格结束。</p><p><code>&lt;td&gt;&lt;/td&gt;</code> 标记书写在 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标记内，一对 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标记内有多少对 <code>&lt;td&gt;&lt;/td&gt;</code> 标记，就表示该行有多少个单元格。在HTML5中仅有 colspan 和 rowspan 两个属性。</p><p>最基本的表格必须包含一对 <code>&lt;table&gt;&lt;/table&gt;</code> 标记、一对或几对 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标记及一对或几对 <code>&lt;td&gt;&lt;/td&gt;</code> 标记。一对 <code>&lt;table&gt;&lt;/table&gt;</code> 标记定义一个表格，一对 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标记定义一行，一对 <code>&lt;td&gt;&lt;/td&gt;</code> 标记定义一个单元格。</p><blockquote><p>简而言之，<code>&lt;tr&gt;</code> 表示有多少行，<code>&lt;td&gt;</code> 表示有多少列</p></blockquote><pre><code class="html">这是一个三行四列的表格：&lt;table &gt;   &lt;tr&gt;       &lt;td&gt;A1&lt;/td&gt;       &lt;td&gt;B1&lt;/td&gt;       &lt;td&gt;C1&lt;/td&gt;       &lt;td&gt;D1&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A2&lt;/td&gt;       &lt;td&gt;B2&lt;/td&gt;       &lt;td&gt;C2&lt;/td&gt;       &lt;td&gt;D2&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A3&lt;/td&gt;       &lt;td&gt;B3&lt;/td&gt;       &lt;td&gt;C3&lt;/td&gt;       &lt;td&gt;D3&lt;/td&gt;   &lt;/tr&gt;&lt;!--表格基本结构--&gt;&lt;/table&gt;</code></pre><table><tr><td>A1</td><td>B1</td><td>C1</td><td>D1</td></tr><tr><td>A2</td><td>B2</td><td>C2</td><td>D2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td></tr></table><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><h3 id="合并两个单元格"><a href="#合并两个单元格" class="headerlink" title="合并两个单元格"></a>合并两个单元格</h3><p>在 HTML 中合并的方向有两种：一种是上下合并；另一种是左右合并，这两种合并方式只需要使用 colspan 和 rowspan 属性即可。</p><p>单元格的合并格式如下：</p><pre><code class="html">左右单元格&lt;td colspan=&quot;数值&quot;&gt; 单元格内容 &lt;/td&gt;上下单元格&lt;td rowspan=&quot;数值&quot;&gt; 单元格内容 &lt;/td&gt;</code></pre><pre><code class="html">这是一个三行四列的表格（合并单元格）：&lt;table &gt;   &lt;tr&gt;    &lt;!--A1,B1上下合并--&gt;       &lt;td colspan=&quot;2&quot;&gt;A1 B1&lt;/td&gt;       &lt;td&gt;C1&lt;/td&gt;       &lt;td&gt;D1&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A2&lt;/td&gt;       &lt;td&gt;B2&lt;/td&gt;       &lt;td rowspan=&quot;2&quot;&gt;C2 C3&lt;/td&gt;&lt;!--C1,C2上下合并--&gt;       &lt;td&gt;D2&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A3&lt;/td&gt;       &lt;td&gt;B3&lt;/td&gt;       &lt;td&gt;D3&lt;/td&gt;   &lt;/tr&gt;&lt;/table&gt;</code></pre><table><tr><td colspan="2">A1 B1</td><td>C1</td><td>D1</td></tr><tr><td>A2</td><td>B2</td><td rowspan="2">C2 C3</td><td>D2</td></tr><tr><td>A3</td><td>B3</td><td>D3</td></tr></table><p>需要注意的是在合并单元格后，相应的单元格标记就应该删除，否则就会多出来一个，以及后面的单元格依次向右移动的错乱现象。</p><h3 id="合并多个单元格"><a href="#合并多个单元格" class="headerlink" title="合并多个单元格"></a>合并多个单元格</h3><pre><code class="html">这是一个三行四列的表格：&lt;table &gt;   &lt;tr&gt;       &lt;td&gt;A1&lt;/td&gt;       &lt;td&gt;B1&lt;/td&gt;       &lt;td&gt;C1&lt;/td&gt;       &lt;td&gt;D1&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A2&lt;/td&gt;       &lt;td&gt;B2&lt;/td&gt;       &lt;td&gt;C2&lt;/td&gt;       &lt;td&gt;D2&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;       &lt;td&gt;A3&lt;/td&gt;       &lt;td&gt;B3&lt;/td&gt;       &lt;td&gt;C3&lt;/td&gt;       &lt;td&gt;D3&lt;/td&gt;   &lt;/tr&gt;&lt;!--表格基本结构--&gt;&lt;/table&gt;</code></pre><table><tr><td colspan="2" rowspan="2">A1 B1<br>A2 B2</td><td>C1</td><td>D1</td></tr><tr><td>C2</td><td>D2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td><td>D3</td></tr></table><h2 id="DreamWeaver操作表格"><a href="#DreamWeaver操作表格" class="headerlink" title="DreamWeaver操作表格"></a>DreamWeaver操作表格</h2><h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><p>在 Dreamweaver CC 2020 中创建表格，只需要执行【插入】菜单中的【Table】命令，在弹出的对话框中指定表格的行数、列数、宽度和边框，即可在光标处创建一个空白表格。</p><p><a href="https://up.media.everdo.cn/image/Hna2" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table.jpg" alt="html_dw_table.jpg"></a></p><p>在弹出的对话框中指定表格的行数、列数、宽度和边框，即可在光标处创建一个空白表格</p><p><a href="https://up.media.everdo.cn/image/HB3Z" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table1.md.jpg" alt="html_dw_table1.md.jpg"></a></p><p>选择表格之后，【属性】面板提供了表格的常用操作</p><p><a href="https://up.media.everdo.cn/image/HREk" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table2.jpg" alt="html_dw_table2.jpg"></a></p><h3 id="拆分合并表格"><a href="#拆分合并表格" class="headerlink" title="拆分合并表格"></a>拆分合并表格</h3><p>在Dreamweaver CC可视化操作中，提供了合并与拆分单元格两种操作。</p><p>进行单元格合并和拆分时，请将光标置于单元格内，如果选择了一个单元格，则拆分命令有效；如果选择了两个或两个以上单元格，则合并命令有效。</p><p>以合并命令为例，在设计视图选中两个单元格：</p><p><a href="https://up.media.everdo.cn/image/H2Bt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table3.jpg" alt="html_dw_table3.jpg"></a></p><p>进入属性面板，点击合并按钮</p><p><a href="https://up.media.everdo.cn/image/H3SI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table6.jpg" alt="html_dw_table6.jpg"></a></p><p>看到合并效果如下</p><p><a href="https://up.media.everdo.cn/image/HjZB" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_dw_table5.jpg" alt="html_dw_table5.jpg"></a></p><h2 id="完整表格标记"><a href="#完整表格标记" class="headerlink" title="完整表格标记"></a>完整表格标记</h2><p>为了让表格结构更清楚，以及配合后面的CSS样式，更方便地制造出各种各样的表格，表格中还会出现表头、主体、脚注等。三者对应的 HTML 标记为 <code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>。<br>另外表格还有两个标记。标记 <code>&lt;caption&gt;</code> 表示表格的标题，在一行中除了 <code>&lt;td&gt;</code> 标记表示一个单元格以外，还可以使用 <code>&lt;th&gt;</code> 定义表格内的表头单元格。</p><p>使用 <code>&lt;caption&gt;</code> 标记定义了表格标题，<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code> 和 <code>&lt;tfoot&gt;</code> 标记对表格进行了分组。在 <code>&lt;thead&gt;</code> 部分使用 <code>&lt;th&gt;</code> 标记代替 <code>&lt;td&gt;</code> 标记定义单元格，<code>&lt;th&gt;</code> 标记定义的单元格默认加粗。<code>&lt;caption&gt;</code> 标记必须紧随 <code>&lt;table&gt;</code> 标记之后。</p><pre><code class="html">&lt;style&gt;    tfoot{background-color: #FF3;}  /*脚注颜色*/&lt;/style&gt;&lt;table width=&quot;200&quot; border=&quot;1&quot;&gt; &lt;!--边框粗细--&gt;    &lt;tr&gt;      &lt;td colspan=&quot;2&quot;&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;      &lt;td rowspan=&quot;2&quot;&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;      &lt;td&gt;&amp;nbsp;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;table &gt;   &lt;caption&gt;学生成绩单&lt;/caption&gt; &lt;!--表格标题--&gt;    &lt;thead&gt; &lt;!--表头--&gt;     &lt;tr&gt;         &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;     &lt;/tr&gt;    &lt;/thead&gt;    &lt;tfoot&gt; &lt;!--脚注--&gt;        &lt;tr&gt;            &lt;td&gt;平均分&lt;/td&gt;&lt;td colspan=&quot;2&quot;&gt;540&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;    &lt;tbody&gt; &lt;!--主体--&gt;     &lt;tr&gt;      &lt;td&gt;张三&lt;/td&gt;      &lt;td&gt;男&lt;/td&gt;      &lt;td&gt;560&lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tr&gt;      &lt;td&gt;李四&lt;/td&gt;      &lt;td&gt;男&lt;/td&gt;      &lt;td&gt;520&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p>运行结果如下：</p><p><a href="https://up.media.everdo.cn/image/HDJX" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/14/html_table.jpg" alt="html_table.jpg"></a></p><h2 id="一些简单-CSS"><a href="#一些简单-CSS" class="headerlink" title="一些简单 CSS"></a>一些简单 CSS</h2><pre><code class="html">&lt;style&gt;table{    /*表格添加宽度为3的#505050色边框*/    border:3px solid #505050;}caption{    /*表格标题字号36号*/    font-size:36px;}th,td{    /*表格单元格增加描边*/    border:1px solid #505050;}&lt;/style&gt;</code></pre><blockquote><p>使用 <code>&lt;thead&gt;、&lt;tbody&gt;和&lt;tfoot&gt;</code> 标记对行进行分组的意义何在？</p><p>在HTML文档中增加 <code>&lt;thead&gt;、&lt;tbody&gt; 和 &lt;tfoot&gt;</code> 标记虽然从外观上不能看出任何变化，但是它们却使文档的结构更加清晰。使用 <code>&lt;thead&gt;、&lt;tbody&gt; 和 &lt;tfoot&gt;</code> 标记除了使文档更加清晰之外，还有一个更重要的意义，那就是方便使用CSS样式对表格的各个部分进行修饰，从而制作出更炫的表格</p></blockquote><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 03-超链接和iFrame</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-03-%E8%B6%85%E9%93%BE%E6%8E%A5%E5%92%8CiFrame/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-03-%E8%B6%85%E9%93%BE%E6%8E%A5%E5%92%8CiFrame/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="URL概念"><a href="#URL概念" class="headerlink" title="URL概念"></a>URL概念</h2><p>例如：<a href="https://coding.emptinessboy.com/feed.xml">https://coding.emptinessboy.com/feed.xml</a></p><p>（协议https）:// (主机名/域名) / (路径)</p><h3 id="相对-URL-和-绝对-URL"><a href="#相对-URL-和-绝对-URL" class="headerlink" title="相对 URL 和 绝对 URL"></a>相对 URL 和 绝对 URL</h3><p>（1）绝对URL一般用于访问非同一台服务器上的资源。</p><a id="more"></a><p>（2）相对URL是指访问同一台服务器上相同文件夹或不同文件夹中的资源。如果访问相同文件夹中的文件，只需要写文件名；如果访问不同文件夹中资源，URL以服务器的根目录为起点，指明文件的相对关系，由文件夹名和文件名两部分构成。</p><pre><code class="html">URL绝对路径： &lt;a href=&quot;https://coding.emptinessboy.com/feed.xml&quot;&gt;robots.txt&lt;/a&gt;URL相对路径： &lt;a href=&quot;/feed.xml&quot;&gt;robots.txt&lt;/a&gt;URL相对路径： &lt;a href=&quot;../../../feed.xml&quot;&gt;robots.txt&lt;/a&gt;</code></pre><p>URL绝对路径： <a href="https://coding.emptinessboy.com/feed.xml">robots.txt</a><br>URL相对路径： <a href="/feed.xml">robots.txt</a><br>URL相对路径： <a href="../../../feed.xml">robots.txt</a></p><h2 id="超链接标记"><a href="#超链接标记" class="headerlink" title="超链接标记"></a>超链接标记</h2><p>建立超链接所使用的HTML标记为 <code>&lt;a&gt;&lt;/a&gt;</code>。超链接最重要的两个要素是超链接指向的目标地址和设置为超链接的网页元素。基本的超链接结构如下：</p><pre><code class="html">&lt;a href=&quot;URL&quot;&gt;网页元素&lt;/a&gt;</code></pre><h2 id="文本和图片的超链接"><a href="#文本和图片的超链接" class="headerlink" title="文本和图片的超链接"></a>文本和图片的超链接</h2><p>文本超链接和图片超链接通过 <code>&lt;a&gt;&lt;/a&gt;</code> 标记实现，将文本或图片放在 <code>&lt;a&gt;</code> 开始标记和 <code>&lt;/a&gt;</code> 结束标记之间即可建立超链接。</p><pre><code class="html">&lt;a href=&quot;https://coding.emptinessboy.com/&quot;&gt;Emptinessboy&lt;/a&gt;&lt;a href=&quot;https://coding.emptinessboy.com/&quot;&gt;&lt;img src=&quot;https://coding.emptinessboy.com/img/logo.png&quot; /&gt;&lt;/a&gt;</code></pre><p><a href="https://coding.emptinessboy.com/">Emptinessboy</a><br><br><a href="https://coding.emptinessboy.com/"><img src="https://coding.emptinessboy.com/img/logo.png" width="80px;"></a></p><h2 id="超链接对象类型"><a href="#超链接对象类型" class="headerlink" title="超链接对象类型"></a>超链接对象类型</h2><p>超链接不但可以链接到各种类型（如图片文件、声音文件、视频文件、word等）的文件，还可以链接到其他网站、ftp服务器、电子邮件等。</p><p>如果超链接对象是浏览器能够识别的类型，就会直接在浏览器中显示；如果是浏览器不能识别的类型，则会触发下载对话框。</p><h3 id="对象之电子邮件"><a href="#对象之电子邮件" class="headerlink" title="对象之电子邮件"></a>对象之电子邮件</h3><p>电子邮件链接可以实现，当访问者单击某个链接以后，会自动打开电子邮件客户端软件（如Outlook或Foxmail等）</p><pre><code class="html">&lt;a href=&quot;mailto:i@my.huxiaofan.com&quot;&gt;发邮件给 i@my.huxiaofan.com&lt;/a&gt;</code></pre><p><a href="mailto:i@my.huxiaofan.com">发邮件给 i@my.huxiaofan.com</a></p><h3 id="对象之电话号码"><a href="#对象之电话号码" class="headerlink" title="对象之电话号码"></a>对象之电话号码</h3><p>电话号码链接可以实现，当访问者单击某个链接以后，会自动打开手机里的拨号器。</p><pre><code class="html">&lt;a href=&quot;tel:123456789&quot;&gt;我怎么可能把电话告诉你呢/dog&lt;/a&gt;</code></pre><p><a href="tel:123456789">我怎么可能把电话告诉你呢/dog</a></p><p>点击后大概就是下面这样的效果啦！！</p><p><a href="https://up.media.everdo.cn/image/5d6" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html_tel.jpg" alt="html_tel.jpg"></a></p><p>（^_^ 一加五还能战！！！</p><h2 id="新窗口打开超链接"><a href="#新窗口打开超链接" class="headerlink" title="新窗口打开超链接"></a>新窗口打开超链接</h2><p>默认情况下，当单击超链接时，目标页面会在当前窗口中显示并替换掉当前页面的内容。</p><p>如果要实现在单击某个超链接后在新的浏览器窗口中显示目标页面，就需要使用 <code>&lt;a&gt;</code> 标记的 target 属性。target 属性取值有4个：<code>_blank、_self、_top、_parent</code>。由于HTML5不再支持框，所以 <code>_top、_parent</code>这两个取值不常用。</p><p>其中，<code>_blank</code> 表示在新窗口中显示超链接页面；<code>_self</code> 表示在当前窗口中显示超链接页面。当省略 <code>target</code> 属性时，默认取值为 <code>_self</code>。</p><pre><code class="html">&lt;a href=&quot;https://coding.emptinessboy.com/&quot;&gt;默认_self属性&lt;/a&gt;&lt;a href=&quot;https://coding.emptinessboy.com/&quot; target=&quot;_self&quot;&gt;指定_self属性&lt;/a&gt;&lt;a href=&quot;https://coding.emptinessboy.com/&quot; target=&quot;_blank&quot;&gt;使用_blank属性&lt;/a&gt;</code></pre><p><a href="https://coding.emptinessboy.com/">默认_self属性</a><br><a href="https://coding.emptinessboy.com/" target="_self">指定_self属性</a><br><a href="https://coding.emptinessboy.com/" target="_blank">使用_blank属性</a></p><h2 id="热点区域（进阶）"><a href="#热点区域（进阶）" class="headerlink" title="热点区域（进阶）"></a>热点区域（进阶）</h2><p>热点区域或称超链接的触发区域。</p><p>当单击一张图片的不同区域时会显示不同的链接内容，这就是图片的热点区域。所谓图片的热点区域就是将一个图片划分成若干个链接区域。访问者单击不同的区域会链接到不同的目标页面。</p><p>在HTML中，可以为图片创建3种类型的热点区域：矩形、圆形和多边形。创建热点区域使用标记 <code>&lt;map&gt; &lt;/map&gt;</code> 和 <code>&lt;area&gt;</code>，语法格式如下：</p><h3 id="案例（例子来自-w3school-com-cn）"><a href="#案例（例子来自-w3school-com-cn）" class="headerlink" title="案例（例子来自 w3school.com.cn）"></a>案例（例子来自 w3school.com.cn）</h3><pre><code class="html">&lt;img src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/13/eg_planets.jpg&quot; width=&quot;215px&quot; height=&quot;260px&quot; usemap=&quot;#pic&quot; /&gt;&lt;map name=&quot;pic&quot; id=&quot;#pic&quot;&gt;    &lt;area shape=&quot;rect&quot; coords=&quot;0,0,110,260&quot; href=&quot;https://up.media.everdo.cn/image/83Q&quot; target=&quot;_blank&quot; /&gt;     图片左半边太阳部分热区域（0，0），（110，260）    &lt;area shape=&quot;circle&quot; coords=&quot;129,161,10&quot; href=&quot;https://up.media.everdo.cn/image/aEJ&quot; target=&quot;_blank&quot; /&gt;     水星的热区域（120，161），r=10    &lt;area shape=&quot;poly&quot; coords=&quot;165,150,190,150,180,120&quot; href=&quot;https://up.media.everdo.cn/image/gUy&quot; target=&quot;_blank&quot; /&gt;     金星热区域使用三角形演示 （160，150），（190，150），（180，120）&lt;/map&gt;</code></pre><p><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/eg_planets.jpg" width="215px" height="260px" usemap="#pic"><map name="pic" id="#pic"><area shape="rect" coords="0,0,110,260" href="https://up.media.everdo.cn/image/83Q" target="_blank"><area shape="circle" coords="129,161,10" href="https://up.media.everdo.cn/image/aEJ" target="_blank"><area shape="poly" coords="165,150,190,150,180,120" href="https://up.media.everdo.cn/image/gUy" target="_blank"></map></p><h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><blockquote><p>img 元素中的 “usemap” 属性引用 map 元素中的 “id” 或 “name” 属性（根据浏览器），所以我们同时向 map 元素添加了 “id” 和 “name” 属性。</p></blockquote><p>（1）要想建立图片热点区域，必须先插入图片。注意，图片必须增加 usemap 属性，说明该图像是热区映射图像，属性值必须以 <code>“#”</code> 开头，如 <code>#pic</code>。</p><p>（2）<code>img</code> 元素中的 <code>&quot;usemap&quot;</code> 属性引用 <code>map</code> 元素中的 <code>&quot;id&quot;</code> 或 <code>&quot;name&quot;</code> 属性（根据浏览器），所以我们同时向 <code>map</code> 元素添加了 <code>&quot;id&quot;</code> 和 <code>&quot;name&quot;</code> 属性。(已知 Chrome 是使用 name 属性的！！！)</p><p>（3）<code>&lt;area&gt;</code> 总是嵌套在 <code>&lt;map&gt;</code> 标签中。它定义图像映射中的区域，主要是定义热点区域的形状及超链接。它有3个相应的属性：</p><ul><li><p>shape属性，控件划分区域的形状，其取值有3个，分别是 rect（矩形）、circle（圆形）和 poly（多边形）。</p><ul><li>如果 shape 属性取值为 rect，那么 coords 的设置值分别为矩形的左上角 x、y 坐标点和右下角x、y坐标点，单位为像素。</li><li>如果 shape 属性取值为 circle，那么 coords 的设置值分别为圆形圆心 x、y 坐标点和半径值，单位为像素。</li><li>如果 shape 属性取值为 poly，那么 coords 的设置值分别为多边形在各个点 x、y 坐标，单位为像素。</li></ul></li><li><p>coords 属性，控制区域的划分坐标。</p></li><li><p>href 属性是为区域设置超链接的目标，设置值为 <code>“#”</code> 时，表示为空链接。</p></li></ul><blockquote><p>上面示例运行结果截图如下：<br><br><a href="https://up.media.everdo.cn/image/K8S" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html_maparea.jpg" alt="html_maparea.jpg"></a></p></blockquote><h3 id="DreamWeaver-实现"><a href="#DreamWeaver-实现" class="headerlink" title="DreamWeaver 实现"></a>DreamWeaver 实现</h3><p>使用Dreamweaver CC可以很方便地快速且能精确定位热点区域。</p><p>01 创建一个HTML文档，插入一个图片文件。（这里以我之前搭建的公众号的网站 <a href="https://blog.everdo.cn" target="_blank" rel="noopener">Everdo博客</a> 的 banner 为例）</p><p><a href="https://up.media.everdo.cn/image/H4xl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/map-area.jpg" alt="map-area.jpg"></a></p><p>02 选中图片，在Dreamweaver CC中打开【属性】面板，面板左下角有3个蓝色图标按钮，依次代表矩形、圆形和多边形热点区域。单击左边的【矩形热点】工具图标</p><p><a href="https://up.media.everdo.cn/image/HHC0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/map-area-1.jpg" alt="map-area-1.jpg"></a></p><p>03 在设计视图，将鼠标指针移动到图片上，从左上方向右下方拖曳，得到矩形区域</p><p><a href="https://up.media.everdo.cn/image/HPJD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/map-area-2.jpg" alt="map-area-2.jpg"></a></p><p>04 如果绘制出来的矩形热区有误差，可以通过【属性】面板中的【指针热点】工具进行编辑</p><p>05 完成上述操作之后，保持矩形热区被选中状态，然后在【属性】面板中的【链接】文本框中输入该热点区域链接对应的跳转目标页面。</p><p><a href="https://up.media.everdo.cn/image/HIdL" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/map-area-3.jpg" alt="map-area-3.jpg"></a></p><p>06 到此为止，使用热点区域制作网站的导航就完成了。此时页面相应的HTML源代码如下：</p><p><a href="https://up.media.everdo.cn/image/Hh1c" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/map-area-4.jpg" alt="map-area-4.jpg"></a></p><blockquote><p>Tips：不推荐使用 HTML 的 热点map 属性来创建 banner，这个工具更适合用来创建地图里的超链接。</p></blockquote><h2 id="浮动框架-iFrame"><a href="#浮动框架-iFrame" class="headerlink" title="浮动框架 iFrame"></a>浮动框架 iFrame</h2><p>HTML5中已经不支持frameset框架，但是它仍然支持iframe浮动框架的使用。浮动框架可以自由控制窗口大小，可以配合表格随意地在网页的任何位置插入窗口。</p><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>使用iframe创建浮动框架的格式如下：</p><pre><code class="html">&lt;iframe src=&quot;链接对象&quot;&gt; &lt;/iframe&gt;</code></pre><p>其中，src表示浮动框架中显示对象的路径，可以是绝对路径，也可以是相对路径。</p><h3 id="高级属性"><a href="#高级属性" class="headerlink" title="高级属性"></a>高级属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>URL</td><td>规定在 iframe 中显示的文档的 URL。</td></tr><tr><td>srcdoc</td><td>HTML_code</td><td>规定在 <code>&lt;iframe&gt;</code> 中显示的页面的 HTML 内容。</td></tr><tr><td>align</td><td>left，right，top，middle，bottom</td><td>不赞成使用。请使用样式代替。规定如何根据周围的元素来对齐此框架。</td></tr><tr><td>frameborder</td><td>1，0</td><td>规定是否显示框架周围的边框。</td></tr><tr><td>width</td><td>pixels %</td><td>定义 iframe 的宽度。</td></tr><tr><td>height</td><td>pixels %</td><td>规定 iframe 的高度。</td></tr><tr><td>longdesc</td><td>URL</td><td>规定一个页面，该页面包含了有关 iframe 的较长描述。</td></tr><tr><td>marginheight</td><td>pixels</td><td>定义 iframe 的顶部和底部的空白边距。</td></tr><tr><td>marginwidth</td><td>pixels</td><td>定义 iframe 的左侧和右侧的空白边距。</td></tr><tr><td>name</td><td>frame_name</td><td>规定 iframe 的名称。name 属性用于在 JavaScript 中引用元素，或者作为链接的目标。</td></tr><tr><td>sandbox</td><td>“”，allow-forms，allow-same-origin，allow-scripts，allow-top-navigation</td><td>启用一系列对 <code>&lt;iframe&gt;</code> 中内容的额外限制。</td></tr><tr><td>scrolling</td><td>yes,no,auto</td><td>规定是否在 iframe 中显示滚动条。</td></tr></tbody></table><h3 id="进阶样例"><a href="#进阶样例" class="headerlink" title="进阶样例"></a>进阶样例</h3><p>这里的例子使用 jquery 方式使得 iframe 高度自适应文档内容(由于js载入框架不能跨域 <strong><a href="#%E8%A1%A5%E5%85%85%EF%BC%9AiFrame-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">见补充内容</a></strong>，代码运行结果暂时使用纯的 html 进行 iFrame)。完整JS载入的 iFrame 效果看我博客页面 <a href="https://huxiaofan.com/diary/everdo-shengdanjie/" target="_blank" rel="noopener">https://huxiaofan.com/diary/everdo-shengdanjie/</a></p><pre><code class="html">ps：这个例子是我做的一期公众号交互推文，是不是很好看呀！！喵喵喵&lt;iframe name=&quot;hxf&quot; onload=&quot;this.height=hxf.document.body.scrollHeight&quot; src=&quot;https://huxiaofan.com/doc/2019-12-25/everdo-hxf-blog.html&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;0px&quot;&gt;加载中……&lt;/iframe&gt;</code></pre><a href="https://huxiaofan.com/diary/everdo-shengdanjie/" target="_blank"><iframe name="hxf" src="https://huxiaofan.com/doc/2019-12-25/everdo-hxf-blog.html" frameborder="0" scrolling="yes" width="100%" height="800px">加载中……</iframe></a><br><h3 id="补充：iFrame-跨域问题"><a href="#补充：iFrame-跨域问题" class="headerlink" title="补充：iFrame 跨域问题"></a>补充：iFrame 跨域问题</h3><p>我们可以通过在服务端设置HTTP头部中的 X-Frame-Options（旧式浏览器） 和 Content-Security-Policy（新式浏览器） 信息来控制允许哪些站点对我们进行 iFrame。</p><p>这里我们为了让本站域名 coding.emptinessboy.com 可以引用我博客 huxiaofan.com 的 html,因此需要在 nginx.conf 添加.在服务端设置的方式如下：</p><pre><code class="nginx">Nginx 配置:add_header X-Frame-Options &quot;ALLOW-FROM coding.emptinessboy.com huxiaofan.com&quot;;add_header Content-Security-Policy &quot;frame-ancestors coding.emptinessboy.com huxiaofan.com&quot;;</code></pre><p>目前出于安全考虑，无法 <code>&lt;iframe&gt;</code> 使用JavaScript 访问其他来源的内容，如果可以的话，这将是一个巨大的安全漏洞。对于同源策略， 浏览器会阻止脚本尝试访问来源不同的框架。</p><p>如果未保留地址的以下至少之一，则认为起源是不同的：</p><pre><code class="html">&lt;protocol&gt;://&lt;hostname&gt;:&lt;port&gt;/...</code></pre><p>如果要访问框架，协议，主机名和端口必须与原始域相同</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 02-文本和图像</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-02-%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-02-%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h2><h3 id="直接在DreamWeaver粘贴"><a href="#直接在DreamWeaver粘贴" class="headerlink" title="直接在DreamWeaver粘贴"></a>直接在DreamWeaver粘贴</h3><p>略</p><h3 id="特殊文字符号"><a href="#特殊文字符号" class="headerlink" title="特殊文字符号"></a>特殊文字符号</h3><p>如何在网页上显示这些特殊字符(字符转义) 每个行业都有自己的行业特性，如数学、物理和化学都有特殊的符号</p><p>在HTML中，特殊字符以“&amp;”开头，以“；”结尾，中间为相关字符编码</p><a id="more"></a><p><a href="https://up.media.everdo.cn/image/OCj" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/specialword-html5.jpg" alt="specialword-html5.jpg"></a></p><blockquote><p>技巧提示：尽量不要使用多个 <code>“&amp;nbsp”</code> 来表示多个空格，因为多数浏览器对空格的距离实现是不一样的。</p></blockquote><h3 id="文本特殊样式"><a href="#文本特殊样式" class="headerlink" title="文本特殊样式"></a>文本特殊样式</h3><p>文本特殊样式在文档中经常会出现重要文本（加粗显示）、倾斜文本、上标和下标文本等。</p><h4 id="重要文本"><a href="#重要文本" class="headerlink" title="重要文本"></a>重要文本</h4><pre><code class="html">&lt;p&gt;&lt;b&gt;我是粗体文字&lt;/b&gt; &lt;/p&gt;</code></pre><p><b>我是粗体文字</b></p><pre><code class="html">&lt;p&gt;&lt;strong&gt;我是加强调文字&lt;/strong&gt;&lt;/p&gt;</code></pre><p><strong>我是加强调文字</strong></p><h4 id="倾斜文本"><a href="#倾斜文本" class="headerlink" title="倾斜文本"></a>倾斜文本</h4><pre><code class="html">&lt;p&gt;&lt;i&gt;我是倾斜文字&lt;/i&gt;&lt;/p&gt;</code></pre><p><i>我是倾斜文字</i></p><pre><code class="html">&lt;p&gt;&lt;em&gt;我是强调文字&lt;/em&gt;&lt;/p&gt;</code></pre><p><em>我是强调文字</em></p><blockquote><p>就表现而言 <code>&lt;em&gt;&lt;/em&gt;,&lt;i&gt;&lt;/i&gt;</code> 表现都一样，都是表示斜体。但是 <code>&lt;em&gt;</code> 标签是“含有语义”的标签，搜索引擎会了解这些语义。其在HTML中是特意被设定为表示“强调”的意思。当发现这些表示“强调”的标签时，一些屏幕阅读器可能使用不同的inflection，更利于SEO。</p></blockquote><h4 id="上标下标文本"><a href="#上标下标文本" class="headerlink" title="上标下标文本"></a>上标下标文本</h4><p>在HTML中用 <code>&lt;sup&gt;</code> 标记实现上标文字，用 <code>&lt;sub&gt;</code> 标记实现下标文字。<code>&lt;sup&gt;</code> 和 <code>&lt;sub&gt;</code> 都是<strong>双标记</strong>，放在开始标记和结束标记之间的文本会分别以上标或下标形式出现。</p><p>EG:可以套娃！</p><p>在HTML中用<code>&lt;sup&gt;</code>标记<sup>实现上标文字，</sup>用<code>&lt;sub&gt;</code>标记<sub>实现下标文字。<code>&lt;sup&gt;</code><sup>和<code>&lt;sub&gt;</code><sub>都是双标记，放在开始标记和结束标记之间的文本会分别以上标或下标形式出现。</sub></sup></sub></p><h2 id="文本排版"><a href="#文本排版" class="headerlink" title="文本排版"></a>文本排版</h2><h3 id="换行和标题"><a href="#换行和标题" class="headerlink" title="换行和标题"></a>换行和标题</h3><p>换行标记 <code>&lt;br/&gt;</code> 与段落标记 <code>&lt;p&gt;</code></p><p>标题标记 <code>&lt;h1&gt;～&lt;h6&gt;</code> 作为标题，它们的重要性是有区别的，其中 <code>&lt;h1&gt;</code> 标题的重要性最高，<code>&lt;h6&gt;</code> 的最低。</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用 <code>&lt;hr /&gt;</code> 可以创建一条水平线。</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="建立无序列表-lt-ul-gt"><a href="#建立无序列表-lt-ul-gt" class="headerlink" title="建立无序列表 &lt;ul&gt;"></a>建立无序列表 <code>&lt;ul&gt;</code></h4><ul><li>无序列表使用一对标记 <code>&lt;ul&gt;&lt;/ul&gt;</code></li><li>其中每一个列表项使用 <code>&lt;li&gt;&lt;/li&gt;</code></li><li>无序列表项中可以嵌套一个列表</li><li><code>&lt;li&gt;&lt;/li&gt;</code> 标记间又增加了一对 <code>&lt;ul&gt;&lt;/ul&gt;</code></li></ul><pre><code class="html">&lt;ul&gt;    &lt;li&gt;列表项第一行&lt;/li&gt;    &lt;li&gt;列表项第二行&lt;/li&gt;    &lt;ul&gt;    &lt;li&gt;列表嵌套项第一行&lt;/li&gt;    &lt;li&gt;列表嵌套项第二行&lt;/li&gt;    &lt;/ul&gt;    &lt;li&gt;列表项第三行&lt;/li&gt;&lt;/ul&gt;</code></pre><ul><li>列表项第一行</li><li>列表项第二行</li><ul><li>列表嵌套项第一行</li><li>列表嵌套项第二行</li></ul><li>列表项第三行</li></ul><h4 id="建立有序列表-lt-ol-gt"><a href="#建立有序列表-lt-ol-gt" class="headerlink" title="建立有序列表 &lt;ol&gt;"></a>建立有序列表 <code>&lt;ol&gt;</code></h4><p>它使用标记 <code>&lt;ol&gt;&lt;/ol&gt;</code>，每一个列表项使用 <code>&lt;li&gt;&lt;/li&gt;</code></p><pre><code class="html">&lt;ol&gt;    &lt;li&gt;列表项第一行&lt;/li&gt;    &lt;li&gt;列表项第二行&lt;/li&gt;    &lt;ol&gt;    &lt;li&gt;列表嵌套项第一行&lt;/li&gt;    &lt;li&gt;列表嵌套项第二行&lt;/li&gt;    &lt;/ol&gt;    &lt;li&gt;列表项第三行&lt;/li&gt;&lt;/ol&gt;</code></pre><ol><li>列表项第一行</li><li>列表项第二行</li><ol><li>列表嵌套项第一行</li><li>列表嵌套项第二行</li></ol><li>列表项第三行</li></ol><h2 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h2><h3 id="图像标记-lt-img-gt"><a href="#图像标记-lt-img-gt" class="headerlink" title="图像标记 &lt;img&gt;"></a>图像标记 <code>&lt;img&gt;</code></h3><p>在相对路径中，<code>“..”</code> 表示上一级目录，<code>“../..”</code> 表示上级的上级目录，依此类推<br>路径分隔符使用了 <code>“\”和“/”</code> 两种，其中 <code>“\”</code> 表示本地分隔符，<code>“/”</code> 表示网络分隔符。</p><p>图像可以美化网页，插入图像使用<strong>单标记</strong> <code>&lt;img /&gt;</code>。</p><blockquote><p>DW 中快速插入图片快捷键为 ctrl+alt+i</p></blockquote><pre><code class="html">&lt;img src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg&quot; alt=&quot;img方法&quot; title=&quot;img属性值和使用方法&quot;/&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg" alt="img方法" title="img属性值和使用方法"><br>### 文件路径<blockquote><p>在相对路径中，<code>“..”</code> 表示上一级目录，<code>“../..”</code> 表示上级的上级目录，依此类推<br>路径分隔符使用了 <code>“\”</code> 和 <code>“/”</code> 两种，其中 <code>“\”</code> 表示本地分隔符，“/”表示网络分隔符。</p></blockquote><p>绝对路径实例：</p><pre><code>E:\Webs\images\tp.jpg</code></pre><p>相对路径实例：</p><pre><code>./images/tp.jpg</code></pre><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><p>原则上，照片，背景等大图用 jpg ；透明图片使用 png ；动图使用 gif</p><p>矢量图 svg ；压缩图 webp</p><h3 id="图片宽高属性"><a href="#图片宽高属性" class="headerlink" title="图片宽高属性"></a>图片宽高属性</h3><p>图片显示的尺寸是由 width 和 height 控制的。当只有其中一个属性时，另一个就以图片原始长宽比例来显示。设定的宽高均为按比例缩放</p><pre><code class="html">指定宽高时，图片被压扁&lt;img src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg&quot; width=&quot;250px&quot; height=&quot;55px;&quot;/&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg" width="250px" height="55px;"><pre><code class="html">指定宽时，图片按原始比例缩放&lt;img src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg&quot; width=&quot;250px&quot;/&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg" width="250px"><pre><code class="html">指定高时，图片按原始比例缩放&lt;img src=&quot;https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg&quot; height=&quot;55px&quot;/&gt;</code></pre><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html-img.jpg" height="55px"><h2 id="Tips-lt-br-gt-和-lt-p-gt-lt-p-gt"><a href="#Tips-lt-br-gt-和-lt-p-gt-lt-p-gt" class="headerlink" title="Tips: &lt;br/&gt; 和 &lt;p&gt;&lt;/p&gt;"></a>Tips: <code>&lt;br/&gt;</code> 和 <code>&lt;p&gt;&lt;/p&gt;</code></h2><p>一般来说 <code>&lt;br/&gt;</code> 间距小于 <code>&lt;p&gt;&lt;/p&gt;</code> 不过可以用 CSS 调整他们</p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档整理 01-概述</title>
      <link href="/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2001-%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/03/HTML%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2001-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="概述部分"><a href="#概述部分" class="headerlink" title="概述部分"></a>概述部分</h2><p>HTML 是2014年10月发布的W3C推荐标准，是一种标记性语言</p><h3 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h3><p>HTML5对文档类型进行了简化，简单到15个字符就可以了，代码如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;</code></pre><p>技巧提示：Doctype申明需要出现在HTML文件的第一行。</p><a id="more"></a><h3 id="HTML标记"><a href="#HTML标记" class="headerlink" title="HTML标记"></a>HTML标记</h3><p>HTML标记代表文档的开始，由于HTML语言语法的松散特性，该标记可以省略，但是为了使之符合Web标准和文档的完整性，用户要养成良好的编写习惯，建议不要省略该标记。</p><pre><code class="html">&lt;html&gt; ... &lt;/html&gt;</code></pre><h3 id="头标记"><a href="#头标记" class="headerlink" title="头标记"></a>头标记</h3><p>头标记head用于说明文档头部相关信息，一般包括标题信息、元信息、定义CSS样式和脚本代码等。HTML的头部信息是以</p><head>开始，以<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/feed.xml" title="帆的自留地" type="application/atom+xml"></head>结束，语法格式如下：<p></p><pre><code class="html">&lt;head&gt; … &lt;/head&gt;</code></pre><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>标题一般是用来说明页面的用途的，它显示在浏览器的标题栏中</p><pre><code class="html">&lt;title&gt; … &lt;/title&gt;</code></pre><h4 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h4><meta>标记可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词<p><a href="https://up.media.everdo.cn/image/t7G" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/03/13/html-meta.jpg" alt="html-meta.jpg"></a></p><h5 id="（1）字符集charset属性"><a href="#（1）字符集charset属性" class="headerlink" title="（1）字符集charset属性"></a>（1）字符集charset属性</h5><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><h5 id="（2）搜索引擎的关键字优化"><a href="#（2）搜索引擎的关键字优化" class="headerlink" title="（2）搜索引擎的关键字优化"></a>（2）搜索引擎的关键字优化</h5><pre><code class="html">&lt;meta name=&quot;keywords&quot; content=&quot;关键字,keywords&quot; /&gt;</code></pre><p>不同的关键字之间应用 <strong>半角逗号隔开（英文输入状态下）</strong>，不要使用 “空格” 或 “|” 间隔；是 <strong>keywords，不是keyword</strong>；关键字标签中的内容应该是一个个的短语，而不是一段话。</p><p>关键字标记中的内容要与网页核心内容相关，确信使用的关键词出现在网页文本中。使用用户易于通过搜索引擎检索的关键字，过于生僻的词汇不太适合做meta标记中的关键字。不要重复使用关键字，否则可能会被搜索引擎惩罚。一个网页的关键字标记里最多包含3~5个最重要的关键字，不要超过5个。每个网页的关键字应该不一样。</p><p><em>目前它在搜索引擎排名中的作用很小。</em></p><h5 id="（3）页面描述meta-description"><a href="#（3）页面描述meta-description" class="headerlink" title="（3）页面描述meta description"></a>（3）页面描述meta description</h5><p>描述元标记是一种HTML元标记，用来简略描述网页的主要内容，通常被搜索引擎用于搜索结果页上展示给最终用户看的一段文字片段。</p><pre><code class="html">&lt;meta name=&quot;description&quot; content=&quot;网页的介绍&quot; /&gt;</code></pre><h5 id="（4）页面定时跳转"><a href="#（4）页面定时跳转" class="headerlink" title="（4）页面定时跳转"></a>（4）页面定时跳转</h5><p>使用 <code>&lt;meta&gt;</code> 标记可以使网页在经过一定时间后自动刷新，可以通过将http-equiv属性值设置为refresh来实现。content属性值可以设置为更新时间。</p><pre><code class="html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒;[url=网址]&quot; /&gt;</code></pre><p>例如，实现每5秒刷新一次页面，将下述代码放入head标记部分即可。</p><pre><code class="html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot; /&gt;</code></pre><h2 id="网页的主体标记-body"><a href="#网页的主体标记-body" class="headerlink" title="网页的主体标记 body"></a>网页的主体标记 body</h2><p>网页所要显示的内容都放在网页的主体标记内，它是HTML文件的重点所在，后面章节所要介绍的HTML标记都将放在这个标记内。然而它并不仅仅是一个形式上的标记，它本身也可以控制网页的背景颜色或背景图像，这会在后面进行介绍。主体标记是以 <code>&lt;body&gt;</code> 开始，以 <code>&lt;/body&gt;</code> 结束，</p><blockquote><p>注意，在构建HTML结构时，标记不允许交错出现，否则会造成错误。</p></blockquote><h2 id="页面注释标记"><a href="#页面注释标记" class="headerlink" title="页面注释标记"></a>页面注释标记</h2><pre><code class="html">&lt;!-- 被注释内容 --&gt;</code></pre><h2 id="一些变化"><a href="#一些变化" class="headerlink" title="一些变化"></a>一些变化</h2><ul><li><p>标签不再区分大小写</p></li><li><p>在HTML5中，属性值不放在引号中也是正确的</p><ul><li><code>&lt;input checked=&quot;a&quot; type=&quot;checkbox&quot;/&gt;</code> 与 <code>&lt;input checked=a type=checkbox/&gt;</code> 相同</li><li>仍然建议读者加上引号</li></ul></li><li><p>允许部分属性值的属性省略</p><ul><li><code>&lt;input checked type=&quot;checkbox&quot;/&gt; &lt;input readonly type=&quot;text&quot;/&gt;</code></li><li>其中<code>checked=&quot;checked&quot;</code>省略为checked，而<code>readonly=&quot;readonly&quot;</code>省略为readonly。</li></ul></li></ul><br>HTML5中的标记分为单标记和双标记。所谓单标记是指没有结束标记的标记，双标记是指既有开始标记又包含结束标记。 例如```<br>```<p>HTML5中不允许写结束标记的 <strong>单标记</strong> 元素有</p><pre><code class="html">&lt;area/&gt;  &lt;base/&gt;  &lt;br/&gt;  &lt;col/&gt;  &lt;command/&gt;  &lt;embed/&gt;  &lt;hr/&gt;  &lt;img/&gt;  &lt;input/&gt;  &lt;keygen/&gt;  &lt;link/&gt;  &lt;meta/&gt;  &lt;param/&gt;  &lt;source/&gt;  &lt;track/&gt;  &lt;wbr/&gt;</code></pre><p>HTML5中允许省略结束标记的 <strong>双标记</strong> 元素有</p><pre><code class="html">&lt;li&gt;  &lt;dt&gt;  &lt;dd&gt;  &lt;p&gt;  &lt;rt&gt;  &lt;rp&gt;  &lt;optgroup&gt;  &lt;option&gt;  &lt;colgroup&gt;  &lt;thead&gt;  &lt;tbody&gt;  &lt;tfoot&gt;  &lt;tr&gt;  &lt;td&gt;  &lt;th&gt;</code></pre><h2 id="Html快速构建新的模板"><a href="#Html快速构建新的模板" class="headerlink" title="Html快速构建新的模板"></a>Html快速构建新的模板</h2><pre><code class="html">&lt;!-- author: @emptinessboy huxiaofan.com --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;关键字,keywords&quot; /&gt;        &lt;meta name=&quot;description&quot; content=&quot;网页的介绍&quot; /&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="在线代码校验"><a href="#在线代码校验" class="headerlink" title="在线代码校验"></a>在线代码校验</h2><p>HTML5语法的新变化为了兼容各个不统一的页面代码，HTML5的设计在语法方面做了以下变化</p><p>在线校验 <a href="http://validator.w3.org/" target="_blank" rel="noopener">http://validator.w3.org/</a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAS系统选择与重复文件删除体验</title>
      <link href="/2020/02/WindowsServer%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/02/WindowsServer%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>前段时间，网上瞎买了些电子垃圾，动手组装了台 NAS , 开始打算用 FreeNas 系统组 ZFS 阵列。但是在看了 ZFS 的各种文档后发现 ZFS 虽然有着诱人的容量和性能的体验，但是却非常的消耗系统资源。此外 ZFS 的扩容方式和常见的 Raid 阵列都不一样，并不方便直接向存储池中添加磁盘。由于穷，没钱一次性买那么多硬盘，加之组装的 NAS 走的低功耗路线，性能相当菜（双核奔腾5400的CPU，加上8G内存），因此果断放弃。</p><ul><li><p>现在手里的硬件平台：</p><ul><li>G5400双核的CPU +8G内存</li><li>两块 4T 日立机械硬盘</li><li>8 盘位的机箱</li></ul></li><li><p>罗列了下自己的需求</p><ul><li>一个安全为主的存储池和一个性能较好的存储池</li><li>方便扩容的磁盘阵列</li><li>重复文件删除和 SSD 缓存加速</li><li>SMBA3 和 NFS 的文件共享需要</li></ul></li></ul><p>根据自己的计划，先利用两个盘位搭建一个安全为主的存储池用于存放相片等资料，剩余6个盘位等以后有钱了慢慢组 Raid5。</p><br><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>在网上逛了一圈，花了几天体验了包括黑群在内的诸多NAS系统，发现 Linux 平台除了 ZFS 均无法实现文件系统级别的重复文件删除。而 SSD 缓存加速也需要复杂的软件配置。FreeNas打头的 ZFS 以及其底层的 FreeBSD 系统较为难用，不适合家庭使用。唯一比较接近目标的黑群，又因为对万兆网卡（以后打算上）的兼容问题以及盗版系统的种种强迫症问题让我放弃选择。</p><p>回头看 Windows 平台，Server 版本的系统虽然具有重复文件删除的功能，但 Windows 对 raid 的支持明显没有 Linux 下那么完整，（例如无法支持 Raid6，可靠性不如 mdadm 等）</p><p>具体不同平台阵列的情况可以看下图（来自知乎@awpak78）</p><p><a href="https://up.media.everdo.cn/image/99B" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/datapool.jpg" alt="datapool.jpg"></a></p><p>至于 Winserver 分层缓存的奇偶校验存储池也因为上手门槛过高让小白的我难以下手。【DOG/哪个dalao会可以教教我】</p><p>在看了不少 Dalao 使用 Vmware 虚拟机操作系统 esxi 装 NASos 的文章后，我突然想到，或许可以使用免费开源的虚拟机系统 PVE（ProxmoxVE）来替代 esxi ，使用 linux 的 mdadm 来创建管理 raid 磁盘阵列。因为 PVE 系统基于 Debian ，虽然我之前习惯了 Centos ，但上手起来也没有太大的难度。</p><p>在 PVE 系统使用 mdadm 创建 RAID,然后使用 VT 硬件虚拟化，将 /dev/md0 磁盘阵列硬件直通到虚拟机的 WinServer 中，然后在 Windows 中创建 NTFS 或者 REFS 文件系统，并对之开启重复文件删除功能。至于 SSD 缓存加速则可以使用 Primocache 来实现。</p><p>这波方案虽然绕了点，却完美满足需求诶！！！</p><br><h2 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h2><p>在装好系统后，我先用手里的两个盘创建了 RAID1 阵列。</p><p><a href="https://up.media.everdo.cn/image/EOt" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/mdadm.jpg" alt="mdadm.jpg"></a></p><p>qm 命令配置直通给 Windows 后一切正常</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/fde3b5ec6d6be8546f04d5d40db8c536.jpg" alt="fde3b5ec6d6be8546f04d5d40db8c536.jpg"></p><p>成功创建文件系统，并拷入自己的数据</p><p><a href="https://up.media.everdo.cn/image/sxI" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/vdisk.jpg" alt="vdisk.jpg"></a></p><p>需要注意的是，在 PVE 下运行的虚拟机是采用 KVM 虚拟化的，搭配 VirtIO 半虚拟化技术才能发挥最佳性能。因此这里也费力些功夫将硬件配置为 QEMU HARDDISK。</p><br><h2 id="重复文件删除体验"><a href="#重复文件删除体验" class="headerlink" title="重复文件删除体验"></a>重复文件删除体验</h2><p>终于到了核心功能重复文件删除了。为什么采用重复文件删除？还得从我的懒习惯说起，我备份数据向来是想到的时候随手一复制，往往出现一份数据备份好几遍的情况【尴尬】。</p><p>有了重复文件删除功能，可以说解决了我老大难的问题了！</p><p>在 WinServer 系统中启用这项功能很简单，只要先为服务器添加这项功能，然后对卷启用就可以了。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/jiaosegn.jpg" alt="jiaosegn.jpg"></p><p>安装完功能进行一次重启，然后配置开启重复文件删除</p><p><a href="https://up.media.everdo.cn/image/Md4" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/cfwjsc1.jpg" alt="cfwjsc1.jpg"></a></p><p>可以看到刚开启的时候，重复文件删除率是0</p><p>因为系统是通过计划任务定时执行重复文件删除操作的，未来更快体验到效果，我使用下面的 Powershell 命令来手动运行一次优化任务。</p><p>以下的 Powershell 命令可以从微软官方文档中寻找到</p><blockquote><p>链接地址：<a href="https://docs.microsoft.com/zh-cn/powershell/module/deduplication/start-dedupjob?view=win10-ps" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><a href="https://up.media.everdo.cn/image/v0M" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/cfwjsc2.jpg" alt="cfwjsc2.jpg"></a></p><p>以下是我的操作，先导入 Powershell 命令模块</p><pre><code class="powershell">PS C:\&gt; Import-Module ServerManagerPS C:\&gt; Import-Module Deduplication</code></pre><p>然后运行 Start-DedupJob 命令开始优化（Volume后面的值改成自己需要优化的卷）</p><pre><code class="powershell">PS C:\&gt; Start-DedupJob –Volume D: –Type Optimization</code></pre><p>根据官方文档，还可以使用 <strong>Get-DedupJob</strong> 命令查询进度</p><p><a href="https://up.media.everdo.cn/image/y8Y" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/cfwjsc3.jpg" alt="cfwjsc3.jpg"></a></p><p>输完命令，静静等待奇迹发生吧！</p><p><a href="https://up.media.everdo.cn/image/XFa" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/cfwjsc4.jpg" alt="cfwjsc4.jpg"></a></p><p>可以看到任务由 Queued 转为 Running ，然后我听到了震耳欲聋的炒黄豆的声音（机械硬盘声音贼大！！！）</p><p>一个小时后……</p><p><a href="https://up.media.everdo.cn/image/C9s" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/cfwjsc5.jpg" alt="cfwjsc5.jpg"></a></p><p>已经可以通过GUI看到优化完成后的文件系统，居然已经删除了 103GB 的重复文件！！节省了大量的磁盘空间。可以说是穷买不起硬盘党的福音哇！</p><p>另外这种文件系统级别的重复文件删除不是真的把重复的两份文件直接删除，而是利用了像C语言里的指针类似的技术（emm，不知道理解的对不对），将重复的数据块指向相同的磁盘空间，从而节省磁盘空间。所以原先的文件目录结构等都不会发生变化。</p><p>NICE!! 巨硬打法好！</p><p><a href="https://up.media.everdo.cn/image/SU3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/27/Windows-server-2019.jpg" alt="Windows-server-2019.jpg"></a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA入坑之JDK环境安装到HelloWorld</title>
      <link href="/2020/02/JAVA%E5%AD%A6%E4%B9%A0%E4%B9%8BJDK%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2020/02/JAVA%E5%AD%A6%E4%B9%A0%E4%B9%8BJDK%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>受疫情影响，只好在家上网课了。这学期面向对象的程序设计教的是JAVA，因此开发环境第一波走起。</p><br><h2 id="什么是JDK-？"><a href="#什么是JDK-？" class="headerlink" title="什么是JDK ？"></a>什么是JDK ？</h2><p>JDK是用于使用Java编程语言构建应用程序和组件的开发环境。</p><p>JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。</p><p>因此想要进行 JAVA 开发，安装 JDK 就是第一步</p><br><h2 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h2><p>JDK 可以从它的开发公司 Oracle（甲骨文） 网站上下载。目前的最新版本是 13.0.2 ，由于之前老师分享的 JDK绿色版 <del>貌似有问题</del> 我环境变量配置的锅，因此去官网下载了最新版本。</p><blockquote><p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">JDK下载</a></p></blockquote><p>选定我们需要的版本，Windows64位可执行的exe版本，然后下载。由于甲骨文网站在国外，下载速度可能比较慢，必要的时候还得科学下。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk1.png" alt="jdk1.png"></p><p>下载完成后直接运行安装程序即可。这里有个坑提前说下，如果你的电脑之前已经安装过 JAVA (JRE) 或者其他版本的 JDK 这里可以先卸载一波，以免导致后面 JDK 和 JRE版本不一致的问题。<em>具体表现为 JAVAC 编译的二进制文件无法被 JAVA 命令直接运行。</em></p><br><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><p>安装很简单，基本上一路 NEXT 即可，这里我把 JDK安装路径设置到 D:\JAVA\jdk</p><p><a href="https://up.media.everdo.cn/image/Rn9" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk2.png" alt="jdk2.png"></a></p><p>这一步选择安装路径</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk3.png" alt="jdk3.png"></p><p>然后静静等待进度条跑完即可</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk4.png" alt="jdk4.png"></p><p>如果看到下面的提示，则表示 JDK 的所有文件已经全部成功解压到对应路径了。</p><p><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk5.png" alt="jdk5.png"></p><p>当然这一步使用非直接运行的压缩包版本也是可以的，两者的区别可能就是 EXE 版本系统会自动注册环境变量，并添加注册表项，方便后续卸载等。</p><br><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>如果是采用安装程序安装的 JDK ，理论上系统应该会自动配置环境变量。但是很不幸，在我的电脑上自动环境变量没有生效。所以手动配置一波。</p><p>环境变量的设置在 <strong>此电脑</strong> 右键–&gt; <strong>属性</strong> –&gt; <strong>高级系统设置</strong> –&gt; <strong>环境变量</strong> 里。</p><h3 id="JAVA-HOME-变量"><a href="#JAVA-HOME-变量" class="headerlink" title="JAVA_HOME 变量"></a>JAVA_HOME 变量</h3><p>打开后，我们先新增 JAVA_HOME 变量</p><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>D:\Java\jdk-13.0.2</td></tr></tbody></table><p><a href="https://up.media.everdo.cn/image/3bn" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk6.png" alt="jdk6.png"></a></p><p>由于我的 JDK 安装目录为 <em>D:\Java\jdk-13.0.2</em> 所以此处 JAVA_HOME 变量值为我的安装路径</p><h3 id="CLASS-PATH-变量"><a href="#CLASS-PATH-变量" class="headerlink" title="CLASS_PATH 变量"></a>CLASS_PATH 变量</h3><p>此处 CLASS_PATH 变量同样是新增。由于我们已经配置了 JAVA_HOME 此处变量即可引用 %JAVA_HOME% 这样在以后升级 JDK 的时候可以很方便的切换到最新的版本。</p><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>CLASS_PATH</td><td>.;%JAVA_HOME%\lib;</td></tr></tbody></table><p><a href="https://up.media.everdo.cn/image/DLQ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk9.png" alt="jdk9.png"></a></p><p>注意：JDK8 在配置 CLASS_PATH 的时候则配置为</p><pre><code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></pre><h3 id="path-变量"><a href="#path-变量" class="headerlink" title="path 变量"></a>path 变量</h3><p>做完了这两步，我们还有最关键的 path 变量。不同于前两条的新建。 path 变量的添加则是在系统已经存在在变量值后面追加两条。一条定位到 JDK 安装目录下面的 bin ，另一条定位到 JRE 目录下面的 bin 。</p><pre><code>%JAVA_HOME%\jre\bin%JAVA_HOME%\bin</code></pre><p><a href="https://up.media.everdo.cn/image/YFJ" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk7.png" alt="jdk7.png"></a></p><p>选中 path 后双击追加变量值</p><p><a href="https://up.media.everdo.cn/image/AzS" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk8.png" alt="jdk8.png"></a></p><p>添加这两行后直接保存即可。</p><br><h2 id="生成-JRE"><a href="#生成-JRE" class="headerlink" title="生成 JRE"></a>生成 JRE</h2><p>什么？！！！为什么在 CMD 输入java 报错？但 javac 却正常？！！</p><p>其实到这里我们的 JRE 还没有生成，所以 java 命令是不能运行的。</p><p>那么 jre 到底是什么？</p><blockquote><p>Java运行环境（Java Runtime Environment，简称JRE）是一个软件，由太阳微系统所研发，JRE可以让计算机系统运行Java应用程序。JRE的内部有一个Java虚拟机 JVM 以及一些标准的类别函数库（Class Library）</p></blockquote><p>Oracle 的 JDK 在 13.0 版本默认不自动安装 JRE 。因此我们现在在 JDK 安装路径下看不到 JRE 这个文件夹。</p><p><a href="https://up.media.everdo.cn/image/bmy" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk10.png" alt="jdk10.png"></a></p><p>大概就是我现在这个亚子的</p><p>而想要让 JDK13 生成 JRE 的很简单。只需要在 %JAVA_HOME% 下面运行下面的 powershell 命令即可</p><pre><code class="powershell">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code></pre><p><a href="https://up.media.everdo.cn/image/dOd" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk11.png" alt="jdk11.png"></a></p><p>要注意的是，运行前要CD到 JDK 安装目录。运行后就可以看到，JDK 的安装目录下面有了 JRE 文件夹</p><p><a href="https://up.media.everdo.cn/image/inl" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk12.png" alt="jdk12.png"></a></p><p>这时候，再次运行 JAVA 命令，可以看到有输出结果了</p><p><a href="https://up.media.everdo.cn/image/rq0" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk13.png" alt="jdk13.png"></a></p><p>同样运行 JAVAC 测试下</p><p><a href="https://up.media.everdo.cn/image/QXD" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk14.png" alt="jdk14.png"></a></p><p>查看下两者的版本是否一致</p><p><a href="https://up.media.everdo.cn/image/x4L" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk15.png" alt="jdk15.png"></a></p><p>另外说明下，之前我尝试过从官网下载 jre 然后解压到 jdk 的目录下。这种情况 java 和 javac 都可以正常运行。但是由于 jdk 和 jre 版本不同（sdk不同），很可能出现javac 编译的程序不能被 jre 运行。</p><br><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World !!!"></a>Hello World !!!</h2><p>现在到了最振奋人心的 Hello World 时刻了。</p><p>来首 Hello World 压压惊。【滑稽】</p><p>打开文本编辑器，这里我用的 vstudio ，粘贴下面的 Hello World 代码，保存为 HelloWorld.java （这里文件名要和代码里的 class 一致，包括大小写）</p><p><a href="https://up.media.everdo.cn/image/Wbc" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk16.png" alt="jdk16.png"></a></p><p>代码如下，可直接复制：</p><pre><code class="java">class HelloWorld{  public static void main(String[] arr){  System.out.print(&quot;HELLO WORLD&quot;); }}</code></pre><p>保存为文件后，我们执行两个命令。(需要先 cd 进入到对应的文件夹)</p><pre><code class="powershell">cd c:\users\huxia\desktopjavac HelloWorld.java</code></pre><p><em>吐槽下，沙雕微软为什么把邮箱的前几个字母做文件夹名</em></p><p>如果你和我一样，看到桌面上多出来一个 HelloWorld.class 的二进制文件，那么恭喜你，HelloWorld 程序已经编译成功啦！！</p><p>最后我们执行命令</p><pre><code class="powershell">java HelloWorld</code></pre><p><a href="https://up.media.everdo.cn/image/602" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/jdk17.png" alt="jdk17.png"></a></p><p>看到成功输出欢迎信息。WOW，干杯！！</p><br><hr><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>到了今天 4月15日 其实 jdk 的 14.0.1 版本已经放出来了。更新过程很简单，一样下载安装后，记住解压缩路径。然后修改 JAVA_HOME</p><pre><code>%JAVA_HOME% 改为 D:\Java\jdk-14.0.1</code></pre><p>最后只要在 IED 根据需要更新项目使用的 JDK 即可！</p><br><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> JAVA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mark Down 之简单入门</title>
      <link href="/2020/02/Mark-Down-%E4%B9%8B%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
      <url>/2020/02/Mark-Down-%E4%B9%8B%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>Markdown 是一种轻量级的标记语言，它允许人们使用易读易写的纯文本格式编写文档，借助可实现快速排版且转换成格式丰富的HTML页面。目前被越来越多的写作爱好者及工作者使用。</p><p>Markdown 编写的文档后缀为 <strong>.md</strong> ，<strong>.markdown</strong></p><br><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在 Markdown 中总共有6个标题，我们分别把它们称为：一级标题、二级标题、三级标题、四级标题、五级标题和六级标题。其中六级标题最小，一级标题最大。</p><pre><code class="markdown"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p><a href="https://up.media.everdo.cn/image/nm3" target="_blank" rel="noopener"><img src="https://media.everdo.cn/tank/pic-bed/2020/02/26/markdown-.md.png" alt="markdown-.md.png"></a></p><br><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在Markdown之中我们会发现文字无法换行，始终集中在一行之中。这时如果需要换行那么该怎么办呢？<br>在这里我们可以使用“换行标签”（<code>&lt;/br&gt;</code>）。</p><p>Ps:在一些 Markdown 编辑器中，如：网易云笔记的 Markdown 编辑器中空格+换行键(Enter)，也可以实现换行功能。</p><pre><code class="markdown">上段文字&lt;/br&gt;下段文字</code></pre><p>上段文字<br><br><br>下段文字</p><br><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释代码如下：</p><pre><code class="markdown">[任意字符]:对括号内容的注释，两者均不显示如 [^_^]:哈哈哈哈哈哈</code></pre><p>这里干干净净什么都没有</p><br><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在我们想要引用一句话的时候，我们在 Markdown 中使用如下代码：</p><pre><code class="markdown">代码格式：&gt;引用的内容</code></pre><blockquote><p>引用话语：人类的本质是复读机</p></blockquote><br><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="markdown">---</code></pre><hr><br><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><p>在 Markdown 中有：斜体、加粗、高亮、划线。这些文字样式供我们选择，代码如下：</p><pre><code class="markdwon">*斜体***加粗*****粗斜体文本***==高亮==&lt;u&gt;下划线&lt;/u&gt;~~删除线~~</code></pre><p><em>斜体</em></p><p><strong>加粗</strong></p><p><strong><em>粗斜体文本</em></strong></p><p>==高亮==</p><p><u>下划线</u></p><p><del>删除线</del></p><p>但如果我们想修改文字 大小 / 颜色 / 字体，就要用 font 标签，( Ps：center和font都是html的标签，在markdown也能用 )</p><pre><code class="html">&lt;font color=#2196F3 size=2 face=&quot;微软雅黑&quot;&gt;微软雅黑大小为2的字&lt;/font&gt;</code></pre><p>color代表字体颜色（要用16进制颜色值），size代表文字大小，face代表字体</p><p><font color="#2196F3" size="2" face="微软雅黑">微软雅黑大小为2的字</font></p><p>实现“文字居中”就要center标签，代码如下：</p><pre><code class="html">&lt;center&gt;居中&lt;/center&gt;</code></pre><center>居中</center><h2 id="链接以及图片"><a href="#链接以及图片" class="headerlink" title="链接以及图片"></a>链接以及图片</h2><p>在 Markdown 中添加链接和图片有异曲同工之妙，所以我们放在一起来讲，代码如下：</p><pre><code class="markdwon">代码格式链接：[显示名称](链接)[这里是链接](https://coding.emptinessboy.com/)代码格式图片：![名称](图片链接)![这样是图片](https://coding.emptinessboy.com/img/logo.png)</code></pre><p><a href="https://coding.emptinessboy.com/">这里是链接</a><br><img src="https://coding.emptinessboy.com/img/logo.png" alt="这样是图片"></p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>在Markdown中如果我们想要高亮一段代码，可以使用如下代码：</p><pre><code class="markdown">  ```key    代码 (把key换成代码类型)    ```</code></pre><table><thead><tr><th>语言</th><th>对应的 key</th></tr></thead><tbody><tr><td>1C</td><td>1c</td></tr><tr><td>ActionScript</td><td>actionscript</td></tr><tr><td>Apache</td><td>apache</td></tr><tr><td>AppleScript</td><td>applescript</td></tr><tr><td>AsciiDoc</td><td>asciidoc</td></tr><tr><td>AspectJ</td><td>asciidoc</td></tr><tr><td>AutoHotkey</td><td>autohotkey</td></tr><tr><td>AVR Assembler</td><td>avrasm</td></tr><tr><td>Axapta</td><td>axapta</td></tr><tr><td>Bash</td><td>bash</td></tr><tr><td>BrainFuck</td><td>brainfuck</td></tr><tr><td>Cap’n Proto</td><td>capnproto</td></tr><tr><td>Clojure REPL</td><td>clojure</td></tr><tr><td>Clojure</td><td>clojure</td></tr><tr><td>CMake</td><td>cmake</td></tr><tr><td>CoffeeScript</td><td>coffeescript</td></tr><tr><td>C++</td><td>cpp</td></tr><tr><td>C#</td><td>cs</td></tr><tr><td>CSS</td><td>css</td></tr><tr><td>D</td><td>d</td></tr><tr><td>Dart</td><td>d</td></tr><tr><td>Delphi</td><td>delphi</td></tr><tr><td>Diff</td><td>diff</td></tr><tr><td>Django</td><td>django</td></tr><tr><td>DOS.bat</td><td>dos</td></tr><tr><td>Dust</td><td>dust</td></tr><tr><td>Elixir</td><td>elixir</td></tr><tr><td>ERB(Embedded Ruby)</td><td>erb</td></tr><tr><td>Erlang REPL</td><td>erlang-repl</td></tr><tr><td>Erlang</td><td>erlang</td></tr><tr><td>FIX</td><td>fix</td></tr><tr><td>F#</td><td>fsharp</td></tr><tr><td>G-code(ISO 6983)</td><td>gcode</td></tr><tr><td>Gherkin</td><td>gherkin</td></tr><tr><td>GLSL</td><td>glsl</td></tr><tr><td>Go</td><td>go</td></tr><tr><td>Gradle</td><td>gradle</td></tr><tr><td>Groovy</td><td>groovy</td></tr><tr><td>Haml</td><td>haml</td></tr><tr><td>Handlebars</td><td>handlebars</td></tr><tr><td>Haskell</td><td>haskell</td></tr><tr><td>Haxe</td><td>haxe</td></tr><tr><td>HTML</td><td>html</td></tr><tr><td>HTTP</td><td>http</td></tr><tr><td>Ini file</td><td>ini</td></tr><tr><td>Java</td><td>java</td></tr><tr><td>JavaScript</td><td>javascript</td></tr><tr><td>JSON</td><td>json</td></tr><tr><td>Lasso</td><td>lasso</td></tr><tr><td>Less</td><td>less</td></tr><tr><td>Lisp</td><td>lisp</td></tr><tr><td>LiveCode</td><td>livecodeserver</td></tr><tr><td>LiveScript</td><td>livescript</td></tr><tr><td>Lua</td><td>lua</td></tr><tr><td>Makefile</td><td>makefile</td></tr><tr><td>Markdown</td><td>markdown</td></tr><tr><td>Mathematica</td><td>mathematica</td></tr><tr><td>Matlab</td><td>matlab</td></tr><tr><td>MEL (Maya Embedded Language)</td><td>mel</td></tr><tr><td>Mercury</td><td>mercury</td></tr><tr><td>Mizar</td><td>mizar</td></tr><tr><td>Monkey</td><td>monkey</td></tr><tr><td>Nginx</td><td>nginx</td></tr><tr><td>Nimrod</td><td>nimrod</td></tr><tr><td>Nix</td><td>nix</td></tr><tr><td>NSIS</td><td>nsis</td></tr><tr><td>Objective C</td><td>objectivec</td></tr><tr><td>OCaml</td><td>ocaml</td></tr><tr><td>Oxygene</td><td>oxygene</td></tr><tr><td>Parser 3</td><td>parser3</td></tr><tr><td>Perl</td><td>perl</td></tr><tr><td>PHP</td><td>php</td></tr><tr><td>PowerShell</td><td>powershell</td></tr><tr><td>Processing</td><td>processing</td></tr><tr><td>Python’s profiler output</td><td>profile</td></tr><tr><td>Protocol Buffers</td><td>protobuf</td></tr><tr><td>Puppet</td><td>puppet</td></tr><tr><td>Python</td><td>python</td></tr><tr><td>Q</td><td>q</td></tr><tr><td>R</td><td>r</td></tr><tr><td>RenderMan RIB</td><td>rib</td></tr><tr><td>Roboconf</td><td>roboconf</td></tr><tr><td>RenderMan RSL</td><td>rsl</td></tr><tr><td>Ruby</td><td>ruby</td></tr><tr><td>Oracle Rules Language</td><td>ruleslanguage</td></tr><tr><td>Rust</td><td>rust</td></tr><tr><td>Scala</td><td>scala</td></tr><tr><td>Scheme</td><td>scheme</td></tr><tr><td>Scilab</td><td>scilab</td></tr><tr><td>SCSS</td><td>scss</td></tr><tr><td>Smali</td><td>smali</td></tr><tr><td>SmallTalk</td><td>smalltalk</td></tr><tr><td>SML</td><td>sml</td></tr><tr><td>SQL</td><td>sql</td></tr><tr><td>Stata</td><td>stata</td></tr><tr><td>STEP Part21(ISO 10303-21)</td><td>step21</td></tr><tr><td>Stylus</td><td>stylus</td></tr><tr><td>Swift</td><td>swift</td></tr><tr><td>Tcl</td><td>tcl</td></tr><tr><td>Tex</td><td>tex</td></tr><tr><td>text</td><td>text/plain</td></tr><tr><td>Thrift</td><td>thrift</td></tr><tr><td>Twig</td><td>twig</td></tr><tr><td>TypeScript</td><td>typescript</td></tr><tr><td>Vala</td><td>vala</td></tr><tr><td>VB.NET</td><td>vbnet</td></tr><tr><td>VBScript in HTML</td><td>vbscript-html</td></tr><tr><td>VBScript</td><td>vbscript</td></tr><tr><td>Verilog</td><td>verilog</td></tr><tr><td>VHDL</td><td>vhdl</td></tr><tr><td>Vim Script</td><td>vim</td></tr><tr><td>Intel x86 Assembly</td><td>x86asm</td></tr><tr><td>XL</td><td>xl</td></tr><tr><td>XML</td><td>xml</td></tr><tr><td>YAML</td><td>yml</td></tr></tbody></table><br><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>在 Markdown 中我们可以绘制列表，代码格式如下：</p><pre><code class="markdown">- 列表1  - 列表1.1  - 列表1.2</code></pre><ul><li>列表1<ul><li>列表1.1</li><li>列表1.2</li></ul></li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>在 Markdown 中我们可以绘制列表，代码格式如下：</p><pre><code class="markdown">1. 列表1  - 列表1.1  - 列表1.2</code></pre><ol><li>列表1<ul><li>列表1.1</li><li>列表1.2</li></ul></li><li>列表2<ul><li>列表2.1</li><li>列表2.2</li></ul></li></ol><br><h2 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h2><p>在 Markdown 中你可以输入你最近的代办事项，代码格式如下：</p><pre><code class="markdown">- [ ] 未完成事项- [x] 已完成事项</code></pre><ul><li><input disabled type="checkbox"> 未完成事项</li><li><input checked disabled type="checkbox"> 已完成事项</li></ul><p>Ps：带x的代表已经完成的事项，空格的为还没有完成的事项</p><br><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在 Markdown 中我们同样可以绘制表格，代码格式如下 (Ps：第二行中 —|—|— 是有几个大标题就写几个。如果是两个就是 —|— ，四个就是 —|—|—|— )：</p><pre><code class="markdown">大标题1|大标题2|大标题3---|---|---内容1|内容2|内容3内容1|内容2|内容3</code></pre><table><thead><tr><th>大标题1</th><th>大标题2</th><th>大标题3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><br><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><pre><code class="markdown">在文章中引入[^1]内容[^1]:脚注说明文字</code></pre><p>文字内容 <a href="md是markdown文件的后缀名">^md</a></p><br><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>Markdown中的转义字符为\，若不想使符号变成文字的格式等，在符号前加\。</p><br><p><strong>至此以上列举的 Markdown 就已经足够我们在日常写作中使用了。还有更多高级操作，例如使用 Markdown 渲染流程图，甘特图等等因为需要引入插件，并不完美兼容所有平台，故暂时不做学习了。本文整理自网络</strong></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/hello-world/"/>
      <url>/2020/02/hello-world/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 28 2022 11:43:41 GMT+0800 (中国标准时间) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><img src="https://media.everdo.cn/tank/pic-bed/2021/04/09/4.png" alt="尾图4" style="zoom:33%"><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
